
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8"/>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta content="utf-8" http-equiv="encoding">
	<meta name="encrypt" content="cryptellegram, encryption, cipher, mail, email, message, photo, document, private">
	<meta name="private" content="cryptelle, email, mail, messsage, photo, document, secret, encrypt, .exe">
	<div id="showThis" style="display: inline-block;">
		<div id="loader-wrapper">
			<div id="loader"></div>
			<div class="loader-section section-left"></div>
			<div class="loader-section section-right"></div>
		</div>
	</div>
    <script src="/cryption/jsglue.js" type="text/javascript"></script>
	<title>Cryptheka</title>
	<link rel="stylesheet" href="/cryption/static/css/overseer.css" />
    <link rel="stylesheet" href="/cryption/static/css/datepicker.css" />
	<script type="text/javascript" src="../static/js/jquery-1.11.2.min.js"></script>
	<script type="text/javascript" src="../static/js/moment.js"></script>
    <!-- <script src="../static/js/cleave.min.js"></script> -->
    <script type="text/javascript" src="../static/js/datepicker.js"></script>
    <script type="text/javascript" src="../static/js/timepicker.js"></script>
	<script>
        console.log('==> ' + window.location.hostname);
        if (window.location.hostname == 'localhost') {
            console.log('\n\t\tEdit Mode\n')
            var editmode = 2; // 2-edit 1-online
        } else {
            console.log('\n\t\tOnline Mode\n')
            var editmode = 1;
        };
        var onlStatus = true;
        var specvew = 'A'; // 0,1,2,3,4,5,6,7,8,etc. A for all # view dictionary options
        var month = ['January','February','March','April','May','June','July','August','September','October','November','December'];
        var abrevMon = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
        var strgDay = ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'];
        var charchgble = [[": [u&#34;&#39;","'"],[': [u&#39;&#34;','"'],[": [u&#34;'",'"'],[': [u&#39;"',"'"],
            [': [u&#34;','"'],[': [u&#39;',"'"],['}, u&#39;',"'"],['}, u&#34;','"'],
            [': u&#39;',"'"],[': u&#34;','"'],[', u&#39;',"'"],[', u&#34;','"'],
            [', &#39;',"'"],[', &#34;','"'],
            ['{u&#39;',"'"],['{u&#34;','"'],
            ['[&#39;',"'"],['[&#34;','"'],['u&#39;',"'"],['u&#34;','"'],['&#39;',"'"],["&#34;",'"'],
            [", u'","'"],[', u"','"'],["}'","'"],['}"','"'],["{'","'"],['{"','"'],
            [", '","'"],[', "','"'],["['","'"],['["','"'],
            [": '","'"],[': "','"']]; //
        var spOpt = [": [u&#34;",': [u&#39;',': u&#39;',': u&#34;','{u&#39;','{u&#34;','[&#39;','[&#34;'];
        var EngNum = ['0','1','2','3','4','5','6','7','8','9'];
        var EngComNum = [',0',',1',',2',',3',',4',',5',',6',',7',',8',',9'];
        var EngLoc = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'];
        var EngUpc = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'];
        window.onpageshow = init;
        function init() {
            // console.log('Active...');
            if (window.Event) {
            // document.captureEvents(Event.MOUSEMOVE);
                document.addEventListener("mousemove",getCursorXY);
            };
            document.onmousemove = getCursorXY;
        };
        function getCursorXY(e) {
            // document.getElementById('cursorX').value = (window.Event) ? e.pageX : event.clientX + (document.documentElement.scrollLeft ? document.documentElement.scrollLeft : document.body.scrollLeft);
            // document.getElementById('cursorY').value = (window.Event) ? e.pageY : event.clientY + (document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop);
            document.getElementById('thisbs4X').value = (window.Event) ? e.pageX : event.clientX + (document.documentElement.scrollLeft ? document.documentElement.scrollLeft : document.body.scrollLeft);
            document.getElementById('thisbs4Y').value = (window.Event) ? e.pageY : event.clientY + (document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop);
        };
		function starTime() {
			var curnt = new Date();
			var currenTime = curnt.getTime();
			var uYr = curnt.getUTCFullYear();
			var uMo = curnt.getUTCMonth();
			var uDa = curnt.getUTCDate();
            var cYr = curnt.getFullYear();
            var cMo = curnt.getMonth();
            var cDa = curnt.getDate();
			var cH = curnt.getHours();
			var cM = curnt.getMinutes();
			var cS = curnt.getSeconds();
			var uH = curnt.getUTCHours();
			var uM = curnt.getUTCMinutes();
			var uS = curnt.getUTCSeconds();
			var cH = chk10(cH); uH = chk10(uH);
			var cM = chk10(cM); uM = chk10(uM);
			var cS = chk10(cS); uS = chk10(uS);
			//document.getElementById('tClock').innerHTML = cH + ':' + cM + ':' + cS;
			document.getElementById('uDate').innerHTML = month[uMo] + ' ' + uDa + ', ' + uYr
			document.getElementById('uClock').innerHTML = uH + ':' + uM + ':' + uS;
			var t = setTimeout(starTime, 500);
		};



        function doConnectFunction() {
            // check WWW
            // Grab the GOOGLE CMD
            // console.log('Connect to Internet');
            // console.log('..inside 1');
            onlStatus = true;
            // console.log('xStatus: ' + onlStatus);
        }
        function doNotConnectFunction() {
            // check LOCAL
            // Grab the LOCAL JQ
            // console.log('<Not Connect to Internet>');
            // console.log('..inside 2');
            onlStatus = false;
            // console.log('oStatus: ' + onlStatus);
        }



        function onlineStatus() {
            // Hard to test on local because connecting to internet for response.
            // onlStatus = false;

            // console.log('..inside 0');
            var i = new Image();
            i.onload = doConnectFunction;
            i.onerror = doNotConnectFunction;
            // CHANGE IMAGE URL TO ANY IMAGE YOU KNOW IS LIVE
            // i.src = 'http://gfx2.hotmail.com/mail/uxp/w4/m4/pr014/h/s7.png?d=' + escape(Date());
            i.src = 'http://www.cryptellegram.com/cryption/static/img/Trademark-Crypheka.png?d=' + escape(createRandomNumber(1,100000));
            // console.log('[Status]: ' + onlStatus);
            // console.log('Source: ' + i.src);
            // console.log('Status: ' + i.naturalWidth);
            // console.log('Complete: ' + i.complete);

            // escape(Date()) is necessary to override possibility of image coming from cache
            // console.log('..inside 4');
            i = null;
            return onlStatus;
        };
		function chk10(i) {
			if (i < 10) {
				i = "0" + i; // add zero in front of single digit numbers.
			};
			return i;
		};
        function check4location(thefile) {
            var myObject, result;
            myObject = new XMLHttpRequest();
            myObject.open('HEAD', thefile, false);
            myObject.send();
            if(myObject.status == "404") {
                // alert("File doesn't exists");
                result = false;
            } else {
                // alert('File Exists');
                result = true;
            };
            return result;
        };
        function chageIcon(domImg,srcImage) {
            var img = new Image();
            img.onload = function()
            {
                // Load completed
                domImg.src = this.src;
            };
            img.src = srcImage;
        };
        function htmlSpc(val1,val2,val3) {
            // val1 -> string (word)   val2, val3 -> int (number of space)
            x = "&nbsp;";
            xf = "";
            xb = "";
            for (var i=0; i < val2; i++) {
                xf += x;
            };
            for (var i=0; i < val3; i++) {
                xb += x;
            };
            results = xf + val1 + xb;
            return results
        };
        function browser() {
            // Return cached result if avalible, else get result then cache it.
            if (browser.prototype._cachedResult)
                return browser.prototype._cachedResult;

            var isOpera = !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0;
            // Opera 8.0+ (UA detection to detect Blink/v8-powered Opera)
            var isFirefox = typeof InstallTrigger !== 'undefined';// Firefox 1.0+
            var isSafari = Object.prototype.toString.call(window.HTMLElement).indexOf('Constructor') > 0;
            // At least Safari 3+: "[object HTMLElementConstructor]"
            var isChrome = !!window.chrome && !isOpera;// Chrome 1+
            var isIE = /*@cc_on!@*/false || !!document.documentMode; // At least IE6

            return (browser.prototype._cachedResult =
                isOpera ? 'Opera' :
                isFirefox ? 'Firefox' :
                isSafari ? 'Safari' :
                isChrome ? 'Chrome' :
                isIE ? 'IE' :
                '');
        };
        function remvElement(tid) {
            var elmt = document.getElementById(tid);
            if (elmt) {
                elmt.parentNode.removeChild(elmt);
            };
        };
        function sayIt(query, language) {
	        /*
	         * Coded by Jason Mayes 2013 for Chrome (but may work on other browsers now).
	         * Please keep this disclaimer if you use this code.
	         * www.jasonmayes.com
	        */
          	var q = new SpeechSynthesisUtterance(query);
          	q.lang = language;
          	q.rate = 1.2;
          	speechSynthesis.speak(q);
        };
        function randomString(length, chars) {
            // 'aA', '#aA', '#A!'
            var mask = '';
            if (chars.indexOf('a') > -1) mask += 'abcdefghijklmnopqrstuvwxyz';
            if (chars.indexOf('A') > -1) mask += 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
            if (chars.indexOf('#') > -1) mask += '0123456789';
            if (chars.indexOf('!') > -1) mask += '~`!@#$%^&*()_+-={}[]:";\'<>?,./|\\';
            var result = '';
            for (var i = length; i > 0; --i) result += mask[Math.floor(Math.random() * mask.length)];
            return result;
        };
        function letterCount(string, letter, caseSensitive) {
            var count = 0;
            if ( !caseSensitive) {
                string = string.toUpperCase();
                letter = letter.toUpperCase();
            };
            for (var i=0, l=string.length; i<string.length; i += 1) {
                if (string[i] === letter) {
                    count += 1;
                };
            };
            return count;
        };
        function stringCount(string,val,caseSensitive) {
            // check the val appearence in a string
            var count = 0;
            if ( !caseSensitive) {
                string = string.toUpperCase();
                val = val.toUpperCase();
            };
            // console.log('\nValue: ' + val + '\nString: ' + string + '\t\t' + val.length);
            for (var i=0, l=string.length; i<string.length; i += 1) {
                adjstring = string.slice(i,string.length);
                // console.log('Check this: ' + adjstring.slice(0,val.length) + '\t--> ' + adjstring);
                if (val == adjstring.slice(0,val.length)) {
                    count += 1;
                };
            };
            // console.log('\tCount: ' + count);
            return count;
        };
        function charCount(string, char, caseSensitive) {
            var chkarea, count;
            count = 0;
            if ( !caseSensitive) {
                string = string.toUpperCase();
                char = char.toUpperCase();
            };
            for (var i=0, l=string.length; i<string.length; i += 1) {
                chkarea = string.substr(i,char.length);
                // alert('Search Value: --> ' + char + '\nSearch Area: --> ' + chkarea);
                // console.log('\tSearch Value: --> ' + char + '\tSearch Area: --> ' + chkarea + '\tCount: ' + count);
                if (chkarea === char) {
                    count += 1;
                };
            };
            return count;
        };
        function createRandomNumber(min, max){
            var x, y, z;
            x = max - min;
            y = Math.floor(Math.random() * x);
            z = y + min;
            return z;
        };
        function oddOrEven(x) {
            //
            return ( x & 1 ) ? "odd" : "even";
        };
        function isNumeric(value) {
            // online
            return /^\d+$/.test(value);
        };
        function myRound(value, decimals) {
            //
            return Number(Math.round(value + 'e' + decimals) + 'e-' + decimals);
        };
        function con2$(obj) {
            // convert to currenty format
            var dollar, cents;
            // console.log('\n\nConvert ' + obj + ' to $$$');
            reject = false;
            currentsee = 'Error';
            obj = obj.toString();
            let0 = letterCount(obj,"-",false);
            let1 = letterCount(obj,".",false);
            let2 = letterCount(obj,",",false);
            pmark = obj.indexOf('.'); // locate period
            if (pmark == -1) {
                pmark = obj.length;
            };
            // check to see if its an acceptable format
            tmpobj = obj;
            tmpobj = myRepl('$','',tmpobj);
            tmpobj = myRepl(' ','',tmpobj);
            tmpobj = myRepl('-','',tmpobj);
            tmpobj = myRepl(',','',tmpobj);
            tmpobj = myRepl('.','',tmpobj);
            // console.log(tmpobj);
            chkobj = isNumeric(tmpobj);
            if (let0 > 1 || let1 > 1 || chkobj == false) {
                reject = true;
            };
            // console.log('Reject Entry: ' + reject);

            // remove all none numbered character and seperate the dollar from the cents.
            if (reject == false) {
                // console.log('Decimal Location: ' + pmark);
                ltside = obj.slice(0, pmark);
                rtside = obj.slice(pmark,obj.length);
                // console.log('Dollar Side: ' + ltside + '\t\tCent Side: ' + rtside);

                // Dollar Side
                if (ltside.length > 0) {
                    // console.log('Raw version of dollar: ' + ltside);
                    tmpobj = ltside;
                    tmpobj = myRepl('$','',tmpobj);
                    tmpobj = myRepl(' ','',tmpobj);
                    tmpobj = myRepl('-','',tmpobj);
                    tmpobj = myRepl(',','',tmpobj);
                    tmpobj = myRepl('.','',tmpobj);
                    ltside = tmpobj;
                    // console.log('Modified version of dollar: ' + ltside);
                    var tmp1 = ltside.split('');
                    var tmp2 = tmp1.reverse();
                    var tmp3 = tmp2.join('');
                    var tmp4 = '';
                    var ct = -1;
                    for (i in tmp3) {
                        ct++;
                        // console.log(i + '\t--> ' + tmp3[ct]);
                        r = ct % 3;
                        // console.log('remainder: ' + r);
                        if (r == 0) {
                            tmp4 += ',';
                        };
                        tmp4 += tmp3[ct];
                    };
                    if (tmp4.charAt(0) == ",") {
                        tmp5 = tmp4.slice(1,tmp4.length);
                    } else {
                        tmp5 = tmp4;
                    };
                    var tmp6 = tmp5.split('');
                    var tmp7 = tmp6.reverse();
                    dollar = tmp7.join('');
                } else {
                    //
                    dollar = '0';
                };

                // Cents Side
                if (rtside.length > 3) {
                    reject = true;
                } else if (rtside.length > 0) {
                    // console.log('Raw version of cent: ' + rtside);
                    tmpobj = rtside;
                    tmpobj = myRepl('$','',tmpobj);
                    tmpobj = myRepl(' ','',tmpobj);
                    tmpobj = myRepl('-','',tmpobj);
                    tmpobj = myRepl(',','',tmpobj);
                    tmpobj = myRepl('.','',tmpobj);
                    rtside = tmpobj;
                    // console.log('Modified version of cent: ' + rtside);
                    if (rtside.length == 1) {
                        rtside = rtside + '0';
                    };
                    cents = rtside;
                } else {
                    //
                    cents = '00';
                };

                // Modifications
                if (reject == false) {
                    currentsee = '$ ';
                    if (let0 > 0) {
                        currentsee += '-';
                    };
                    currentsee += dollar + '.' + cents;
                };


            };
            // console.log('\nConversion: ' + currentsee + '\n\n');
            return currentsee;
        };
        function Date2Num(obj) {
            // javaScript Version
            // convert any date format to numerical form
            // console.log('\n\nConvert Date To Numerical');
            var reject = false;
            var obj0 = obj.toString();
            var let0 = letterCount(obj0,"-",false);
            var let1 = letterCount(obj0,".",false);
            var let2 = letterCount(obj0,",",false);
            var let3 = letterCount(obj0,"/",false);
            var let4 = letterCount(obj0," ",false);

            var form = null;
            var numfmat = "None"
            var profmat = "None";
            var theyear, themonth, theday, chkmonth;
            var wrk0, wrk1;

            // any other format you wish to use setup idea here
            if ((let0 == 2 || let1 == 2 || let3 == 2) && (let2 == 0 & let4 == 0)) {
                // format appears mo/dd/yyyy or mo-dd-yyyy, etc.
                form = 'mdy'
            } else if (let2 == 1 && let4 == 2 && let0 == 0 && let3 == 0) {
                // format appears Mon day, year
                form = 'pmdy'
            } else if ((let4 == 1 || let3 == 1) && (let0 == 0 && let1 == 0 && let2 == 0)) {
                // format appears Year Mon or Year/mo or vice versa (only vv)
                form = 'ym';
            } else {
                reject = true;
            };

            if (reject == true) {
                console.log('Reject Entry: ' + obj);
            } else {
                // console.log(typeof obj + '\tEntry: ' + obj + '\t...format detected: ' + form)
                if (['ym'].indexOf(form) != -1) {
                    if (obj0.indexOf('/') != -1) {
                        wrk0 = obj0.split('/');
                    } else if (obj0.indexOf(' ') != -1) {
                        wrk0 = obj0.split(' ');
                    };

                    theday = '32'; // no day will be place at the end.
                    for ( i in wrk0 ) {
                        wrk1 = wrk0[i].toLowerCase();
                        wrk2 = wrk1.replace(/^[a-z]/, function (x) {return x.toUpperCase()}) // String
                        if (isNumeric(wrk0[i]) == true && wrk0[i].length == 4) {
                            // year
                            theyear = wrk0[i];
                        } else if (abrevMon.indexOf(wrk2) != -1) {
                            // month
                            themonth = wrk2;
                            chkmonth = month[(abrevMon.indexOf(wrk2))]; // full name
                        };
                    };
                } else if (['pmdy'].indexOf(form) != -1) {
                    // proper format
                    wrk0 = obj0.split(' ');
                    // console.log('the Split: ' + wrk0);
                    for ( i in wrk0 ) {
                        wrk1 = wrk0[i].toLowerCase();
                        wrk2 = wrk1.replace(/^[a-z]/, function (x) {return x.toUpperCase()}) // String
                        // console.log('\t\to\t' + wrk0[i]);
                        if (isNumeric(wrk0[i]) == true && wrk0[i].length == 4) {
                            // year
                            theyear = wrk0[i];
                        } else if (abrevMon.indexOf(wrk2) != -1) {
                            // month
                            themonth = wrk2; // abrev
                            // themonth = month[(abrevMon.indexOf(wrk0[i]))]; // full name
                            chkmonth = month[(abrevMon.indexOf(wrk2))]; // full name
                        } else if (month.indexOf(wrk2) != -1) {
                            // month
                            themonth = wrk2;
                            chkmonth = themonth;
                        } else if (wrk0[i].indexOf(',') != -1) {
                            // day
                            theday = wrk0[i].substring(0,wrk0[i].length - 1);
                        };
                    };
                } else if (['mdy'].indexOf(form) != -1) {
                    // month, day, year format... all number no char
                    if (obj0.indexOf('/') != -1) {
                        wrk0 = obj0.split('/');
                    } else if (obj0.indexOf('-') != -1) {
                        wrk0 = obj0.split('-');
                    };
                    for ( i in wrk0 ) {
                        // console.log('\t\to\t' + wrk0[i]);
                        if (isNumeric(wrk0[i]) == true && wrk0[i].length == 4) {
                            // year
                            theyear = wrk0[i];
                        } else if (isNumeric(wrk0[i]) == true && [1,2].indexOf(wrk0[i].length) != -1) {
                            // 0 - month, 1 - day, 2 - year if yr only 2 digit
                            if (i == 0) {
                                themonth = month[Number(wrk0[i]) - 1];
                                chkmonth = themonth;
                            } else if (i == 1) {
                                theday = wrk0[i];
                            } else if (i == 2) {
                                // change to the century of your choice
                                theyear = '20' + wrk0[i];
                            };
                        };
                    };
                };
                // console.log('Work Zero: ' + wrk0);
                // console.log('Year: ' + theyear + '\tMonth: ' + themonth + '\tDay: ' + theday + '\tCheck Month: ' + chkmonth);
                if ([theyear,themonth,theday].indexOf(undefined) != -1) {
                    // Reject...
                    console.log('Reject 2, Something wrong somewhere');
                    reject = true;
                };
                if (reject == false) {
                    // Proceed
                    if (theday == '32') {
                        profmat = theyear + ' ' + themonth;
                    } else {
                        profmat = themonth + ' ' + theday + ', ' + theyear;
                    };
                    nmonth = month.indexOf(chkmonth) + 1
                    if (nmonth < 10) {
                        if (Number(theday) < 10) {
                            numfmat = theyear + '0' + nmonth + '0' + theday;
                        } else {
                            numfmat = theyear + '0' + nmonth + theday;
                        };
                    } else {
                        if (Number(theday) < 10) {
                            numfmat = theyear + nmonth + '0' + theday;
                        } else {
                            numfmat = theyear + nmonth + theday;
                        };
                    };
                };
            };
            result = [numfmat, profmat]
            // console.log(result + '\n\n');
            return result;
        };
        function orDates(val1, val2) {
            // javaScript Version
            // val1 = array of dates, val = sequence order
            // console.log('\n\nData: ' + val1);
            // console.log('Order: ' + val2);
            var wrkarry1 = [];
            var result = [];
            for (i in val1) {
                wrk0 = Date2Num(val1[i]);
                // console.log('\t--> ' + wrk0);
                // if duplicate is present, setup code to add addtional point of number to data
                wrkarry1.push(wrk0[0]);
            };
            // console.log('1 -->\t' + wrkarry1);
            if (val2 == 'high') {
                wrkarry1.sort();
            } else if (val2 == 'low') {
                wrkarry1.sort();
                wrkarry1.reverse();
            } else {
                // Initial
            };
            // console.log('2 -->\t' + wrkarry1);
            for (var i=0; i < wrkarry1.length; i++) {
                // console.log('Loop 1: ' +  wrkarry1[i]);
                for (var j=0; j < val1.length; j++) {
                    // console.log('\tLoop 2: ' + val1[j]);
                    wrk0 = Date2Num(val1[j]);
                    if (wrk0[0] == wrkarry1[i]) {
                        result.push(wrk0[1])
                        break;
                    };
                };
            };
            // console.log('\n\n');
            return result;
        };
        function myRepl(val1, val2, val3) {
            // replace the string with all occurance
            // val1 value to change, val2 change value to, val3 entire string
            // console.log('String: ' + val3 + '\n Look For this: ' + val1 + '\nChange to this: ' + val2);
            var work = val3
            var y1 = val1.length;
            var bpart, epart;
            if (work.indexOf(val1) != -1) {
                for (var i = work.length - 1; i >= 0; i--) {
                    curL = work[i];
                    curG = work.substring(i, i+y1);
                    // console.log('-->\t' + i + '\tLetter: ' + curL+ '\tGroup: ' + curG);
                    if (curG == val1) {
                        // console.log('\t\tFound One: ');
                        bpart = work.substring(0,i)
                        epart = work.substring(i + y1, work.length);
                        // console.log ('Begin: ' + bpart + '\t' + val2 + '\t' + epart);
                        work = bpart + val2 + epart;
                    };
                };
            };
            // console.log('Result: ' + work)
            return work;
        };
        function objData(obj) {
            // ***************this code to get the object data... *****************
            var output = '';
            for (var property in obj) {
                output += property + ':' + obj[property] + '; ';
            };
            return output;
        };
        var removeItemFromArray = function(array, item){
            /* assign a empty array */
            var tmp = [];
            /* loop over all array items */
            for (var index in array) {
                if (array[index] !== item){
                    /* push to temporary array if not like item */
                    tmp.push(array[index]);
                };
            };
            /* return the temporary array */
            return tmp;
        };
        function removeOptions(obj, whch1) {
            // alert('Delete which one: ' + whch1); // important that you have the index mark ???
            while (obj.options.length) {
                if (whch1 == 'ALL'){
                    obj.remove(0);
                } else {
                    obj.remove(whch1);
                    break;
                };
            };
        };
        function remvSelOpt(value1,selections) {
            // see removeOptions in base
            if (value1 == "ALL") {
                for (var i = selections.options.length - 1; i >= 0; i--) {
                    selections.remove(i);
                };
            } else {
                // remove those in list
                // alert('Remove these:\n' + value1);
                for (var i = selections.options.length - 1; i >= 0; i--) {
                    thechar = selections.options[i].text;
                    if (value1.indexOf(thechar) != -1) {
                        selections.remove(i);
                    };
                };
            };
        }; // online
        function data_betw_quote(obj) {
        	// use with pyList depreciated
            // get the data between the string
            var accum = "";
            var L5 = "";
            var l5 = "halt";
            //alert("...inside data between quote:\n" + obj);
            for (var h in obj) {
                L5 = obj.substring(h -5, h);
                if (L5 == "&#39;") {
                    if (l5 == "halt") {
                        l5 = "launch";
                    } else {
                        l5 = "halt";
                    };
                };
                if (l5 == "launch") {
                    accum += obj[h];
                };
            };
            return accum.substring(0, accum.length - 5);
        };
        function pyListInt(obj) {
            // convert raw to object(sim to py list) former py_data
            // the data is an object where is first parameter is the string version of a list.  Seperate the string for the list
            // alert('Create a List: ' + typeof(obj) + '\nLength: ' + obj.length + '\n' + obj.substring(0,500));
            loc = -1;
            var nlast = 1; // by making this one, excludes the bracket from a list
            var thedata = [];
            var markS = [];
            var markE = [];
            var accum = "";
            var L5 = "";
            var x8 = 0;
            // alert("...inside py-data Integer\n" + obj);
            for (var h in obj) {
                loc++;
                x8++;
                L5 = obj.substring(h - 5, h);
                if (obj[h] == "," || obj[h] == "]") {
                    markS[markS.length] = nlast;
                    markE[markE.length] = h;
                    accum = obj.substring(nlast,h);
                    nlast = loc + 1;
                    // alert('Accum:  ' + accum);
                };
                // if (x8 > 20){break;};
                // alert(L5 + '\n' + obj[h]);
            };
            for (j in markS) {
                // var tmp = data_betw_quote(obj.substring(markS[j],markE[j])); // function
                var tmp = obj.substring(markS[j],markE[j]);
                thedata[thedata.length] = tmp;
                // alert('>>>   ' + tmp);
            };
            return thedata;
        };
        function findIlist(obj,objlst) {
            // find an item inside of a object.
            // locate the index with a list.
            // alert('In Find List...');
            var x8 = 0;
            for (var h in objlst) {
                x8++;
                // if (x8 > 3) {break};
                if (obj == objlst[h].trim()) {
                    // use trim to remove the spaces in front & back.
                    var result = h;
                    // alert("...found " + objlst[h]);
                    break;
                };
            };
            return result;
        };
        function py_set(type,obj1,obj2) {
            // convert two array(list) to one list base on type(request)
            result = [];
            if (type == 'difference') {
                // determine the difference between the two list
                //alert(typeof obj1 + '  List1: ' + obj1);
                //alert(typeof obj2 + '  List2: ' + obj2);
                x8 = false;
                for (var chk1 in obj1) {
                    var fndit = findIlist(obj1[chk1], obj2); // function ->
                    if (typeof fndit !== 'undefined') {continue;};
                    result[result.length] = obj1[chk1];
                };
                if (obj1.length > 1 && result.length == 0) {
                    // Restart List... Clear Out Prev List
                    //alert('Restarting... PlayList');
                    prevList = [];
                    result = obj1;
                };
            }
            else if (type == 'same') {

            }
            else {
                alert('Option Not Available');
            };
            return result;
        };


        function nwList(obj) {
            //
            console.log('\n\n\n...Inside PyList2');
            console.log('+ ' + typeof obj);
            console.log('-> ' + obj.substring(0,5000));
            var orig, result;
            var k0; // the character during loop
            var keyct = 0; // the key count
            var actpt = ['Start'] // store the location of the keys
            var quoStatus = false; // quotation status
            var lookL,lookR,viewpos; // the array for character range storage
            var crng = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17]; // check these range
            var wrksect = "Start";
            var wrksqre = false;
            var arrCT = -1; // note: key count jump with very first open bracket
            var arrLV = 0; // not setup yet but for array within array

            // check value [make sure its a string]
            if (typeof(obj) != 'string') {
                alert('Not the correct format');
                console.log ('\n\nIn nwList: format is not correct\n\n');
                return 'ERROR';
            };
            orig = obj;
            result = []; // start off as an array
            // read legitmate [ for open and legitmate ] for close.  this will determine the dic keys

            var cks, cke, csp; // check these area... cks - start, cke - end, csp - current position

            // cks = 0, cke = orig.length, csp = orig.length; //   ****************** TEST LIST *********************
            cks = 0, cke = 0, csp = 0; // View Test Area
            for (k0=0; k0 < orig.length; k0++) {
                lookL = [];
                lookR = [];
                var rmdr = k0 % 18; // the remainder
                for (var i=0; i < crng.length; i++) {
                    if (i==0) {
                        lookL[0] = orig[k0]; // actual character
                        lookR[0] = orig[k0];
                    } else {
                        lookL[i] = orig.substring(k0 - i, k0);
                        lookR[i] = orig.substring(k0, k0 + i);
                    };
                };
                viewpos = orig.substring(k0 - 20, k0 + 20); // view current position -5 and +5
                vewAct(k0, 0, csp, 0, '\n\n\n\nCuRRRent Position: ' + k0 + '\t Character: ' + orig[k0] + '\t\t' + viewpos);
                if ([',','[',']'].indexOf(lookL[0]) != -1) {
                    // these are the factors of a list
                    vewAct(k0, cks, cke, '\tPosition: ' + k0 + '\tCommand Character Activated ==>  ' + orig[k0]);
                    if (lookL[0] == '[') {
                        sect = 'Open Square';
                        vewAct(k0, cks, cke, 6, '\nWork Section: ' + wrksect + '\n' + lookL[5] + '\t\tOpen Square View\t\t' + lookR[9]);
                        if (wrksect == 'Start') { // only time to start off with wrksect, all other lookL & lookR
                            if (lookL[3] == '' || lookL[4] == '') {
                                // First Bracket establishing the start of a list
                                arrCT++; // must be done only when one of the choices are selected
                                arrLV++;
                                actpt.push(k0);
                                vewAct(k0, cks, cke, '\tKey Location with-in Original:\t' + actpt);
                                wrksect = 'opSquare';
                                // sayIt('First Bracket establishing the start of a list');
                            } else {
                                tmpsay = 'OPEN SQUARE Response Not Setup';
                                vewAct(k0, cks, cke, 4, '\n\nKey Count: ' + arrCT + '\n(65483) This' + tmpsay + '.\n\t\t'+orig.substring(k0-10, k0+10)+'\nLast: ' + lookL[9] + '\nNext: ' + lookR[9]);
                                if (k0 > cks && k0 < cke && tmpsay != '') {
                                    sayIt(tmpsay + ' Line ' + k0);
                                };
                            };
                        } else if (['['].indexOf(lookL[1]) != -1 && ['[&#39;','[&#34;'].indexOf(lookR[6]) != -1) {
                            if (wrksect == 'opSquare') {
                                // add array within another array
                                vewAct(k0, cks, cke, 9, 'actpt' + '\n' + orig.substring(actpt[actpt.length -1], k0));
                                valvalue = orig.substring(actpt[actpt.length - 1], k0);
                                actpt.push(k0);
                                for (xp in charchgble) {
                                    if (valvalue.indexOf(charchgble[xp][0]) != -1) {
                                        valvalue = myRepl(charchgble[xp][0], charchgble[xp][1], valvalue);
                                    };
                                };
                                adjval = valvalue.substring(1, valvalue.length - 1);

                                vewAct(k0, cks, cke, 'Array Count: ' + arrCT + '\tVALUE Value: ' + valvalue + '\nActions Points: ' + 'actpt');
                                vewAct(k0, cks, cke, 8, '\n\no\t' + adjval + '\to\n\n');

                                tmpsay = "";
                                arrLV++;
                                result.push([]);

                                vewAct(k0, cks, cke, 14, '\n\noooNoLooo>\tLevel: ' + arrLV + '\n' + 'result' + '\n\n');
                                vewAct(k0, cks, cke, 11, result);
                                wrksect = 'opSquare';
                            } else {
                                tmpsay = 'OPEN SQUARE Response from ' + wrksect +' Not SetUp';
                                console.log ('\n\nKey Count: ' + arrCT + '\n(442690) This ' + tmpsay + '.\n\t\t'+orig.substring(k0-10, k0+10)+'\nLast: ' + lookL[9] + '\nNext: ' + lookR[9]);
                                if (k0 > cks && k0 < cke && tmpsay != '') {
                                    sayIt(tmpsay + ' Line ' + k0);
                                };
                            };
                        } else {
                            tmpsay = "Open Square Instructions Not Setup";
                            console.log('\n\t\t\t*********************************************');
                            console.log('\t\t\t*\t' + tmpsay + '\t*');
                            console.log('\t\t\t*********************************************\n');
                            if (k0 > cks && k0 < cke && tmpsay != '') {
                                sayIt(tmpsay + ' Line ' + k0);
                            };
                        };
                    }  else if (lookL[0] == ',') {
                        // Seperate value to value, value to key ...don't know which one for future
                        sect = 'Comma';
                        vewAct(k0, cks, cke, 6, '\nWork Section: ' + wrksect + '\n' + lookL[5] + '\t\tComma View\t\t' + lookR[8]);

                        if ((['&#39;','&#34;'].indexOf(lookL[5]) != -1 && [', &#39;',', &#34;'].indexOf(lookR[7]) != -1) || (["'",'"'].indexOf(lookL[1]) != -1 && [", '",', "'].indexOf(lookR[3]) != -1)) {
                            if (wrksect == 'opSquare') {
                                // obtain the value, store it and prepare for next
                                vewAct(k0, cks, cke, 9, 'actpt' + '\n' + orig.substring(actpt[actpt.length -1], k0));
                                valvalue = orig.substring(actpt[actpt.length - 1], k0);
                                actpt.push(k0);
                                for (xp in charchgble) {
                                    if (valvalue.indexOf(charchgble[xp][0]) != -1) {
                                        valvalue = myRepl(charchgble[xp][0], charchgble[xp][1], valvalue);
                                    };
                                };
                                adjval = valvalue.substring(1, valvalue.length - 1);

                                vewAct(k0, cks, cke, 'Array Level: ' + arrLV + '\tVALUE Value: ' + valvalue + '\nActions Points: ' + 'actpt');
                                vewAct(k0, cks, cke, 8, '\n\no\t' + adjval + '\to\n\n');

                                // tmpsay = 'Section ' +  arrLV + ' Not Setup';
                                tmpsay = "";
                                arrCT++;


                                if (arrLV == 1) {
                                    // tmpsay = 'Section ' +  arrLV + ' Not Setup';
                                    result.push(adjval);
                                } else if (arrLV == 2) {
                                    tmpsay = 'Section ' +  arrLV + ' Working On';
                                    console.log(result);
                                    result[0].push(adjval);
                                } else if (arrLV == 3) {
                                    tmpsay = 'Section ' +  arrLV + ' Not Setup';
                                } else if (arrLV == 4) {
                                    tmpsay = 'Section ' +  arrLV + ' Not Setup';
                                } else if (arrLV == 5) {
                                    tmpsay = 'Section ' +  arrLV + ' Not Setup';
                                } else if (arrLV == 6) {
                                    tmpsay = 'Section ' +  arrLV + ' Not Setup';
                                } // more option not setup
                                if (k0 > cks && k0 < cke && tmpsay != '') {
                                    sayIt(tmpsay + ' Line ' + k0);
                                    vewAct(k0, cks, cke, 13, '<<' + tmpsay + '>>');
                                };
                                vewAct(k0, cks, cke, 14, '\n\nooooooo>\tList: '  + '\n' + 'result' + '\n\n');
                                vewAct(k0, cks, cke, 11, result);
                                wrksect = 'coMma';
                            } else if (wrksect == 'coMma') {
                                // obtain the value, store it and prepare for next
                                vewAct(k0, cks, cke, 9, 'actpt' + '\n' + orig.substring(actpt[actpt.length -1], k0));
                                valvalue = orig.substring(actpt[actpt.length - 1], k0);
                                actpt.push(k0);
                                for (xp in charchgble) {
                                    if (valvalue.indexOf(charchgble[xp][0]) != -1) {
                                        valvalue = myRepl(charchgble[xp][0], charchgble[xp][1], valvalue);
                                    };
                                };
                                adjval = valvalue.substring(1, valvalue.length - 1);

                                vewAct(k0, cks, cke, 'Array Count: ' + arrCT + '\tVALUE Value: ' + valvalue + '\nActions Points: ' + 'actpt');
                                vewAct(k0, cks, cke, 8, '\n\no\t' + adjval + '\to\n\n');

                                tmpsay = "";
                                arrCT++;


                                if (arrLV == 1) {
                                    // tmpsay = 'Section ' +  arrLV + ' Not Setup';
                                    result.push(adjval);
                                } else if (arrLV == 2) {
                                    tmpsay = 'Section ' +  arrLV + ' Working On';
                                    result[0].push(adjval);
                                } else if (arrLV == 3) {
                                    tmpsay = 'Section ' +  arrLV + ' Not Setup';
                                } else if (arrLV == 4) {
                                    tmpsay = 'Section ' +  arrLV + ' Not Setup';
                                } else if (arrLV == 5) {
                                    tmpsay = 'Section ' +  arrLV + ' Not Setup';
                                } else if (arrLV == 6) {
                                    tmpsay = 'Section ' +  arrLV + ' Not Setup';
                                } // more option not setup
                                if (k0 > cks && k0 < cke && tmpsay != '') {
                                    sayIt(tmpsay + ' Line ' + k0);
                                    vewAct(k0, cks, cke, 13, '<<' + tmpsay + '>>');
                                };

                                vewAct(k0, cks, cke, 14, '\n\nooEooooo>\tList: '  + '\n' + 'result' + '\n\n');
                                vewAct(k0, cks, cke, 11, result);
                                wrksect = 'coMma';

                            } else {
                                tmpsay = 'COMMA Response from ' + wrksect +' Not SetUp';
                                console.log ('\n\nKey Count: ' + arrCT + '\n(442673) This ' + tmpsay + '.\n\t\t'+orig.substring(k0-10, k0+10)+'\nLast: ' + lookL[9] + '\nNext: ' + lookR[9]);
                                if (k0 > cks && k0 < cke && tmpsay != '') {
                                    sayIt(tmpsay + ' Line ' + k0);
                                    vewAct(k0, cks, cke, 13, '<<' + tmpsay + '>>');
                                };
                            };
                        } else {
                            tmpsay = "Comma Instructions o Not Setup";
                            console.log('\n\t\t\t*****************************************');
                            console.log('\t\t\t*\t' + tmpsay + '\t*');
                            console.log('\t\t\t*****************************************\n');
                            if (k0 > cks && k0 < cke && tmpsay != '') {
                                sayIt(tmpsay + ' Line ' + k0);
                            };
                        };
                    } else if (lookL[0] == ']') {
                        sect = 'Close Square';
                        vewAct(k0, cks, cke, 6, '\nWork Section: ' + wrksect + '\n' + lookL[5] + '\t\tClose Square View\t\t' + lookR[9]);
                        if (['&#39;','&#34;'].indexOf(lookL[5]) != -1 && [']'].indexOf(lookR[1]) != -1) {
                            if (wrksect == 'coMma') {
                                // obtain the value, store it and prepare for end
                                vewAct(k0, cks, cke, 9, 'actpt' + '\n' + orig.substring(actpt[actpt.length -1], k0));
                                valvalue = orig.substring(actpt[actpt.length - 1], k0);
                                actpt.push(k0);
                                for (xp in charchgble) {
                                    if (valvalue.indexOf(charchgble[xp][0]) != -1) {
                                        valvalue = myRepl(charchgble[xp][0], charchgble[xp][1], valvalue);
                                    };
                                };
                                adjval = valvalue.substring(1, valvalue.length - 1);

                                vewAct(k0, cks, cke, 'Array Count: ' + arrCT + '\tVALUE Value: ' + valvalue + '\nActions Points: ' + 'actpt');
                                vewAct(k0, cks, cke, 8, '\n\no\t' + adjval + '\to\n\n');

                                tmpsay = "";
                                arrCT++;


                                if (arrLV == 1) {
                                    // tmpsay = 'Section ' +  arrCT + ' Not Setup';
                                    result.push(adjval);
                                } else if (arrLV == 2) {
                                    tmpsay = 'Section ' +  arrCT + ' Not Setup';
                                } else if (arrLV == 3) {
                                    tmpsay = 'Section ' +  arrCT + ' Not Setup';
                                } else if (arrLV == 4) {
                                    tmpsay = 'Section ' +  arrCT + ' Not Setup';
                                } else if (arrLV == 5) {
                                    tmpsay = 'Section ' +  arrCT + ' Not Setup';
                                } else if (arrLV == 6) {
                                    tmpsay = 'Section ' +  arrCT + ' Not Setup';
                                } // more option not setup
                                if (k0 > cks && k0 < cke && tmpsay != '') {
                                    sayIt(tmpsay + ' Line ' + k0);
                                    vewAct(k0, cks, cke, 13, '<<' + tmpsay + '>>');
                                };
                                vewAct(k0, cks, cke, 14, '\n\nooooooo>\tList: '  + '\n' + 'result' + '\n\n');
                                vewAct(k0, cks, cke, 11, result);
                                wrksect = 'clSquare';
                            } else {
                                tmpsay = 'CLOSE SQUARE Response from ' + wrksect +' Not SetUp';
                                console.log ('\n\nKey Count: ' + arrCT + '\n(144613) This ' + tmpsay + '.\n\t\t'+orig.substring(k0-10, k0+10)+'\nLast: ' + lookL[9] + '\nNext: ' + lookR[9]);
                                if (k0 > cks && k0 < cke && tmpsay != '') {
                                    sayIt(tmpsay + ' Line ' + k0);
                                };
                            };
                        } else {
                            tmpsay = "Close Square Instructions Not Setup";
                            console.log('\n\t\t\t*****************************************');
                            console.log('\t\t\t*\t' + tmpsay + '\t*');
                            console.log('\t\t\t*****************************************\n');
                            if (k0 > cks && k0 < cke && tmpsay != '') {
                                sayIt(tmpsay + ' Line ' + k0);
                            };
                        };
                    } else {
                        // Not one of the main characters
                        tmpsay = "Command Character Not Setup";
                        console.log('\n\n\t\t\t*****************************************');
                        console.log('\t\t\t*\tCommand Character: ' + orig[k0] + ' Not SETUP\t*');
                        console.log('\t\t\t*****************************************\n');
                        if (k0 > cks && k0 < cke && tmpsay != '') {
                            sayIt(tmpsay + ' Line ' + k0);
                        };
                    };
                };
            };
            // console.log(result);
            return result;
        };


        function pyList(obj) {
            // convert raw to object(sim to py list) former py_data
        	// alert('Create a List: ' + typeof(obj) + '\nLength: ' + obj.length + '\n' + obj.substring(0,50000));
            // console.log('\n\n\n\n\n\n\n' + typeof(obj) + '\tThe List DATA:\n' + obj);
            // list are seperated by commas, single out the correction location.
            // console.log ('Create a List: ' + typeof(obj) + '\nLength: ' + obj.length + '\n' + obj.substring(0,50000));
            var orig, result;
            var k0; // the character during loop
            var keyct = 0; // the key count
            var actpt = ['Start'] // store the location of the keys
            var lookL,lookR,viewpos; // the array for character range storage
            var sqrStatus; // square bracket status
            var quoStatus; // quotation status
            var dicStatus; // dic number of keys
            var arr0, arr1, arr2, arr3, arr4, arr5; // array keys/range
            var crng = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17]; // check these range
            x8 = 0;
            // check value [make sure its a string]
            if (typeof(obj) != 'string') {
                alert('Not the correct format');
                return 'ERROR';
            };
            orig = obj;
            result = []; // start off as an array
            arr0 = [], arr1 = [], arr2 = [], arr3 = [], arr4 = [], arr5 = [];
            sqrStatus = false, quoStatus = false, dicStatus = null;

            // examine the data, make sure first and last characters are correct
            if (orig.length < 1 ) {
                return 'BLANK';
            } else if (orig[0] != '[' || orig.substr(orig.length - 1, orig.length) != ']') {
                console.log(orig.length + '  Error With List Data:\n' + orig);
                alert(orig[0] + '  Error-with-Data  ' + orig.substr(orig.length - 1, orig.length));
                return 'ERROR';
            };

            // Start Process: Store Ranges
            var x,y,z; // temp characters
            var myarrct = Number(-1);
            for (k0=0; k0 < orig.length; k0++) {
                // console.log('\n' + k0 + '  ' + orig[k0] + '  ' + k0 % 18);
                // x8++;
                // if (x8 > 9000){
                //  alert(x8 + '\ncheck point1 ' + lookL[8]);
                // };
                // if (x8 > 79225) {break;};
                lookL = [];
                lookR = [];
                var rmdr = k0 % 18; // the remainder
                // console.log("start <from> here " + k0);
                for (var i=0; i < crng.length; i++) {
                    if (i==0) {
                        lookL[0] = orig[k0]; // actual character
                        lookR[0] = orig[k0];
                    } else {
                        lookL[crng[i]] = orig.substring(k0 - crng[i], k0);
                        lookR[crng[i]] = orig.substring(k0, k0 + crng[i]);
                    };
                };
                viewpos = orig.substring(k0 - 20, k0 + 20); // view current position -5 and +5

                // console.log('\n\nStored Range: ' + k0 + '  ' + orig[k0] + '  ' + k0 % 18 + '\n' +
                //     'Actual: '+lookL[0]+'\t\t'+viewpos+'\n2\t'+lookL[2]+'\t\t\t'+lookR[17]+'\n3\t'+lookL[3]+'\t\t\t'+lookR[16]+
                //     '\n4\t'+lookL[4]+'\t\t\t'+lookR[15]+'\n5\t'+lookL[5]+'\t\t\t'+lookR[14]+'\n6\t'+lookL[6]+
                //     '\t\t\t'+lookR[13]+'\n7\t'+lookL[7]+'\t\t\t'+lookR[12]+'\n8\t'+lookL[8]+'\t\t'+lookR[11]+
                //     '\n9\t'+lookL[9]+'\t\t'+lookR[10]+'\n10\t'+lookL[10]+'\t\t'+lookR[9]+'\n11\t'+lookL[11]+
                //     '\t\t'+lookR[8]+'\n12\t'+lookL[12]+'\t\t'+lookR[7]+'\n13\t'+lookL[13]+'\t\t'+lookR[6]+
                //     '\n14\t'+lookL[14]+'\t\t'+lookR[5]+'\n15\t'+lookL[15]+'\t\t'+lookR[4]+'\n16\t'+lookL[16]+
                //     '\t'+lookR[3]+'\n17\t'+lookL[17]+'\t'+lookR[2]
                // ); // actual at zero, 1 blank, rest proper

                // Start Checking:
                if ([',','[',']'].indexOf(lookL[0]) != -1) {
                    // these are the factors of a dictionary
                    // console.log ('\n\n\t' + viewpos);
                    // console.log ('Last:\t' + lookL[10] + '\nNext:\t' + lookR[10]);
                    // you can adjust the strings here... (skey)
                    if (lookL[0] == '[') {
                        // open SQUARE bracket
                        // console.log ('\n\n' + k0 + '\tOPEN Square Bracket:\t\t' + orig.substring(k0 - 10, k0 + 10));
                        var wrksect1 = 'Open Square Bracket';
                        myarrct++;
                        if (lookL[3] == '' && lookR[6] == '[&#34;') {
                            actpt.push(k0);
                            // console.log ('\t\t\t(Start Of List) ...' + orig.substring(k0 - 10, k0 + 10));
                        } else if (lookL[3] == '' && lookR[7] == '[u&#34;') {
                            actpt.push(k0);
                        } else if (lookL[3] == '' && lookR[6] == '[&#39;') {
                            actpt.push(k0);
                            // console.log ('\t\t\t(Start Of List) ...' + orig.substring(k0 - 10, k0 + 10));
                        } else if (lookL[3] == '' && lookR[7] == '[u&#39;') {
                            actpt.push(k0);
                        } else {
                            // console.log(k0 + ' Checking on Open Square Bracket\t\t' + orig.substring(k0 - 20, k0 + 20))
                            // alert(k0 + '  OPEN Square Bracket Not SetUp')
                            // console.log ('\nThis OPEN SQUARE BRACKET Response Not SetUp.\n\t\t'+orig.substring(k0-10, k0+10)+'\nLast: ' + lookL[9] + '\nNext: ' + lookR[9]);
                        }
                    } else if (lookL[0] == ',') {
                        // console.log ('\n\n' + k0 + '\tCOMMA:\t\t' + orig.substring(k0 - 10, k0 + 10));
                        var wrksect1 = 'Open Square Bracket';
                        if (lookL[5] == '&#34;' && lookR[8] == ', u&#34;') {
                            tmpk = actpt.pop(); // close out old key
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            actpt.push(k0); // start new value
                            if (x != -1 && y != -1) {
                                skey = pkey.substring(x+1,y);
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                arr0[arr0.length] = skey; // add
                            } else {
                                alert('Situation Not Setup 5109');
                            };
                            // console.log ('->\t['+arr0+']\n\n');
                        } else if (lookL[5] == '&#39;' && lookR[8] == ', u&#39;') {
                            tmpk = actpt.pop(); // close out old key
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            actpt.push(k0); // start new value
                            if (x != -1 && y != -1) {
                                skey = pkey.substring(x+1,y);
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                arr0[arr0.length] = skey; // add
                            } else {
                                alert('Situation Not Setup 5109');
                            };
                            // console.log ('->\t['+arr0+']\n\n');
                        } else if (lookL[5] == '&#34;' && lookR[8] == ', u&#39;') {
                            tmpk = actpt.pop(); // close out old key
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            actpt.push(k0); // start new value
                            if (x != -1 && y != -1) {
                                skey = pkey.substring(x+1,y);
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                arr0[arr0.length] = skey; // add
                            } else {
                                alert('Situation Not Setup 5109');
                            };
                            // console.log ('->\t['+arr0+']\t' + typeof skey +'\n\n');
                        } else if (lookL[5] == '&#39;' && lookR[8] == ', u&#34;') {
                            tmpk = actpt.pop(); // close out old key
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            actpt.push(k0); // start new value
                            if (x != -1 && y != -1) {
                                skey = pkey.substring(x+1,y);
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                arr0[arr0.length] = skey; // add
                            } else {
                                alert('Situation Not Setup 5109');
                            };
                            // console.log ('->\t['+arr0+']\n\n');
                        } else if (lookL[5] == '&#34;' && lookR[8] == ', u&#34;') {
                            tmpk = actpt.pop(); // close out old key
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            actpt.push(k0); // start new value
                            if (x != -1 && y != -1) {
                                skey = pkey.substring(x+1,y);
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                arr0[arr0.length] = skey; // add
                            } else {
                                alert('Situation Not Setup 5109');
                            };
                            // console.log ('->\t['+arr0+']\n\n');
                        } else if (lookL[5] == '&#34;' && lookR[8] == ', &#34;') {
                            tmpk = actpt.pop(); // close out old key
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            actpt.push(k0); // start new value
                            if (x != -1 && y != -1) {
                                skey = pkey.substring(x+1,y);
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                arr0[arr0.length] = skey; // add
                            } else {
                                alert('Situation Not Setup 5109');
                            };
                            // console.log ('->\t['+arr0+']\n\n');
                        } else if (lookL[5] == '&#39;' && lookR[8] == ', &#39;') {
                            tmpk = actpt.pop(); // close out old key
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            actpt.push(k0); // start new value
                            if (x != -1 && y != -1) {
                                skey = pkey.substring(x+1,y);
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                arr0[arr0.length] = skey; // add
                            } else {
                                alert('Situation Not Setup 5109');
                            };
                            // console.log ('->\t['+arr0+']\t' + typeof skey +'\n\n');
                        } else if (lookL[5] == '&#34;' && lookR[8] == ', &#39;') {
                            tmpk = actpt.pop(); // close out old key
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            actpt.push(k0); // start new value
                            if (x != -1 && y != -1) {
                                skey = pkey.substring(x+1,y);
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                arr0[arr0.length] = skey; // add
                            } else {
                                alert('Situation Not Setup 5109');
                            };
                            // console.log ('->\t['+arr0+']\t' + typeof skey +'\n\n');
                        } else if (lookL[5] == '&#39;' && lookR[8] == ', &#34;') {
                            tmpk = actpt.pop(); // close out old key
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            actpt.push(k0); // start new value
                            if (x != -1 && y != -1) {
                                skey = pkey.substring(x+1,y);
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                arr0[arr0.length] = skey; // add
                            } else {
                                alert('Situation Not Setup 5109');
                            };
                            // console.log ('->\t['+arr0+']\n\n');
                        } else {
                            // console.log(k0 + ' Checking on Comma\t\t' + orig.substring(k0 - 20, k0 + 20))
                            // alert(k0 + '  Comma Not SetUp');
                            // console.log ('\nThis CommaT Response Not SetUp.\n\t\t'+orig.substring(k0-10, k0+10)+'\nLast: ' + lookL[9] + '\nNext: ' + lookR[9]);
                        }
                    } else if (lookL[0] == ']') {
                        // close SQUARE bracket
                        // console.log ('\n\n' + k0 + '\tCLOSE Square Bracket:\t\t' + orig.substring(k0 - 10, k0 + 10));
                        var wrksect1 = 'Close Square Bracket';
                        myarrct--;
                        if (lookL[5] == '&#34;' && typeof lookR[1] === 'undefined') {
                            // console.log ('\t\t\t(End Of List) ....' + orig.substring(k0 - 10, k0 + 10));
                            tmpk = actpt.pop(); // close out old key
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            if (x != -1 && y != -1) {
                                skey = pkey.substring(x+1,y);
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                arr0[arr0.length] = skey; // add
                            } else {
                                alert('Situation Not Setup 5129');
                            };
                            // console.log ('->\t['+arr0+']\t' + typeof arr0 + '\n\n');
                        } else if (lookL[5] == '&#39;' && typeof lookR[1] === 'undefined') {
                            // console.log ('\t\t\t(End Of List) ...' + orig.substring(k0 - 10, k0 + 10));
                            tmpk = actpt.pop(); // close out old key
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            if (x != -1 && y != -1) {
                                skey = pkey.substring(x+1,y);
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                arr0[arr0.length] = skey; // add
                            } else {
                                alert('Situation Not Setup 5109');
                            };
                            // console.log ('->\t['+arr0+']\t' + typeof arr0 + '\n\n');
                        } else {
                            // console.log(k0 + ' Checking on Close Square Bracket\t\t' + orig.substring(k0 - 20, k0 + 20))
                            // alert(k0 + '  OPEN Square Bracket Not SetUp')
                            // console.log ('\nThis OPEN SQUARE BRACKET Response Not SetUp.\n\t\t'+orig.substring(k0-10, k0+10)+'\nLast: ' + lookL[9] + '\nNext: ' + lookR[9] + '\t' + lookR[1]);
                        }
                    } else {
                        // Not one of the main characters
                        console.log ('Should not be here, there was only three choices');
                    };
                };
            };
            result = arr0;
            // console.log ('\nPy-List Result: ' + result);
            return result;
        };
        function vewArr(argument) {
            // view an array
            result = argument;
            console.log ('... inside view array');
            result.forEach(function(value, index) {
                console.log(value, index);
            });
            // loop the outer array
            for (var i=0; i < result.length; i++) {
                // get the size of the inner array
                var innerArrayLength = result[i].length;
                // loop the inner array
                for (var j=0; j < innerArrayLength; j++) {
                    console.log ('[' + i + ',' + j + ']' + result[i][j]);
                };
            };
        };
        function cmpRespnse(val1,val2) {
            // val1 length, val2 type (all,num,ALP,alp,n&a,N&A)
            var r;
            var bsdata = "";
            for (var i=0; i < val1; i++) {
                // 65-90 AZ, 48-57 09, 97-122 az
                r0 = createRandomNumber(65,90); // AZ
                r1 = createRandomNumber(97,122); // az
                r2 = createRandomNumber(48,57); // 09
                r3 = createRandomNumber(48,122); // 0z
                if (val2 == 'all') {
                    choice = [r0,r1,r2,r3];
                    cho = createRandomNumber(0,3);
                    sel = choice[cho];
                    char = String.fromCharCode(sel);
                    // console.log('Choices: ' + choice + '\t\t' + cho + '\tIt Chose:\t' + sel)
                } else if (val2 == 'N&A') {
                    choice = [r0,r2];
                    cho = createRandomNumber(0,2);
                    sel = choice[cho];
                    char = String.fromCharCode(sel);
                } else if (val2 == 'num') {
                    sel = r2;
                    char = String.fromCharCode(sel);
                } else if (val2 == 'ALP') {
                    sel = r0;
                    char = String.fromCharCode(sel);
                } else {
                    sel = createRandomNumber(32,124);
                    char = String.fromCharCode(sel);
                };

                bsdata += char;
                // console.log(sel + '  <-->  ' + char);
            };
            return bsdata;
        };
        function pyDic2(obj) { // depreciated
            // console.log (typeof(obj));
            // console.log (obj.substring(0,5000));
            var orig, result;
            var k0; // the character during loop
            var keyct = 0; // the key count
            var actpt = ['Start'] // store the location of the keys
            var lookL,lookR,viewpos; // the array for character range storage
            var sqrStatus; // square bracket status
            var quoStatus; // quotation status
            var dicStatus; // dic number of keys
            var arr0, arr1, arr2, arr3, arr4, arr5; // array keys/range
            var crng = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17]; // check these range
            x8 = 0;
            // check value [make sure its a string]
            if (typeof(obj) != 'string') {
                alert('Not the correct format');
                console.log ('\n\nIn pyDic2: format is not correct\n\n');
                return 'ERROR';
            };
            orig = obj;
            result = []; // start off as an array
            arrg = [];
            arr0 = [], arr1 = [], arr2 = [], arr3 = [], arr4 = [], arr5 = [];
            sqrStatus = false, quoStatus = false, dicStatus = null;

            // examine the data, make sure first and last characters are correct
            // console.log(orig.substr(length - 2, orig.length) + '\t--> ' + orig[-2]);
            if (orig[0] == '{' && orig.substr(orig.length - 2, orig.length) == '}}') {
                // console.log('\n....in pyDic2\n\tAppears to be a double dic');
                dicStatus = 'double';
            } else if (orig[0] == '{' && orig.substr(orig.length - 2, orig.length) == ';}') {
                // console.log('\n...in pyDic2\n\tAppears to be a single dic');
                dicStatus = 'single';
            } else if (orig[0] != '{' || orig.substr(orig.length - 2, orig.length) != '}}') {
                console.log('\n....in pyDic2\nError With Dic Data:\n' + orig);
                alert(orig[0] + '  Error+with+Data  ' + orig.substr(orig.length - 2, orig.length));
                return 'ERROR';
            };
            // Start Process: Store Ranges
            var x,y,z; // temp characters
            var myarrct = Number(-1);
            for (k0=0; k0 < orig.length; k0++) {
                // console.log('\n' + k0 + '  ' + orig[k0] + '  ' + k0 % 18);
                // x8++;
                // if (x8 > 9000){
                //  alert(x8 + '\ncheck point1 ' + lookL[8]);
                // };
                // if (x8 > 79225) {break;};
                lookL = [];
                lookR = [];
                var rmdr = k0 % 18; // the remainder
                // console.log("start <from> here " + k0);
                for (var i=0; i < crng.length; i++) {
                    if (i==0) {
                        lookL[0] = orig[k0]; // actual character
                        lookR[0] = orig[k0];
                    } else {
                        lookL[crng[i]] = orig.substring(k0 - crng[i], k0);
                        lookR[crng[i]] = orig.substring(k0, k0 + crng[i]);
                    };
                };
                viewpos = orig.substring(k0 - 20, k0 + 20); // view current position -5 and +5

                // console.log('\n\nStored Range: ' + k0 + '  ' + orig[k0] + '  ' + k0 % 18 + '\n' +
                //     'Actual: '+lookL[0]+'\t\t'+viewpos+'\n2\t'+lookL[2]+'\t\t\t'+lookR[17]+'\n3\t'+lookL[3]+'\t\t\t'+lookR[16]+
                //     '\n4\t'+lookL[4]+'\t\t\t'+lookR[15]+'\n5\t'+lookL[5]+'\t\t\t'+lookR[14]+'\n6\t'+lookL[6]+
                //     '\t\t\t'+lookR[13]+'\n7\t'+lookL[7]+'\t\t\t'+lookR[12]+'\n8\t'+lookL[8]+'\t\t'+lookR[11]+
                //     '\n9\t'+lookL[9]+'\t\t'+lookR[10]+'\n10\t'+lookL[10]+'\t\t'+lookR[9]+'\n11\t'+lookL[11]+
                //     '\t\t'+lookR[8]+'\n12\t'+lookL[12]+'\t\t'+lookR[7]+'\n13\t'+lookL[13]+'\t\t'+lookR[6]+
                //     '\n14\t'+lookL[14]+'\t\t'+lookR[5]+'\n15\t'+lookL[15]+'\t\t'+lookR[4]+'\n16\t'+lookL[16]+
                //     '\t'+lookR[3]+'\n17\t'+lookL[17]+'\t'+lookR[2]
                // ); // actual at zero, 1 blank, rest proper

                // Start Checking:
                if (['{',':','}',',','[',']'].indexOf(lookL[0]) != -1) {
                    // these are the factors of a dictionary
                    // console.log ('\n\n\t' + viewpos);
                    if (lookL[0] == '{') {
                        // open bracket: for beginning of a key
                        // console.log ('\n\n' + k0 + '\tOPEN Bracket:\t\t' + orig.substring(k0 - 10, k0 + 10));
                        var wrksect1 = 'Open Bracket';
                        // console.log('OPEN--> Value of myarrct: ' + myarrct);
                        // console.log ('\t\t\t(Bracket-Open) Start of Key: loc #' + actpt);
                        if (lookL[3] == '' || lookL[4] == '') {
                            // First Bracket establishing the start of a dictionary
                            myarrct++; // must be done only when one of the choices are selected
                            actpt.push(k0);
                        } else if (lookL[7] == '&#34;: ' && lookR[6] == '{&#34;') {
                            actpt.push(k0);
                            myarrct++;
                            // console.log ('\t\t\t(Bracket-Another1) ...' + orig.substring(k0 - 10, k0 + 10));
                        } else if (lookL[7] == '&#39;: ' && lookR[6] == '{&#39;') {
                            myarrct++;
                            actpt.push(k0);
                            // console.log ('\t\t\t(Bracket-Another2) ...' + orig.substring(k0 - 10, k0 + 10));
                        } else if (lookL[7] == '&#34;: ' && lookR[6] == '{&#39;') {
                            myarrct++;
                            actpt.push(k0);
                            // console.log ('\t\t\t(Bracket-Another3) ...' + orig.substring(k0 - 10, k0 + 10));
                        } else if (lookL[7] == '&#39;: ' && lookR[6] == '{&#34;') {
                            myarrct++;
                            actpt.push(k0);
                            // console.log ('\t\t\t(Bracket-Another4) ...' + orig.substring(k0 - 10, k0 + 10));
                        } else if (lookL[7] == '&#34;: ' && lookR[7] == '{u&#34;') {
                            myarrct++;
                            actpt.push(k0);
                            // console.log ('\t\t\t(Bracket-Another5) ...' + orig.substring(k0 - 10, k0 + 10));
                        } else if (lookL[7] == '&#39;: ' && lookR[7] == '{u&#39;') {
                            myarrct++;
                            actpt.push(k0);
                            // console.log ('\t\t\t(Bracket-Another6) ...' + orig.substring(k0 - 10, k0 + 10));
                        } else if (lookL[7] == '&#34;: ' && lookR[7] == '{u&#39;') {
                            myarrct++;
                            actpt.push(k0);
                            // console.log ('\t\t\t(Bracket-Another7) ...' + orig.substring(k0 - 10, k0 + 10));
                        } else if (lookL[7] == '&#39;: ' && lookR[7] == '{u&#34;') {
                            myarrct++;
                            actpt.push(k0);
                            // console.log ('\t\t\t(Bracket-Another8) ...' + orig.substring(k0 - 10, k0 + 10));
                        } else {
                            // console.log(k0 + ' Checking on Open Bracket\t\t' + orig.substring(k0 - 10, k0 + 10))
                            // alert(k0 + '  OPEN Bracket Not SetUp')
                            // console.log ('\nThis OPEN BRACKET Response Not SetUp.\n\t\t'+orig.substring(k0-10, k0+10)+'\nLast: ' + lookL[9] + '\nNext: ' + lookR[9]);
                        };
                    } else if (lookL[0] == ':') {
                        // colon: for seperating keys from its value
                        // : {'  : {"  : ['  : ["  : u'   : u"   : '  : "   : (one space)
                        // console.log (k0 + '\tCOLON:\t\t' + orig.substring(k0 - 10, k0 + 10));
                        var wrksect1 = 'Colon';
                        if (lookL[5] == '&#34;' && lookR[8] == ': [u&#34;') {
                            tmpk = actpt.pop(); // close out old key
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            actpt.push(k0); // start new value
                            if (x != -1 && y != -1) {
                                skey = pkey.substring(x+1,y);
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                if (myarrct == 0) {
                                    arr0[arr0.length] = skey; // add the main key
                                } else if (myarrct == 1) {
                                    arr1[arr1.length] = skey; // add the main key*
                                } else {
                                    console.log('Array Not Setup: ' + myarrct);
                                };
                            } else {
                                alert('Situation Not Setup 5109');
                            };
                        } else if (lookL[5] == '&#39;' && lookR[9] == ': [u&#39;') {
                            tmpk = actpt.pop(); // close out old key
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            actpt.push(k0); // start new value
                            if (x != -1 && y != -1) {
                                skey = pkey.substring(x+1,y);
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                if (myarrct == 0) {
                                    arr0[arr0.length] = skey; // add the main key
                                } else if (myarrct == 1) {
                                    arr1[arr1.length] = skey; // add the main key*
                                } else {
                                    console.log('Array Not Setup: ' + myarrct);
                                };
                            } else {
                                alert('Situation Not Setup 5109');
                            };
                            // console.log ('\to>\t['+arr0+']\t['+arr1+']\t['+arr2+']');
                        } else if (lookL[5] == '&#34;' && lookR[9] == ': [u&#39;') {
                            tmpk = actpt.pop(); // close out old key
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            actpt.push(k0); // start new value
                            if (x != -1 && y != -1) {
                                skey = pkey.substring(x+1,y);
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                if (myarrct == 0) {
                                    arr0[arr0.length] = skey; // add the main key
                                } else if (myarrct == 1) {
                                    arr1[arr1.length] = skey; // add the main key*
                                } else {
                                    console.log('Array Not Setup: ' + myarrct);
                                };
                            } else {
                                alert('Situation Not Setup 5109');
                            };
                        } else if (lookL[5] == '&#39;' && lookR[9] == ': [u&#34;') {
                            tmpk = actpt.pop(); // close out old key
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            actpt.push(k0); // start new value
                            if (x != -1 && y != -1) {
                                skey = pkey.substring(x+1,y);
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                if (myarrct == 0) {
                                    arr0[arr0.length] = skey; // add the main key
                                } else if (myarrct == 1) {
                                    arr1[arr1.length] = skey; // add the main key*
                                } else {
                                    console.log('Array Not Setup: ' + myarrct);
                                };
                            } else {
                                alert('Situation Not Setup 5109');
                            };
                        } else if (lookL[5] == '&#34;' && lookR[8] == ': [&#34;') {
                            tmpk = actpt.pop(); // close out old key
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            actpt.push(k0); // start new value
                            if (x != -1 && y != -1) {
                                skey = pkey.substring(x+1,y);
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                if (myarrct == 0) {
                                    arr0[arr0.length] = skey; // add the main key
                                } else if (myarrct == 1) {
                                    arr1[arr1.length] = skey; // add the main key*
                                } else {
                                    console.log('Array Not Setup: ' + myarrct);
                                };
                            } else {
                                alert('Situation Not Setup 5109');
                            };
                        } else if (lookL[5] == '&#39;' && lookR[8] == ': [&#39;') {
                            tmpk = actpt.pop(); // close out old key
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            actpt.push(k0); // start new value
                            if (x != -1 && y != -1) {
                                skey = pkey.substring(x+1,y);
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                if (myarrct == 0) {
                                    arr0[arr0.length] = skey; // add the main key
                                } else if (myarrct == 1) {
                                    arr1[arr1.length] = skey; // add the main key*
                                } else {
                                    console.log('Array Not Setup: ' + myarrct);
                                };
                            } else {
                                alert('Situation Not Setup 5109');
                            };
                            // console.log ('o>\t['+arr0+']\t['+arr1+']\t['+arr2+']\t' + actpt);
                        } else if (lookL[5] == '&#34;' && lookR[8] == ': [&#39;') {
                            tmpk = actpt.pop(); // close out old key
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            actpt.push(k0); // start new value
                            if (x != -1 && y != -1) {
                                skey = pkey.substring(x+1,y);
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                if (myarrct == 0) {
                                    arr0[arr0.length] = skey; // add the main key
                                } else if (myarrct == 1) {
                                    arr1[arr1.length] = skey; // add the main key*
                                } else {
                                    console.log('Array Not Setup: ' + myarrct);
                                };
                            } else {
                                alert('Situation Not Setup 5109');
                            };
                        } else if (lookL[5] == '&#39;' && lookR[8] == ': [&#34;') {
                            tmpk = actpt.pop(); // close out old key
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            actpt.push(k0); // start new value
                            if (x != -1 && y != -1) {
                                skey = pkey.substring(x+1,y);
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                if (myarrct == 0) {
                                    arr0[arr0.length] = skey; // add the main key
                                } else if (myarrct == 1) {
                                    arr1[arr1.length] = skey; // add the main key*
                                } else {
                                    console.log('Array Not Setup: ' + myarrct);
                                };
                            } else {
                                alert('Situation Not Setup 5109');
                            };
                        } else if (lookL[5] == '&#34;' && lookR[9] == ': {u&#34;') {
                            tmpk = actpt.pop(); // close out old key, no push open brack next
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            if ( x != -1 && y != -1 ) {
                                skey = pkey.substring( x + 1, y );
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                if (myarrct == 0) {
                                    arr0[arr0.length] = skey; // add the main key*
                                } else if (myarrct == 1) {
                                    arr1[arr1.length] = skey; // add the main key
                                } else if (myarrct == 2) {
                                    arr2[arr2.length] = skey; // add the main key
                                } else {
                                    console.log('Array Not Setup: ' + myarrct);
                                };
                            } else {
                                alert('Situation Not Setup 009');
                            };
                        } else if (lookL[5] == '&#39;' && lookR[9] == ': {u&#39;') {
                            tmpk = actpt.pop(); // close out old key, no push open brack next
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            if ( x != -1 && y != -1 ) {
                                skey = pkey.substring( x + 1, y );
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                if (myarrct == 0) {
                                    arr0[arr0.length] = skey; // add the main key*
                                } else if (myarrct == 1) {
                                    arr1[arr1.length] = skey; // add the main key
                                } else if (myarrct == 2) {
                                    arr2[arr2.length] = skey; // add the main key
                                } else {
                                    console.log('Array Not Setup: ' + myarrct);
                                };
                            } else {
                                alert('Situation Not Setup 0039');
                            };
                            // console.log ('\to>\t['+arr0+']\t['+arr1+']\t['+arr2+']');
                        } else if (lookL[5] == '&#34;' && lookR[9] == ': {u&#39;') {
                            tmpk = actpt.pop(); // close out old key, no push open brack next
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            if ( x != -1 && y != -1 ) {
                                skey = pkey.substring(x+1,y);
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                if (myarrct == 0) {
                                    arr0[arr0.length] = skey; // add the main key*
                                } else if (myarrct == 1) {
                                    arr1[arr1.length] = skey; // add the main key
                                } else {
                                    console.log('Array Not Setup: ' + myarrct);
                                };
                            } else {
                                alert('Situation Not Setup 009');
                            };
                        } else if (lookL[5] == '&#39;' && lookR[9] == ': {u&#34;') {
                            tmpk = actpt.pop(); // close out old key, no push open brack next
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            if ( x != -1 && y != -1 ) {
                                skey = pkey.substring( x + 1, y );
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                if (myarrct == 0) {
                                    arr0[arr0.length] = skey; // add the main key*
                                } else if (myarrct == 1) {
                                    arr1[arr1.length] = skey; // add the main key
                                } else {
                                    console.log('Array Not Setup: ' + myarrct);
                                };
                            } else {
                                alert('Situation Not Setup 009');
                            };
                        } else if (lookL[5] == '&#34;' && lookR[8] == ': {&#34;') {
                            tmpk = actpt.pop(); // close out old key, no push open brack next
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            if ( x != -1 && y != -1 ) {
                                skey = pkey.substring( x + 1, y );
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                if (myarrct == 0) {
                                    arr0[arr0.length] = skey; // add the main key*
                                } else if (myarrct == 1) {
                                    arr1[arr1.length] = skey; // add the main key
                                } else {
                                    console.log('Array Not Setup: ' + myarrct);
                                };
                            } else {
                                alert('Situation Not Setup 009');
                            };
                        } else if (lookL[5] == '&#39;' && lookR[8] == ': {&#39;') {
                            tmpk = actpt.pop(); // close out old key, no push open brack next
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            if ( x != -1 && y != -1 ) {
                                skey = pkey.substring( x + 1, y );
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                if (myarrct == 0) {
                                    arr0[arr0.length] = skey; // add the main key*
                                } else if (myarrct == 1) {
                                    arr1[arr1.length] = skey; // add the main key
                                } else {
                                    console.log('Array Not Setup: ' + myarrct);
                                };
                            } else {
                                alert('Situation Not Setup 009');
                            };
                            // console.log ('o>\t['+arr0+']\t['+arr1+']\t['+arr2+']');
                        } else if (lookL[5] == '&#34;' && lookR[8] == ': {&#39;') {
                            tmpk = actpt.pop(); // close out old key, no push open brack next
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            if ( x != -1 && y != -1 ) {
                                skey = pkey.substring( x + 1, y );
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                if (myarrct == 0) {
                                    arr0[arr0.length] = skey; // add the main key*
                                } else if (myarrct == 1) {
                                    arr1[arr1.length] = skey; // add the main key
                                } else {
                                    console.log('Array Not Setup: ' + myarrct);
                                };
                            } else {
                                alert('Situation Not Setup 009');
                            };
                        } else if (lookL[5] == '&#39;' && lookR[8] == ': {&#34;') {
                            tmpk = actpt.pop(); // close out old key, no push open brack next
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            if ( x != -1 && y != -1 ) {
                                skey = pkey.substring( x + 1, y );
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                if (myarrct == 0) {
                                    arr0[arr0.length] = skey; // add the main key*
                                } else if (myarrct == 1) {
                                    arr1[arr1.length] = skey; // add the main key
                                } else {
                                    console.log('Array Not Setup: ' + myarrct);
                                };
                            } else {
                                alert('Situation Not Setup 009');
                            };
                        } else if (lookL[5] == '&#34;' && lookR[8] == ': u&#34;') {
                            tmpk = actpt.pop(); // close out old key
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            actpt.push(k0); // start new value
                            if (x != -1 && y != -1) {
                                skey = pkey.substring(x+1,y);
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                if (myarrct == 0) {
                                    arr0[arr0.length] = skey; // add the main key
                                } else if (myarrct == 1) {
                                    arr1[arr1.length] = skey; // add the main key*
                                } else if (myarrct == 2) {
                                    arr2[arr2.length] = skey; // add the main key
                                } else {
                                    console.log('Array Not Setup: ' + myarrct);
                                };
                            } else {
                                alert('Situation Not Setup 51709');
                            };
                        } else if (lookL[5] == '&#34;' && lookR[13] == ': u&#34;&#39;') {
                            tmpk = actpt.pop(); // close out old key
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            actpt.push(k0); // start new value
                            quoStatus = true;
                            if (x != -1 && y != -1) {
                                skey = pkey.substring(x+1,y);
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                if (myarrct == 0) {
                                    arr0[arr0.length] = skey; // add the main key
                                } else if (myarrct == 1) {
                                    arr1[arr1.length] = skey; // add the main key*
                                } else if (myarrct == 2) {
                                    arr2[arr2.length] = skey; // add the main key
                                } else {
                                    console.log('Array Not Setup: ' + myarrct);
                                };
                            } else {
                                alert('Situation Not Setup 5109');
                            };
                            // console.log ('\too>\t['+arr0+']\t['+arr1+']\t['+arr2+']');
                        } else if (lookL[5] == '&#34;' && lookR[13] == ': u&#39;&#34;') {
                            tmpk = actpt.pop(); // close out old key
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            actpt.push(k0); // start new value
                            quoStatus = true;
                            if (x != -1 && y != -1) {
                                skey = pkey.substring(x+1,y);
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                if (myarrct == 0) {
                                    arr0[arr0.length] = skey; // add the main key
                                } else if (myarrct == 1) {
                                    arr1[arr1.length] = skey; // add the main key*
                                } else if (myarrct == 2) {
                                    arr2[arr2.length] = skey; // add the main key
                                } else {
                                    console.log('Array Not Setup: ' + myarrct);
                                };
                            } else {
                                alert('Situation Not Setup 5109');
                            };
                            // console.log ('\too>\t['+arr0+']\t['+arr1+']\t['+arr2+']');
                        } else if (lookL[5] == '&#39;' && lookR[13] == ': u&#34;&#39;') {
                            tmpk = actpt.pop(); // close out old key
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            actpt.push(k0); // start new value
                            quoStatus = true;
                            if (x != -1 && y != -1) {
                                skey = pkey.substring(x+1,y);
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                if (myarrct == 0) {
                                    arr0[arr0.length] = skey; // add the main key
                                } else if (myarrct == 1) {
                                    arr1[arr1.length] = skey; // add the main key*
                                } else if (myarrct == 2) {
                                    arr2[arr2.length] = skey; // add the main key
                                } else {
                                    console.log('Array Not Setup: ' + myarrct);
                                };
                            } else {
                                alert('Situation Not Setup 5109');
                            };
                            // console.log ('\too>\t['+arr0+']\t['+arr1+']\t['+arr2+']');
                        } else if (lookL[5] == '&#39;' && lookR[13] == ': u&#39;&#34;') {
                            tmpk = actpt.pop(); // close out old key
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            actpt.push(k0); // start new value
                            quoStatus = true;
                            if (x != -1 && y != -1) {
                                skey = pkey.substring(x+1,y);
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                if (myarrct == 0) {
                                    arr0[arr0.length] = skey; // add the main key
                                } else if (myarrct == 1) {
                                    arr1[arr1.length] = skey; // add the main key*
                                } else if (myarrct == 2) {
                                    arr2[arr2.length] = skey; // add the main key
                                } else {
                                    console.log('Array Not Setup: ' + myarrct);
                                };
                            } else {
                                alert('Situation Not Setup 5109');
                            };
                            // console.log ('\too>\t['+arr0+']\t['+arr1+']\t['+arr2+']');
                        } else if (lookL[5] == '&#39;' && lookR[8] == ': u&#39;') {
                            tmpk = actpt.pop(); // close out old key
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            actpt.push(k0); // start new value
                            if (x != -1 && y != -1) {
                                skey = pkey.substring(x+1,y);
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                if (myarrct == 0) {
                                    arr0[arr0.length] = skey; // add the main key
                                } else if (myarrct == 1) {
                                    arr1[arr1.length] = skey; // add the main key*
                                } else if (myarrct == 2) {
                                    arr2[arr2.length] = skey; // add the main key
                                } else if (myarrct == 3) {
                                    arr3[arr3.length] = skey; // add the main key
                                } else {
                                    console.log('Array Not Setup: ' + myarrct);
                                };
                            } else {
                                alert('Situation Not Setup 53109');
                            };
                            // console.log ('\too>\t['+arr0+']\t['+arr1+']\t['+arr2+']');
                        } else if (lookL[5] == '&#34;' && lookR[8] == ': u&#39;') {
                            tmpk = actpt.pop(); // close out old key
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            actpt.push(k0); // start new value
                            if (x != -1 && y != -1) {
                                skey = pkey.substring(x+1,y);
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                if (myarrct == 0) {
                                    arr0[arr0.length] = skey; // add the main key
                                } else if (myarrct == 1) {
                                    arr1[arr1.length] = skey; // add the main key*
                                } else {
                                    console.log('Array Not Setup: ' + myarrct);
                                };
                            } else {
                                alert('Situation Not Setup 5109');
                            };
                        } else if (lookL[5] == '&#39;' && lookR[8] == ': u&#34;') {
                            tmpk = actpt.pop(); // close out old key
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            actpt.push(k0); // start new value
                            if (x != -1 && y != -1) {
                                skey = pkey.substring(x+1,y);
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                if (myarrct == 0) {
                                    arr0[arr0.length] = skey; // add the main key
                                } else if (myarrct == 1) {
                                    arr1[arr1.length] = skey; // add the main key*
                                } else {
                                    console.log('Array Not Setup: ' + myarrct);
                                };
                            } else {
                                alert('Situation Not Setup 5109');
                            };
                        } else if (lookL[5] == '&#34;' && lookR[7] == ': &#34;') {
                            tmpk = actpt.pop(); // close out old key
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            actpt.push(k0); // start new value
                            if (x != -1 && y != -1) {
                                skey = pkey.substring(x+1,y);
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                if (myarrct == 0) {
                                    arr0[arr0.length] = skey; // add the main key
                                } else if (myarrct == 1) {
                                    arr1[arr1.length] = skey; // add the main key*
                                } else {
                                    console.log('Array Not Setup: ' + myarrct);
                                };
                            } else {
                                alert('Situation Not Setup 5109');
                            };
                        } else if (lookL[5] == '&#39;' && lookR[7] == ': &#39;') {
                            tmpk = actpt.pop(); // close out old key
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            actpt.push(k0); // start new value
                            if (x != -1 && y != -1) {
                                skey = pkey.substring(x+1,y);
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                if (myarrct == 0) {
                                    arr0[arr0.length] = skey; // add the main key
                                } else if (myarrct == 1) {
                                    arr1[arr1.length] = skey; // add the main key*
                                } else {
                                    console.log('Array Not Setup: ' + myarrct);
                                };
                            } else {
                                alert('Situation Not Setup 5109');
                            };
                            // console.log ('-o>\t['+arr0+']\t['+arr1+']\t['+arr2+']');
                        } else if (lookL[5] == '&#34;' && lookR[7] == ': &#39;') {
                            tmpk = actpt.pop(); // close out old key
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            actpt.push(k0); // start new value
                            if (x != -1 && y != -1) {
                                skey = pkey.substring(x+1,y);
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                if (myarrct == 0) {
                                    arr0[arr0.length] = skey; // add the main key
                                } else if (myarrct == 1) {
                                    arr1[arr1.length] = skey; // add the main key*
                                } else {
                                    console.log('Array Not Setup: ' + myarrct);
                                };
                            } else {
                                alert('Situation Not Setup 5109');
                            };
                        } else if (lookL[5] == '&#39;' && lookR[7] == ': &#34;') {
                            tmpk = actpt.pop(); // close out old key
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            actpt.push(k0); // start new value
                            if (x != -1 && y != -1) {
                                skey = pkey.substring(x+1,y);
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                if (myarrct == 0) {
                                    arr0[arr0.length] = skey; // add the main key
                                } else if (myarrct == 1) {
                                    arr1[arr1.length] = skey; // add the main key*
                                } else {
                                    console.log('Array Not Setup: ' + myarrct);
                                };
                            } else {
                                alert('Situation Not Setup 5109');
                            };
                        } else if (lookL[5] == '&#34;' && lookR[2] == ': ') {
                            tmpk = actpt.pop(); // close out old key
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            actpt.push(k0); // start new value
                            if (x != -1 && y != -1) {
                                skey = pkey.substring(x+1,y);
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                if (myarrct == 0) {
                                    arr0[arr0.length] = skey; // add the main key
                                } else if (myarrct == 1) {
                                    arr1[arr1.length] = skey; // add the main key*
                                } else {
                                    console.log('Array Not Setup: ' + myarrct);
                                };
                            } else {
                                alert('Situation Not Setup 5109');
                            };
                        } else if (lookL[5] == '&#39;' && lookR[2] == ': ') {
                            tmpk = actpt.pop(); // close out old key
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            actpt.push(k0); // start new value
                            if (x != -1 && y != -1) {
                                skey = pkey.substring(x+1,y);
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                // console.log(skey + '... upcoming value is number');
                                if (myarrct == 0) {
                                    arr0[arr0.length] = skey; // add the main key
                                } else if (myarrct == 1) {
                                    arr1[arr1.length] = skey; // add the main key*
                                } else if (myarrct == -1) {
                                    console.log('\n\nWhat is this?\n'+lookL[5]+'\n'+lookR[5]+'\n'+viewpos);
                                } else {
                                    console.log('Array Not Setup: ' + myarrct);
                                };
                            } else {
                                alert('Situation Not Setup 5109');
                            };
                            // console.log ('#o>\t['+arr0+']\t['+arr1+']\t['+arr2+']');
                        } else {
                            // console.log(k0 + ' Checking on Colon\t\t' + orig.substring(k0 - 10, k0 + 10))
                            // if it does'nt fit previous might be part of data/value
                            // alert(k0 + ' This COLON Response Not SetUp --> 812343');
                            // console.log ('\nThis COLON Response Not SetUp.\n\t\t' + orig.substring(k0 - 10, k0 + 10) +
                            //     '\nLast: ' + lookL[9] + '\nNext: ' + lookR[9]);
                        };
                        // console.log ('->\t['+arr0+']\t['+arr1+']\t['+arr2+']');
                    } else if (lookL[0] == '}') {
                        // close bracket: for ending a value and/or starting a new key
                        // console.log ('\n\n' + k0 + '\tCLOSE Bracket:\t\t' + orig.substring(k0 - 20, k0 + 10));
                        // console.log('CLOSE--> Value of myarrct: ' + myarrct);
                        var wrksect1 = 'Close Bracket';
                        if (lookL[5] == '&#34;' && lookR[9] == '}, u&#34;') {
                            // console.log ('Close Bracket... end position of value');
                            myarrct--;
                            tmpk = actpt.pop(); // close out old key
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            if (x != -1 && y != -1) {
                                skey = pkey.substring(x+1,y);
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                arr2[arr2.length] = skey;
                            } else {
                                alert('Situation Not Setup 18409');
                            };
                            // console.log ('->\t['+arr0+']\t['+arr1+']\t['+arr2+']\n\n');
                            result[result.length] = [arr0,arr1,arr2,arr3,arr4,arr5]
                            arr0 = [], arr1 = [], arr2 = [], arr3 = [], arr4 = [], arr5 = [];
                        } else if (lookL[5] == '&#39;' && lookR[9] == '}, u&#39;') {
                            // console.log ('Close Bracket... end position of value');
                            myarrct--;
                            tmpk = actpt.pop(); // close out old key
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            if (x != -1 && y != -1) {
                                skey = pkey.substring(x+1,y);
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                arr2[arr2.length] = skey;
                            } else {
                                alert('Situation Not Setup 18409');
                            };
                            // console.log ('->\t['+arr0+']\t['+arr1+']\t['+arr2+']\n\n');
                            result[result.length] = [arr0,arr1,arr2,arr3,arr4,arr5]
                            arr0 = [], arr1 = [], arr2 = [], arr3 = [], arr4 = [], arr5 = [];
                        } else if (lookL[5] == '&#34;' && lookR[9] == '}, u&#39;') {
                            // console.log ('Close Bracket... end position of value');
                            myarrct--;
                            tmpk = actpt.pop(); // close out old key
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            if (x != -1 && y != -1) {
                                skey = pkey.substring(x+1,y);
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                arr2[arr2.length] = skey;
                            } else {
                                alert('Situation Not Setup 18409');
                            };
                            // console.log ('->\t['+arr0+']\t['+arr1+']\t['+arr2+']\n\n');
                            result[result.length] = [arr0,arr1,arr2,arr3,arr4,arr5]
                            arr0 = [], arr1 = [], arr2 = [], arr3 = [], arr4 = [], arr5 = [];
                        } else if (lookL[5] == '&#39;' && lookR[9] == '}, u&#34;') {
                            // console.log ('Close Bracket... end position of value');
                            myarrct--;
                            tmpk = actpt.pop(); // close out old key
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            if (x != -1 && y != -1) {
                                skey = pkey.substring(x+1,y);
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                arr2[arr2.length] = skey;
                            } else {
                                alert('Situation Not Setup 18409');
                            };
                            // console.log ('->\t['+arr0+']\t['+arr1+']\t['+arr2+']\n\n');
                            result[result.length] = [arr0,arr1,arr2,arr3,arr4,arr5]
                            arr0 = [], arr1 = [], arr2 = [], arr3 = [], arr4 = [], arr5 = [];
                        } else if (lookL[5] == '&#34;' && lookR[8] == '}, &#34;') {
                            // console.log ('Close Bracket... end position of value'); 34version
                            myarrct--;
                            tmpk = actpt.pop(); // close out old key
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            if (x != -1 && y != -1) {
                                skey = pkey.substring(x+1,y);
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                arr2[arr2.length] = skey;
                            } else {
                                alert('Situation Not Setup 13509');
                            };
                            // console.log ('->\t['+arr0+']\t['+arr1+']\t['+arr2+']\n\n');
                            result[result.length] = [arr0,arr1,arr2,arr3,arr4,arr5]
                            arr0 = [], arr1 = [], arr2 = [], arr3 = [], arr4 = [], arr5 = [];
                        } else if (lookL[5] == '&#39;' && lookR[8] == '}, &#39;') {
                            // console.log ('Close Bracket... end position of value'); 34version
                            myarrct--;
                            tmpk = actpt.pop(); // close out old key
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            if (x != -1 && y != -1) {
                                skey = pkey.substring(x+1,y);
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                arr2[arr2.length] = skey;
                            } else {
                                alert('Situation Not Setup 13509');
                            };
                            // console.log ('-x>\t['+arr0+']\t['+arr1+']\t['+arr2+']\n\n');
                            result[result.length] = [arr0,arr1,arr2,arr3,arr4,arr5]
                            arr0 = [], arr1 = [], arr2 = [], arr3 = [], arr4 = [], arr5 = []; arrg = [];
                        } else if (lookL[5] == '&#34;' && lookR[8] == '}, &#39;') {
                            // console.log ('Close Bracket... end position of value'); 34version
                            myarrct--;
                            tmpk = actpt.pop(); // close out old key
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            if (x != -1 && y != -1) {
                                skey = pkey.substring(x+1,y);
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                arr2[arr2.length] = skey;
                            } else {
                                alert('Situation Not Setup 13509');
                            };
                            // console.log ('->\t['+arr0+']\t['+arr1+']\t['+arr2+']\n\n');
                            result[result.length] = [arr0,arr1,arr2,arr3,arr4,arr5]
                            arr0 = [], arr1 = [], arr2 = [], arr3 = [], arr4 = [], arr5 = [];
                        } else if (lookL[5] == '&#39;' && lookR[8] == '}, &#34;') {
                            // next to different quotation (')
                            myarrct--;
                            tmpk = actpt.pop(); // close out old key
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            if (x != -1 && y != -1) {
                                skey = pkey.substring(x+1,y);
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                arr2[arr2.length] = skey;
                            } else {
                                alert('Situation Not Setup 1069');
                            };
                            // console.log ('->\t['+arr0+']\t['+arr1+']\t['+arr2+']\n\n');
                            result[result.length] = [arr0,arr1,arr2,arr3,arr4,arr5]
                            arr0 = [], arr1 = [], arr2 = [], arr3 = [], arr4 = [], arr5 = [];
                        } else if (lookL[6] == '&#34;]' && lookR[8] == '}, &#34;') {
                            // Music Modification --5
                            // console.log ('\t<->\t['+arr0+']\t['+arr1+']\t['+arr2+']\t['+arrg+']\n\n');
                            myarrct--;
                            tmpk = actpt.pop(); // close out old key
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            if (x != -1 && y != -1) {
                                skey = pkey.substring(x+1,y);
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                if (arrg.length == 0) {
                                    // pop when there is only one data with bracket
                                    arr2[arr2.length] = skey;
                                } else {
                                    // pop when there is data already within the bracket
                                    arrg[arrg.length] = skey; // add the last one before preceeding
                                    arr2[arr2.length] = arrg;
                                };
                            } else {
                                alert('Situation Not Setup 0039');
                            };
                            // console.log ('->\t['+arr0+']\t['+arr1+']\t['+arr2+']\n\n');
                            result[result.length] = [arr0,arr1,arr2,arr3,arr4,arr5]
                            arr0 = [], arr1 = [], arr2 = [], arr3 = [], arr4 = [], arr5 = [], arrg = [];
                        } else if (lookL[6] == '&#39;]' && lookR[8] == '}, &#39;') {
                            // Music Modification --5
                            // console.log ('\t<->\t['+arr0+']\t['+arr1+']\t['+arr2+']\t['+arrg+']\n\n');
                            myarrct--;
                            tmpk = actpt.pop(); // close out old key
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            if (x != -1 && y != -1) {
                                skey = pkey.substring(x+1,y);
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                if (arrg.length == 0) {
                                    // pop when there is only one data with bracket
                                    arr2[arr2.length] = skey;
                                } else {
                                    // pop when there is data already within the bracket
                                    arrg[arrg.length] = skey; // add the last one before preceeding
                                    arr2[arr2.length] = arrg;
                                };
                            } else {
                                alert('Situation Not Setup 0039');
                            };
                            // console.log ('->\t['+arr0+']\t['+arr1+']\t['+arr2+']\n\n');
                            result[result.length] = [arr0,arr1,arr2,arr3,arr4,arr5]
                            arr0 = [], arr1 = [], arr2 = [], arr3 = [], arr4 = [], arr5 = [], arrg = [];
                        } else if (lookL[6] == '&#34;]' && lookR[8] == '}, &#39;') {
                            // Music Modification --5
                            myarrct--;
                            tmpk = actpt.pop(); // close out old key
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            if (x != -1 && y != -1) {
                                skey = pkey.substring(x+1,y);
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                arr2[arr2.length] = skey;
                            } else {
                                alert('Situation Not Setup 0039');
                            };
                            // console.log ('->\t['+arr0+']\t['+arr1+']\t['+arr2+']\n\n');
                            result[result.length] = [arr0,arr1,arr2,arr3,arr4,arr5]
                            arr0 = [], arr1 = [], arr2 = [], arr3 = [], arr4 = [], arr5 = [];
                        } else if (lookL[6] == '&#39;]' && lookR[8] == '}, &#34;') {
                            // Music Modification --5
                            myarrct--;
                            tmpk = actpt.pop(); // close out old key
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            if (x != -1 && y != -1) {
                                skey = pkey.substring(x+1,y);
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                arr2[arr2.length] = skey;
                            } else {
                                alert('Situation Not Setup 0039');
                            };
                            // console.log ('->\t['+arr0+']\t['+arr1+']\t['+arr2+']\n\n');
                            result[result.length] = [arr0,arr1,arr2,arr3,arr4,arr5]
                            arr0 = [], arr1 = [], arr2 = [], arr3 = [], arr4 = [], arr5 = [];
                        } else if (lookL[5] == '&#34;' && lookR[2] == '}}') {
                            // console.log ('Close the Value ');
                            myarrct--;
                            tmpk = actpt.pop(); // close out old key
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            if (x != -1 && y != -1) {
                                skey = pkey.substring(x+1,y);
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                arr2[arr2.length] = skey;
                            } else {
                                alert('Situation Not Setup 009');
                            };
                            // console.log ('->\t['+arr0+']\t['+arr1+']\t['+arr2+']\n\n');
                            result[result.length] = [arr0,arr1,arr2,arr3,arr4,arr5]
                            arr0 = [], arr1 = [], arr2 = [], arr3 = [], arr4 = [], arr5 = [];
                        } else if (lookL[5] == '&#39;' && lookR[2] == '}}') {
                            // console.log ('Close the Value ');
                            myarrct--;
                            tmpk = actpt.pop(); // close out old key
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            if (x != -1 && y != -1) {
                                skey = pkey.substring(x+1,y);
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                arr2[arr2.length] = skey;
                            } else {
                                alert('Situation Not Setup 009');
                            };
                            // console.log ('->\t['+arr0+']\t['+arr1+']\t['+arr2+']\n\n');
                            result[result.length] = [arr0,arr1,arr2,arr3,arr4,arr5]
                            arr0 = [], arr1 = [], arr2 = [], arr3 = [], arr4 = [], arr5 = [];
                        } else if (lookL[6] == '&#34;]' && lookR[2] == '}}') {
                            // Music Modification --?
                            myarrct--;
                            tmpk = actpt.pop(); // close out old key
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            if (x != -1 && y != -1) {
                                skey = pkey.substring(x+1,y);
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                arr2[arr2.length] = skey;
                            } else {
                                alert('Situation Not Setup 412009');
                            };
                            // console.log ('->\t['+arr0+']\t['+arr1+']\t['+arr2+']\n\n');
                            result[result.length] = [arr0,arr1,arr2,arr3,arr4,arr5]
                            arr0 = [], arr1 = [], arr2 = [], arr3 = [], arr4 = [], arr5 = [];
                        } else if (lookL[6] == '&#39;]' && lookR[2] == '}}') {
                            // Music Modification --?
                            myarrct--;
                            tmpk = actpt.pop(); // close out old key
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            if (x != -1 && y != -1) {
                                skey = pkey.substring(x+1,y);
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                arr2[arr2.length] = skey;
                            } else {
                                alert('Situation Not Setup 412009');
                            };
                            // console.log ('-X>\t['+arr0+']\t['+arr1+']\t['+arr2+']\n\n');
                            result[result.length] = [arr0,arr1,arr2,arr3,arr4,arr5]
                            arr0 = [], arr1 = [], arr2 = [], arr3 = [], arr4 = [], arr5 = [];
                        } else if (lookL[7] == '&#34;]}' && lookR[2] != '') {
                            // Music Modification --?
                            myarrct--;
                            tmpk = actpt.pop(); // close out old key
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            if (x != -1 && y != -1) {
                                skey = pkey.substring(x+1,y);
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                arr2[arr2.length] = skey;
                            } else {
                                console.log('At The End... Do nothing');
                            };
                            // console.log ('->\t['+arr0+']\t['+arr1+']\t['+arr2+']\n\n');
                            result[result.length] = [arr0,arr1,arr2,arr3,arr4,arr5]
                            arr0 = [], arr1 = [], arr2 = [], arr3 = [], arr4 = [], arr5 = [];
                        } else if (lookL[7] == '&#39;]}' && lookR[2] != '') {
                            // Music Modification --?
                            myarrct--;
                            tmpk = actpt.pop(); // close out old key
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            // console.log('\n\nError Here: ' + myarrct + '\n' + actpt);
                            // if (x != -1 && y != -1) {
                            //     skey = pkey.substring(x+1,y);
                            //     for (xp in charchgble) {
                            //         if (skey.indexOf(charchgble[xp][0]) != -1) {
                            //             skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                            //         };
                            //     };
                            //     // arr2[arr2.length] = skey;
                            // } else {
                            //     console.log('At The End... Do nothing');
                            // };
                            // console.log('At The End... Do nothing');
                            // console.log ('->\t['+arr0+']\t['+arr1+']\t['+arr2+']\n\n');
                            result[result.length] = [arr0,arr1,arr2,arr3,arr4,arr5]
                            arr0 = [], arr1 = [], arr2 = [], arr3 = [], arr4 = [], arr5 = [];
                        } else if (lookL[10] == '&#34;&#39;' && lookR[2] != '') {
                            // Music Modification --5
                            // console.log ('\t<->\t['+arr0+']\t['+arr1+']\t['+arr2+']\t['+arrg+']\n\n');
                            myarrct--;
                            tmpk = actpt.pop(); // close out old key
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            if (x != -1 && y != -1) {
                                skey = pkey.substring(x+1,y);
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                if (arrg.length == 0) {
                                    // pop when there is only one data with bracket
                                    if (dicStatus == 'single') {
                                        arr1[arr1.length] = skey;
                                    } else if (dicStatus == 'double') {
                                        arr2[arr2.length] = skey;
                                    };
                                } else {
                                    // pop when there is data already within the bracket
                                    arrg[arrg.length] = skey; // add the last one before preceeding
                                    if (dicStatus == 'single') {
                                        arr1[arr1.length] = arrg;
                                    } else if (dicStatus == 'double') {
                                        arr2[arr2.length] = arrg;
                                    };
                                };
                            } else {
                                alert('Situation Not Setup 0039');
                            };
                            // console.log ('->\t['+arr0+']\t['+arr1+']\t['+arr2+']\n\n');
                            result[result.length] = [arr0,arr1,arr2,arr3,arr4,arr5]
                            arr0 = [], arr1 = [], arr2 = [], arr3 = [], arr4 = [], arr5 = [], arrg = [];
                        } else if (lookL[10] == '&#39;&#34;' && lookR[2] != '') {
                            // Music Modification --5
                            // console.log ('\t<->\t['+arr0+']\t['+arr1+']\t['+arr2+']\t['+arrg+']\n\n');
                            myarrct--;
                            tmpk = actpt.pop(); // close out old key
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            if (x != -1 && y != -1) {
                                skey = pkey.substring(x+1,y);
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                if (arrg.length == 0) {
                                    // pop when there is only one data with bracket
                                    if (dicStatus == 'single') {
                                        arr1[arr1.length] = skey;
                                    } else if (dicStatus == 'double') {
                                        arr2[arr2.length] = skey;
                                    };
                                } else {
                                    // pop when there is data already within the bracket
                                    arrg[arrg.length] = skey; // add the last one before preceeding
                                    if (dicStatus == 'single') {
                                        arr1[arr1.length] = arrg;
                                    } else if (dicStatus == 'double') {
                                        arr2[arr2.length] = arrg;
                                    };
                                };
                            } else {
                                alert('Situation Not Setup 0039');
                            };
                            // console.log ('->\t['+arr0+']\t['+arr1+']\t['+arr2+']\n\n');
                            result[result.length] = [arr0,arr1,arr2,arr3,arr4,arr5]
                            arr0 = [], arr1 = [], arr2 = [], arr3 = [], arr4 = [], arr5 = [], arrg = [];
                        } else {
                            // console.log(k0 + ' Checking on Close Bracket\t\t' + orig.substring(k0 - 10, k0 + 10))
                            // alert(k0 + ' CLOSE Bracket Not Setup');
                            // console.log ('This CLOSE BRACKET Response Not SetUp.\n\n' +
                            //  orig.substring(k0 - 10, k0 + 10) + '\n\nLast: ' + lookL[9] + '\nNext: ' + lookR[9]);
                            // console.log ('\nThis CLOSE BRACKET Response Not SetUp.\n\t\t' + orig.substring(k0 - 10, k0 + 10) +
                            //     '\nLast: ' + lookL[9] + '\nNext: ' + lookR[9]);
                        };
                        // console.log (k0 + '\tCLOSE Bracket:\t\t' + orig.substring(k0 - 10, k0 + 10) + '\n\n\n');
                    } else if (lookL[0] == ',') {
                        // Seperate value to value, value to key ...don't know which one for future
                        // console.log (k0 + '\tCOMMA:\t\t' + orig.substring(k0 - 20, k0 + 20));
                        var wrksect1 = 'Comma';
                        // console.log ('Last5:\t' + lookL[10] + '\nNext5:\t' + lookR[10]);
                        // ', u'   '}, u'  "}, '   ']}, '   ', '   , '    <-- last
                        // }, completes a section
                        if (lookL[10] == '&#34;&#39;' && lookR[8] == ', u&#34;') {
                            tmpk = actpt.pop(); // close out old value ***
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            actpt.push(k0); // start new value
                            quoStatus = false;
                            // console.log ('Adjustment Made 2\t\t' + orig.substring(k0 - 20, k0 + 20));
                            if (x != -1 && y != -1) {
                                skey = pkey.substring(x+1,y);
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                if (myarrct == 0) {
                                    arr1[arr1.length] = skey; // add the main key
                                } else if (myarrct == 1) {
                                    arr2[arr2.length] = skey; // add the main key*
                                } else {
                                    console.log('Array Not Setup: ' + myarrct);
                                };
                            } else {
                                alert('Situation Not Setup 5122');
                            };
                            // console.log ('->\t['+arr0+']\t['+arr1+']\t['+arr2+']\n\n');
                            result[result.length] = [arr0,arr1,arr2,arr3,arr4,arr5]
                            arr0 = [], arr1 = [], arr2 = [], arr3 = [], arr4 = [], arr5 = [];
                            // console.log ('\t==>\t['+arr0+']\t['+arr1+']\t['+arr2+']\n\n');
                        } else if (lookL[10] == '&#34;&#39;' && lookR[8] == ', u&#39;') {
                            tmpk = actpt.pop(); // close out old value ***
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            actpt.push(k0); // start new value
                            quoStatus = false;
                            // console.log ('Adjustment Made 2\t\t' + orig.substring(k0 - 20, k0 + 20));
                            if (x != -1 && y != -1) {
                                skey = pkey.substring(x+1,y);
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                if (myarrct == 0) {
                                    arr1[arr1.length] = skey; // add the main key
                                } else if (myarrct == 1) {
                                    arr2[arr2.length] = skey; // add the main key*
                                } else {
                                    console.log('Array Not Setup: ' + myarrct);
                                };
                            } else {
                                alert('Situation Not Setup 5122');
                            };
                            // console.log ('->\t['+arr0+']\t['+arr1+']\t['+arr2+']\n\n');
                            result[result.length] = [arr0,arr1,arr2,arr3,arr4,arr5]
                            arr0 = [], arr1 = [], arr2 = [], arr3 = [], arr4 = [], arr5 = [];
                            // console.log ('\t==>\t['+arr0+']\t['+arr1+']\t['+arr2+']\n\n');
                        } else if (lookL[10] == '&#39;&#34;' && lookR[8] == ', u&#34;') {
                            tmpk = actpt.pop(); // close out old value ***
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            actpt.push(k0); // start new value
                            quoStatus = false;
                            // console.log ('Adjustment Made 2\t\t' + orig.substring(k0 - 20, k0 + 20));
                            if (x != -1 && y != -1) {
                                skey = pkey.substring(x+1,y);
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                if (myarrct == 0) {
                                    arr1[arr1.length] = skey; // add the main key
                                } else if (myarrct == 1) {
                                    arr2[arr2.length] = skey; // add the main key*
                                } else {
                                    console.log('Array Not Setup: ' + myarrct);
                                };
                            } else {
                                alert('Situation Not Setup 5122');
                            };
                            // console.log ('->\t['+arr0+']\t['+arr1+']\t['+arr2+']\n\n');
                            result[result.length] = [arr0,arr1,arr2,arr3,arr4,arr5]
                            arr0 = [], arr1 = [], arr2 = [], arr3 = [], arr4 = [], arr5 = [];
                            // console.log ('\t==>\t['+arr0+']\t['+arr1+']\t['+arr2+']\n\n');
                        } else if (lookL[10] == '&#39;&#34;' && lookR[8] == ', u&#39;') {
                            tmpk = actpt.pop(); // close out old value ***
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            actpt.push(k0); // start new value
                            quoStatus = false;
                            // console.log ('Adjustment Made 2\t\t' + orig.substring(k0 - 20, k0 + 20));
                            if (x != -1 && y != -1) {
                                skey = pkey.substring(x+1,y);
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                if (myarrct == 0) {
                                    arr1[arr1.length] = skey; // add the main key
                                } else if (myarrct == 1) {
                                    arr2[arr2.length] = skey; // add the main key*
                                } else {
                                    console.log('Array Not Setup: ' + myarrct);
                                };
                            } else {
                                alert('Situation Not Setup 5122');
                            };
                            // console.log ('->\t['+arr0+']\t['+arr1+']\t['+arr2+']\n\n');
                            result[result.length] = [arr0,arr1,arr2,arr3,arr4,arr5]
                            arr0 = [], arr1 = [], arr2 = [], arr3 = [], arr4 = [], arr5 = [];
                            // console.log ('\t==>\t['+arr0+']\t['+arr1+']\t['+arr2+']\n\n');
                        } else if (quoStatus == true) {
                            // console.log ('..inside quotation');
                        } else if (lookL[7] == '&#34;]}' && lookR[8] == ', u&#34;') {
                            actpt.push(k0);
                            // console.log ('->\t['+arr0+']\t['+arr1+']\t['+arr2+']\n\n');
                            result[result.length] = [arr0,arr1,arr2,arr3,arr4,arr5]
                            arr0 = [], arr1 = [], arr2 = [], arr3 = [], arr4 = [], arr5 = [];
                        } else if (lookL[7] == '&#39;]}' && lookR[8] == ', u&#39;') {
                            actpt.push(k0);
                            // console.log ('->\t['+arr0+']\t['+arr1+']\t['+arr2+']\n\n');
                            result[result.length] = [arr0,arr1,arr2,arr3,arr4,arr5]
                            arr0 = [], arr1 = [], arr2 = [], arr3 = [], arr4 = [], arr5 = [];
                        } else if (lookL[7] == '&#34;]}' && lookR[8] == ', u&#39;') {
                            actpt.push(k0);
                            // console.log ('->\t['+arr0+']\t['+arr1+']\t['+arr2+']\n\n');
                            result[result.length] = [arr0,arr1,arr2,arr3,arr4,arr5]
                            arr0 = [], arr1 = [], arr2 = [], arr3 = [], arr4 = [], arr5 = [];
                        } else if (lookL[7] == '&#39;]}' && lookR[8] == ', u&#34;') {
                            actpt.push(k0);
                            // console.log ('->\t['+arr0+']\t['+arr1+']\t['+arr2+']\n\n');
                            result[result.length] = [arr0,arr1,arr2,arr3,arr4,arr5]
                            arr0 = [], arr1 = [], arr2 = [], arr3 = [], arr4 = [], arr5 = [];
                        } else if (lookL[7] == '&#34;]}' && lookR[7] == ', &#34;') {
                            actpt.push(k0);
                            // console.log ('->\t['+arr0+']\t['+arr1+']\t['+arr2+']\n\n');
                            result[result.length] = [arr0,arr1,arr2,arr3,arr4,arr5]
                            arr0 = [], arr1 = [], arr2 = [], arr3 = [], arr4 = [], arr5 = [];
                        } else if (lookL[7] == '&#39;]}' && lookR[7] == ', &#39;') {
                            actpt.push(k0);
                            // console.log ('->\t['+arr0+']\t['+arr1+']\t['+arr2+']\t['+arrg+']\n\n');
                            result[result.length] = [arr0,arr1,arr2,arr3,arr4,arr5]
                            arr0 = [], arr1 = [], arr2 = [], arr3 = [], arr4 = [], arr5 = [], arrg = [];
                        } else if (lookL[7] == '&#34;]}' && lookR[7] == ', &#39;') {
                            actpt.push(k0);
                            // console.log ('->\t['+arr0+']\t['+arr1+']\t['+arr2+']\n\n');
                            result[result.length] = [arr0,arr1,arr2,arr3,arr4,arr5]
                            arr0 = [], arr1 = [], arr2 = [], arr3 = [], arr4 = [], arr5 = [];
                        } else if (lookL[7] == '&#39;]}' && lookR[7] == ', &#34;') {
                            actpt.push(k0);
                            // console.log ('->\t['+arr0+']\t['+arr1+']\t['+arr2+']\n\n');
                            result[result.length] = [arr0,arr1,arr2,arr3,arr4,arr5]
                            arr0 = [], arr1 = [], arr2 = [], arr3 = [], arr4 = [], arr5 = [];
                        } else if (lookL[6] == '&#34;}' && lookR[8] == ', u&#34;') {
                            actpt.push(k0);
                            // console.log ('->\t['+arr0+']\t['+arr1+']\t['+arr2+']\n\n');
                            result[result.length] = [arr0,arr1,arr2,arr3,arr4,arr5]
                            arr0 = [], arr1 = [], arr2 = [], arr3 = [], arr4 = [], arr5 = [];
                        } else if (lookL[6] == '&#39;}' && lookR[8] == ', u&#39;') {
                            actpt.push(k0);
                            // console.log ('>>\t' + orig.substring(k0-20,k0+20));
                        } else if (lookL[6] == '&#34;}' && lookR[8] == ', u&#39;') {
                            actpt.push(k0);
                            // console.log ('->\t['+arr0+']\t['+arr1+']\t['+arr2+']\n\n');
                            result[result.length] = [arr0,arr1,arr2,arr3,arr4,arr5]
                            arr0 = [], arr1 = [], arr2 = [], arr3 = [], arr4 = [], arr5 = [];
                        } else if (lookL[6] == '&#39;}' && lookR[8] == ', u&#34;') {
                            actpt.push(k0);
                            // console.log ('>>\t' + orig.substring(k0-20,k0+20));
                        } else if (lookL[6] == '&#34;}' && lookR[7] == ', &#34;') {
                            actpt.push(k0);
                            // console.log ('->\t['+arr0+']\t['+arr1+']\t['+arr2+']\n\n');
                            result[result.length] = [arr0,arr1,arr2,arr3,arr4,arr5]
                            arr0 = [], arr1 = [], arr2 = [], arr3 = [], arr4 = [], arr5 = [];
                        } else if (lookL[6] == '&#39;}' && lookR[7] == ', &#39;') {
                            actpt.push(k0);
                            // console.log ('->\t['+arr0+']\t['+arr1+']\t['+arr2+']\n\n');
                            result[result.length] = [arr0,arr1,arr2,arr3,arr4,arr5]
                            arr0 = [], arr1 = [], arr2 = [], arr3 = [], arr4 = [], arr5 = [];
                        } else if (lookL[6] == '&#34;}' && lookR[7] == ', &#39;') {
                            actpt.push(k0);
                            // console.log ('->\t['+arr0+']\t['+arr1+']\t['+arr2+']\n\n');
                            result[result.length] = [arr0,arr1,arr2,arr3,arr4,arr5]
                            arr0 = [], arr1 = [], arr2 = [], arr3 = [], arr4 = [], arr5 = [];
                        } else if (lookL[6] == '&#39;}' && lookR[7] == ', &#34;') {
                            actpt.push(k0);
                            // console.log ('->\t['+arr0+']\t['+arr1+']\t['+arr2+']\n\n');
                            result[result.length] = [arr0,arr1,arr2,arr3,arr4,arr5]
                            arr0 = [], arr1 = [], arr2 = [], arr3 = [], arr4 = [], arr5 = [];
                        } else if (lookL[5] == '&#34;' && lookR[8] == ', u&#34;') {
                            tmpk = actpt.pop(); // close out old key
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            actpt.push(k0); // start new value
                            if (x != -1 && y != -1) {
                                skey = pkey.substring(x+1,y);
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                if (myarrct == 0) {
                                    arr1[arr1.length] = skey; // add the main key
                                } else if (myarrct == 1) {
                                    arr2[arr2.length] = skey; // add the main key*
                                } else {
                                    console.log('Array Not Setup: ' + myarrct);
                                };
                            } else {
                                alert('Situation Not Setup 5120');
                            };
                        } else if (lookL[5] == '&#39;' && lookR[8] == ', u&#39;') {
                            tmpk = actpt.pop(); // close out old key
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            actpt.push(k0); // start new value
                            if (x != -1 && y != -1) {
                                skey = pkey.substring(x+1,y);
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                if (myarrct == 0) {
                                    arr1[arr1.length] = skey; // add the main key
                                } else if (myarrct == 1) {
                                    arr2[arr2.length] = skey; // add the main key*
                                } else if (myarrct == 2) {
                                    arr3[arr3.length] = skey; // add the main key
                                } else if (myarrct == 3) {
                                    arr4[arr4.length] = skey; // add the main key
                                } else {
                                    console.log('Array Not Setup: ' + myarrct);
                                };
                            } else {
                                alert('Situation Not Setup 5121');
                            };
                            // console.log ('\t=>\t['+arr0+']\t['+arr1+']\t['+arr2+']\n\n');
                        } else if (lookL[5] == '&#34;' && lookR[8] == ', u&#39;') {
                            tmpk = actpt.pop(); // close out old key
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            actpt.push(k0); // start new value
                            // console.log ('Adjustment Made 2\t\t' + orig.substring(k0 - 20, k0 + 20));
                            if (x != -1 && y != -1) {
                                skey = pkey.substring(x+1,y);
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                if (myarrct == 0) {
                                    arr1[arr1.length] = skey; // add the main key
                                } else if (myarrct == 1) {
                                    arr2[arr2.length] = skey; // add the main key*
                                } else {
                                    console.log('Array Not Setup: ' + myarrct);
                                };
                            } else {
                                alert('Situation Not Setup 5122');
                            };
                            // console.log ('\t==>\t['+arr0+']\t['+arr1+']\t['+arr2+']\n\n');
                        } else if (lookL[5] == '&#39;' && lookR[8] == ', u&#34;') {
                            tmpk = actpt.pop(); // close out old key
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            actpt.push(k0); // start new value
                            if (x != -1 && y != -1) {
                                skey = pkey.substring(x+1,y);
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                if (myarrct == 0) {
                                    arr1[arr1.length] = skey; // add the main key
                                } else if (myarrct == 1) {
                                    arr2[arr2.length] = skey; // add the main key*
                                } else {
                                    console.log('Array Not Setup: ' + myarrct);
                                };
                            } else {
                                alert('Situation Not Setup 5123');
                            };
                            // console.log ('\t==>\t['+arr0+']\t['+arr1+']\t['+arr2+']\n\n');
                        } else if (lookL[5] == '&#34;' && lookR[7] == ', &#34;') {
                            tmpk = actpt.pop(); // close out old key
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            actpt.push(k0); // start new value
                            if (x != -1 && y != -1) {
                                skey = pkey.substring(x+1,y);
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                if (myarrct == 0) {
                                    arr0[arr0.length] = skey; // add the main key
                                } else if (myarrct == 1) {
                                    arr1[arr1.length] = skey; // add the main key*
                                } else {
                                    console.log('Array Not Setup: ' + myarrct);
                                };
                            } else {
                                alert('Situation Not Setup 5120');
                            };
                            // console.log ('\t==>\t['+arr0+']\t['+arr1+']\t['+arr2+']\n\n');
                        } else if (lookL[5] == '&#39;' && lookR[7] == ', &#39;') {
                            tmpk = actpt.pop(); // close out old key or value
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            actpt.push(k0); // start new value
                            if (x != -1 && y != -1) {
                                skey = pkey.substring(x+1,y);
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                // console.log('Square status: ' + sqrStatus + '\tKey position: ' + myarrct);
                                if (sqrStatus == false) {
                                    // old key.. just change arr0-1
                                    if (myarrct == 0) {
                                        arr1[arr1.length] = skey; // add the main key
                                    } else if (myarrct == 1) {
                                        arr2[arr2.length] = skey; // add the main key*
                                    } else {
                                        console.log('Array Not Setup: ' + myarrct);
                                    };
                                } else {
                                    // console.log ('inside of a bracket value, Music');
                                    arrg[arrg.length] = skey;
                                    // arr2[arr2.length] = skey;
                                };
                            } else {
                                alert('Situation Not Setup 5121');
                            };
                            // console.log ('\t==>\t['+arr0+']\t['+arr1+']\t['+arr2+']\t['+arrg+']\n\n');
                        } else if (lookL[5] == '&#34;' && lookR[7] == ', &#39;') {
                            tmpk = actpt.pop(); // close out old key
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            actpt.push(k0); // start new value
                            if (x != -1 && y != -1) {
                                skey = pkey.substring(x+1,y);
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                if (myarrct == 0) {
                                    arr0[arr0.length] = skey; // add the main key
                                } else if (myarrct == 1) {
                                    arr1[arr1.length] = skey; // add the main key*
                                } else {
                                    console.log('Array Not Setup: ' + myarrct);
                                };
                            } else {
                                alert('Situation Not Setup 5122');
                            };
                            // console.log ('\t==>\t['+arr0+']\t['+arr1+']\t['+arr2+']\n\n');
                        } else if (lookL[5] == '&#39;' && lookR[7] == ', &#34;') {
                            tmpk = actpt.pop(); // close out old key
                            pkey = orig.substring(tmpk, k0);
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            actpt.push(k0); // start new value
                            if (x != -1 && y != -1) {
                                skey = pkey.substring(x+1,y);
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                if (myarrct == 0) {
                                    arr0[arr0.length] = skey; // add the main key
                                } else if (myarrct == 1) {
                                    arr1[arr1.length] = skey; // add the main key*
                                } else {
                                    console.log('Array Not Setup: ' + myarrct);
                                };
                            } else {
                                alert('Situation Not Setup 5123');
                            };
                            // console.log ('\t==>\t['+arr0+']\t['+arr1+']\t['+arr2+']\n\n');
                        } else if (lookL[2] != '' && lookR[8] == ', u&#34;') {
                            tmpk = actpt.pop(); // close out old key or value
                            pkey = orig.substring(tmpk, k0);
                            nkey = orig.substring(tmpk + 1, k0); // get number value if so
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            actpt.push(k0); // start new value
                            nkey = nkey.trim();
                            chkn = isNumeric(nkey);
                            // console.log(chkn + ' \tNumber Value: ' + nkey);
                            if (x != -1 && y != -1) {
                                skey = pkey.substring(x+1,y);
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                console.log('Square status: ' + sqrStatus + '\tKey position: ' + myarrct);
                                if (sqrStatus == false) {
                                    // old key.. just change arr0-1
                                    if (myarrct == 0) {
                                        arr1[arr1.length] = skey; // add the main key
                                    } else if (myarrct == 1) {
                                        arr2[arr2.length] = skey; // add the main key*
                                    } else {
                                        console.log('Array Not Setup: ' + myarrct);
                                    };
                                } else {
                                    // console.log ('inside of a bracket value, Music');
                                    arrg[arrg.length] = skey;
                                    // arr2[arr2.length] = skey;
                                };
                            } else if (chkn == true) {
                                if (sqrStatus == false) {
                                    // old key.. just change arr0-1
                                    if (myarrct == 0) {
                                        arr1[arr1.length] = nkey; // add the main key
                                    } else if (myarrct == 1) {
                                        arr2[arr2.length] = nkey; // add the main key*
                                    } else {
                                        console.log('Array Not Setup: ' + myarrct);
                                    };
                                } else {
                                    // console.log ('inside of a bracket value, Music');
                                    arrg[arrg.length] = nkey;
                                    // arr2[arr2.length] = skey;
                                };
                            } else {
                                // alert('Situation Not Setup 5221');
                            };
                            // console.log ('\t==>\t['+arr0+']\t['+arr1+']\t['+arr2+']\t['+arrg+']\n\n');
                        } else if (lookL[2] != '' && lookR[8] == ', u&#39;') {
                            tmpk = actpt.pop(); // close out old key or value
                            pkey = orig.substring(tmpk, k0);
                            nkey = orig.substring(tmpk + 1, k0); // get number value if so
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            actpt.push(k0); // start new value
                            nkey = nkey.trim();
                            chkn = isNumeric(nkey);
                            // console.log(chkn + ' \tNumber Value: ' + nkey);
                            if (x != -1 && y != -1) {
                                skey = pkey.substring(x+1,y);
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                console.log('Square status: ' + sqrStatus + '\tKey position: ' + myarrct);
                                if (sqrStatus == false) {
                                    // old key.. just change arr0-1
                                    if (myarrct == 0) {
                                        arr1[arr1.length] = skey; // add the main key
                                    } else if (myarrct == 1) {
                                        arr2[arr2.length] = skey; // add the main key*
                                    } else if (myarrct == 2) {
                                        arr3[arr3.length] = skey; // add the main key
                                    } else {
                                        console.log('Array Not Setup: ' + myarrct);
                                    };
                                } else {
                                    // console.log ('inside of a bracket value, Music');
                                    arrg[arrg.length] = skey;
                                    // arr2[arr2.length] = skey;
                                };
                            } else if (chkn == true) {
                                if (sqrStatus == false) {
                                    // old key.. just change arr0-1
                                    if (myarrct == 0) {
                                        arr1[arr1.length] = nkey; // add the main key
                                    } else if (myarrct == 1) {
                                        arr2[arr2.length] = nkey; // add the main key*
                                    } else if (myarrct == 2) {
                                        arr3[arr3.length] = skey; // add the main key
                                    } else {
                                        console.log('Array Not Setup: ' + myarrct);
                                    };
                                } else {
                                    // console.log ('inside of a bracket value, Music');
                                    arrg[arrg.length] = nkey;
                                    // arr2[arr2.length] = skey;
                                };
                            } else {
                                // alert('Situation Not Setup 512421');
                            };
                            // console.log ('\t==>\t['+arr0+']\t['+arr1+']\t['+arr2+']\t['+arrg+']\n\n');
                        } else if (lookL[2] != '' && lookR[7] == ', &#34;') {
                            tmpk = actpt.pop(); // close out old key or value
                            pkey = orig.substring(tmpk, k0);
                            nkey = orig.substring(tmpk + 1, k0); // get number value if so
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            actpt.push(k0); // start new value
                            nkey = nkey.trim();
                            chkn = isNumeric(nkey);
                            // console.log(chkn + ' \tNumber Value: ' + nkey);
                            if (x != -1 && y != -1) {
                                skey = pkey.substring(x+1,y);
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                console.log('Square status: ' + sqrStatus + '\tKey position: ' + myarrct);
                                if (sqrStatus == false) {
                                    // old key.. just change arr0-1
                                    if (myarrct == 0) {
                                        arr1[arr1.length] = skey; // add the main key
                                    } else if (myarrct == 1) {
                                        arr2[arr2.length] = skey; // add the main key*
                                    } else {
                                        console.log('Array Not Setup: ' + myarrct);
                                    };
                                } else {
                                    // console.log ('inside of a bracket value, Music');
                                    arrg[arrg.length] = skey;
                                    // arr2[arr2.length] = skey;
                                };
                            } else if (chkn == true) {
                                if (sqrStatus == false) {
                                    // old key.. just change arr0-1
                                    if (myarrct == 0) {
                                        arr1[arr1.length] = nkey; // add the main key
                                    } else if (myarrct == 1) {
                                        arr2[arr2.length] = nkey; // add the main key*
                                    } else {
                                        console.log('Array Not Setup: ' + myarrct);
                                    };
                                } else {
                                    // console.log ('inside of a bracket value, Music');
                                    arrg[arrg.length] = nkey;
                                    // arr2[arr2.length] = skey;
                                };
                            } else {
                                alert('Situation Not Setup 51221');
                            };
                            // console.log ('\t==>\t['+arr0+']\t['+arr1+']\t['+arr2+']\t['+arrg+']\n\n');
                        } else if (lookL[2] != '' && lookR[7] == ', &#39;') {
                            tmpk = actpt.pop(); // close out old key or value
                            pkey = orig.substring(tmpk, k0);
                            nkey = orig.substring(tmpk + 1, k0); // get number value if so
                            x = pkey.indexOf(';');
                            y = pkey.lastIndexOf('&');
                            actpt.push(k0); // start new value
                            nkey = nkey.trim();
                            chkn = isNumeric(nkey);
                            // console.log(chkn + ' \tNumber Value: ' + nkey);
                            if (x != -1 && y != -1) {
                                skey = pkey.substring(x+1,y);
                                for (xp in charchgble) {
                                    if (skey.indexOf(charchgble[xp][0]) != -1) {
                                        skey = myRepl(charchgble[xp][0], charchgble[xp][1], skey);
                                    };
                                };
                                console.log('Square status: ' + sqrStatus + '\tKey position: ' + myarrct);
                                if (sqrStatus == false) {
                                    // old key.. just change arr0-1
                                    if (myarrct == 0) {
                                        arr1[arr1.length] = skey; // add the main key
                                    } else if (myarrct == 1) {
                                        arr2[arr2.length] = skey; // add the main key*
                                    } else {
                                        console.log('Array Not Setup: ' + myarrct);
                                    };
                                } else {
                                    // console.log ('inside of a bracket value, Music');
                                    arrg[arrg.length] = skey;
                                    // arr2[arr2.length] = skey;
                                };
                            } else if (chkn == true) {
                                if (sqrStatus == false) {
                                    // old key.. just change arr0-1
                                    if (myarrct == 0) {
                                        arr1[arr1.length] = nkey; // add the main key
                                    } else if (myarrct == 1) {
                                        arr2[arr2.length] = nkey; // add the main key*
                                    } else {
                                        console.log('Array Not Setup: ' + myarrct);
                                    };
                                } else {
                                    // console.log ('inside of a bracket value, Music');
                                    arrg[arrg.length] = nkey;
                                    // arr2[arr2.length] = skey;
                                };
                            } else {
                                alert('Situation Not Setup 5131');
                            };
                            // console.log ('\t==>\t['+arr0+']\t['+arr1+']\t['+arr2+']\t['+arrg+']\n\n');
                        } else {
                            // console.log(k0 + ' Checking on Comma\t\t' + orig.substring(k0 - 10, k0 + 10));
                            // alert(k0 + ' COMMA Response Not SetUp --> 11343');
                            // console.log ('\nThis COMMA Response Not SetUp.\n\t\t' + orig.substring(k0 - 10, k0 + 10) +
                            //     '\nLast: ' + lookL[9] + '\nNext: ' + lookR[9]);
                        };
                    } else if (lookL[0] == '[') {
                        // console.log ('\tOpen Square Bracket:');
                        var wrksect1 = 'Open Square Bracket';
                        // Open Bracket.. problem dealing with value ..between music/moive (use this to identify when to do it)
                        if (lookL[7] == '&#39;: ' && lookR[6] == '[&#39;') {
                            sqrStatus = true; // currently matter only with the comma issue
                            // console.log('\t\t\tChange Square Bracket status to TRUE');
                        // } else if (lookL[] == '' && lookR[] == '') {
                        //     // checking opening square
                        //     console.log('Checking on Open Square')
                        } else {
                            // console.log(k0 + ' Checking on Open Square') // if it does'nt fit previous might be part of data/value
                            // alert(k0 + ' OPEN SQUARE Response Not SetUp --> 11343');
                            // console.log ('OPEN SQUARE Response Not SetUp.\n\n' + orig.substring(k0 - 10, k0 + 10) +
                            //     '\n\nLast: ' + lookL[9] + '\nNext: ' + lookR[9]);
                        };
                    } else if (lookL[0] == ']') {
                        // console.log ('\tClose Square Bracket:');
                        var wrksect1 = 'Close Square Bracket';
                        // Open Bracket.. problem dealing with value ..between music/moive (use this to identify when to do it)
                        if (lookL[5] == '&#39;' && lookR[9] == ']}, &#39;') {
                            sqrStatus = false; // currently matter only with the comma issue
                            // console.log('\t\t\tChange Square Bracket status to FALSE');
                        } else if (lookL[5] == '&#39;' && lookR[3] == ']}}') {
                            // Music Modification --?
                            // alert('Music Modification');
                            sqrStatus = false;
                            // console.log('\t\t\tEnd of Dic... closing out do nothing\t' + actpt);
                        } else {
                            // console.log(k0 + ' Checking on Close Square'); // if it does'nt fit previous might be part of data/value
                            // alert(k0 + ' CLOSE SQUARE Response Not SetUp --> 12343');
                            // console.log ('CLOSE SQUARE Response Not SetUp.\n\n' + orig.substring(k0 - 10, k0 + 10) +
                            //     '\n\nLast: ' + lookL[9] + '\nNext: ' + lookR[9]);
                        };
                    } else {
                        // Not one of the main characters
                        console.log ('Should not be here, there was only six choices');
                    };
                };
            };
            if (orig[0] == '{' && orig.substr(orig.length - 2, orig.length) == ';}') {
                // console.log(orig.length + '\tChecking length reach in Dic: ' + x8)
                // console.log("\n\n\nThe Results:\n" + result + '\n\n' + result[0]+'\n\n'+result[1]);
            };
            return result;
        };
        function myDic(key,subkey,thedic) { // drepreciated
            // console.log ('...inside myDic'); // works with pyDic2
            // use <ALL> to get key values
            var dic, result;
            result = [];
            dic = pyDic2(thedic);
            if (dic == 'ERROR'){
                alert('An Error Occured... STOP PROGRAM!!! note: pyDic2');
                console.log('\n\t...In myDic\nERROR with this DATA:\n' + thedic);
                return 'Error';
            };
            // console.log ('PyDic2 Results: ' + dic + '\n' + typeof dic + '\t' + key);
            // console.log ('\nChecking...dic[0]\n' + dic[0]);
            // console.log ('\nChecking...dic[1]\n' + dic[1]);
            for (var h = 0; h < dic.length; h++) {
                // if (h > 10) {break;};
                // console.log('Looking --> ' + dic[h][0]);
                if (key == dic[h][0]) {
                    // alert('You found key: ' + dic[h][0] + '\n' + dic[h][1] + '\n' + dic[h][2]);
                    // console.log ('Found the Key: ' + typeof dic[h][0] + '\t' + dic[h][0]);
                    // console.log ('this Subkey: ' + typeof dic[h][1] + '\t' + dic[h][1]);
                    // console.log ('this Value: ' + typeof dic[h][2] + '\t' + dic[h][2] + '\n\n');
                    // dic[h][0] has the key, dic[h][1] has subkey, dic[h][2], has the values
                    if (subkey == '<ALL>') {
                        // return all the sub key
                        result = dic[h][1];
                    } else {
                        for (var j=0; j < dic[h][1].length; j++) {
                            if (subkey == dic[h][1][j]) {
                                // alert('You found subkey: ' + dic[h][1].length + ' -- ' + dic[h][1][0].length);
                                // console.log('Found Subkey: ' + dic[h][1][j]);
                                result = dic[h][2][j];
                                break;
                            };
                        };
                    };
                };
            };
            // console.log ('Answer: ' + result.length);
            if (result.length == 0){result = 'EMPTY';};
            return result;
        };
        function copyToClipboard(element) {
            // Work with (Chrome, Opera, Avant, IE)
            // Not Work (Safari)
            $("body").append("<input type='text' id='temp' style='position:absolute;opacity:0;'>");
            $("#temp").val($(element).text()).select();
            document.execCommand("copy");
            $("#temp").remove();

            $('#status-area').flash_message({
                text: 'Cipher Text Copied to Clipboard!',
                how: 'append'
            });
        };
        function copyForPersonal(containerid) {
            // online
            console.log('...inside copyForPersonal');
            // Create a new textarea element and give it id='myt'
            // let textarea = document.createElement('textarea');
            var tex = document.createElement('textarea');
            tex.id = 'myt';
            // Opitional step to make less noise on the page
            tex.style.height = 0;
            // Now append it to your page somewhere, I chose <body>
            document.body.appendChild(tex);
            // Give our textarea a value of whatever inside the div of id = containerid
            tex.value = document.getElementById(containerid).innerHTML;
            // Now copy whatever inside the textarea to clipboard
            var selector = document.querySelector('#myt');
            selector.select();
            document.execCommand("copy")
            // Remove the textarea
            document.body.removeChild(tex);
        };
        function vewAct(val1,val2,val3,val4,val5) {
            // console.log('\n\nHERE!! 2');
            var chkval = Number(val1);
            var vewstart = Number(val2);
            var vewend = Number(val3);
            var vewspec = val4;
            var vewdata = val5;
            // console.log('\n\nHERE!! 3\t' + val4);
            if (chkval >= vewstart && chkval <= vewend) {
                if (specvew == vewspec || specvew == 'A') {
                    console.log(val5);
                    // console.log(val5 + '\t' + val4);
                };
                // console.log(JSON.stringify(val4));
            };
            // console.log('\n\nHERE!! 4');
        };
        function conPath(val1){
            // converts conPath from new dic to a array
            var wrk = val1.split(' <~> ');
            // console.log('\n\nconPath\n' + wrk);
            result = [];
            for (var i=0; i < wrk.length; i++){
                if (wrk[i].length > 0) {
                    result.push(wrk[i]);
                };
            };
            // console.log(result);
            return result;
        };

        function speChk(val1,val2) { // depreciated
            // this can be setup to be more direct
            // val1 = list of letters to check      ring
            // val2 = [and next 4 letters           [the Ori
            // val1 = 'ring ';  // &#39;: [u&#39;
            // val2 = '[the Ori';
            // val1 = '{[u&#394;:';
            retval = false;
            chkv = val2;
            chkv = '&#39;: 4u';
            l = 0;
            for (var c=0; c < chkv.length; c++) {
                // console.log('\t\t==> ' + chkv[c]);
                if (val1.indexOf(chkv[c]) != -1) {
                    // located one value...
                    l++;
                };
                if (l > 4) {
                    console.log('\n\nApproved Entry:  ' + val1 + '\n\n');
                    retval = true;
                    break;
                };
            };
            return retval;
        };

        function passableChk(val1,val2,val3,val4){
            // check for acceptable characters, allowing dictionary to skip
            result = true;
            wrk = val1; // value working on
            lchar = val2; // left acceptable characters
            rchar = val3; // right acceptable characters
            chars = val4; // the entire line of characters
            tmp = '\n\nVal1: ' + wrk + '\nVal2: ' + val2;
            tmp += '\nVal3: ' + val3 + '\nVal4: ' + val4;
            tmp += '\n\n';
            // console.log(tmp)
            if (chars[25] == wrk) {
                chkL = 25;
                chkR = 25;
                for (var i = 0; i < 4; i++) {
                    chkL -= 1;
                    chkR += 1;
                    gLchar = chars[chkL];
                    gRchar = chars[chkR];
                    if (val2.indexOf(gLchar) == -1) {
                        // console.log(gLchar + '  is not within left group');
                        result = false;
                        break;
                    };
                    if (val3.indexOf(gRchar) == -1) {
                        // console.log(gRchar + '  is not within right group');
                        result = false;
                        break;
                    };
                };
            };
            return result;
        };
        function cleaNewDic1Val(val1,val2) {
            // Capture the main key of the dictionary
            var givalue = val1;
            var misc = val2;
            for (xp in charchgble) {
                if (givalue.indexOf(charchgble[xp][0]) != -1) {
                    tmmp = stringCount(givalue,charchgble[xp][0],true)
                    if (tmmp == 2 || charchgble[xp][0].length < 4) {
                        givalue = myRepl(charchgble[xp][0], charchgble[xp][1], givalue);
                    };
                };
            };
            for (xp in charchgble) {
                if (givalue.indexOf(charchgble[xp][0]) != -1) {
                    if (spOpt.indexOf(charchgble[xp][0]) != -1) {
                        givalue = myRepl(charchgble[xp][0], charchgble[xp][1], givalue);
                    };
                };
            };
            for (xp in charchgble) {
                if (givalue.indexOf(charchgble[xp][0]) != -1) {
                    givalue = myRepl(charchgble[xp][0], charchgble[xp][1], givalue);
                };
            };
            // if (['Songs','title','material','format','filename','artist','genre','date'].indexOf(givalue) == -1) {
            //     console.log('\n\n=> Value: ' + givalue + '\t[ ' + misc + ' ]');
            // };
            adjval = givalue.substring(1, givalue.length - 1);
            adjval = adjval.trim();
            tmpval = adjval.substring(0,2);
            if (tmpval == 'u"' || tmpval == "u'") {
                adjval = adjval.substring(2,adjval.length);
            };
            result = adjval;
            // if (['Songs','title','material','format','filename','artist','genre','date'].indexOf(result) == -1) {
            //     console.log('==> Value: ' + result + '\t[ ' + misc + ' ]');
            // };
            return result;
        };

        function nwDic(obj) {
            // note: Comma in data causes an error... fix later.
            // console.log (typeof(obj));
            // console.log (obj.substring(0,1000));
            var orig, result;
            var k0; // the character during loop
            var keyct = 0; // the key count
            var actpt = ['Start'] // store the location of the keys
            var lookL,lookR,viewpos; // the array for character range storage
            var crng = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17]; // check these range
            var thekeys = []; // store keys entries
            var lct1 = -1;
            var lct2 = -1;
            var lct3 = -1;
            var lct4 = -1;
            var lct5 = -1;
            var lct6 = -1;
            var lct7 = -1;
            var lct8 = -1;
            var lct9 = -1;
            var lct10 = -1;
            var xit;
            var x8 = 0;

            var spComKar1 = EngNum + EngUpc + EngLoc; // avoid detecting by quotation
            var spComKar2 = [', 0',', 1',', 2',', 3',', 4',', 5',', 6',', 7',', 8',', 9',', A',', B',', C',', D',', E',', F',', G',', H',', I',', J',', K',', L',', M',', N',', O',', P',', Q',', R',', S',', T',', U',', V',', W',', X',', Y',', Z',', a',', b',', c',', d',', e',', f',', g',', h',', i',', j',', k',', l',', m',', n',', o',', p',', q',', r',', s',', t',', u',', v',', w',', x',', y',', z']
            // check value [make sure its a string]
            if (typeof(obj) != 'string') {
                alert('Not the correct format');
                console.log ('\n\nIn pyDic2: format is not correct\n\n');
                return 'ERROR';
            };
            orig = obj;
            result = []; // start off as an array



            // read legitmate { for open and legitmate } for close.  this will determine the dic keys
            var x,y,z; // temp characters
            var keyCT = -1; // note: key count jump with very first open bracket
            var curKeys = ""; // note: had to store as string, pushing list would change with list
            var pthKeys = "";
            var keyvalue = "";
            var wrksect = "Start";
            var wrksqre = false;
            var showEx = false;
            var allkeys = "", allvalues = "";
            var cks, cke, csp; // check these area... cks - start, cke - end, csp - current position

            // cks = 0, cke = orig.length, csp = orig.length; //   ****************** TEST *********************
            // cks = 327300, cke = 327481, csp = 327481; // View Test Area 3745
            cks = 0, cke = 0, cso = 0, csp = 0;
            for (k0=0; k0 < orig.length; k0++) {
                lookL = [];
                lookR = [];
                var rmdr = k0 % 18; // the remainder
                for (var i=0; i < crng.length; i++) {
                    if (i==0) {
                        lookL[0] = orig[k0]; // actual character
                        lookR[0] = orig[k0];
                    } else {
                        lookL[i] = orig.substring(k0 - i, k0);
                        lookR[i] = orig.substring(k0, k0 + i);
                    };
                };
                viewpos = orig.substring(k0 - 25, k0 + 25); // view current position -5 and +5

                // if (k0 > cke){
                //     console.log('Force Break');
                //     break;
                // };
                var dirctsearch = 'DbLaNk';
                vewAct(k0, cso, csp, 0, '\n\n\n\nCurrent Position0: ' + k0 + '\t Character: ' + orig[k0] + '\t\t' + viewpos);
                if (viewpos.indexOf(dirctsearch) != -1) {
                    console.log('\n\n\nCurrent Positions1: ' + k0 + '\t Character: ' + orig[k0] + '\t\t' + viewpos);
                };

                srchString = "bLaNk";
                if (viewpos.indexOf(srchString) != -1) { // or str.search(srch)
                    console.log(k0 + '\t' + viewpos);
                };
                vewAct(k0, cks, cke, 0, '\n\n\n\nCurrent Position2: ' + k0 + '\t Character: ' + orig[k0] + '\t\t' + viewpos);
                if (['{',':','}',',','[',']'].indexOf(lookL[0]) != -1) {
                    // these are the factors of a dictionary
                    vewAct(k0, cks, cke, 1, '\tPosition: ' + k0 + '\tCommand Character Activated ==>  ' + orig[k0]);
                    if (lookL[0] == '{') {
                        sect = 'Open Bracket';
                        vewAct(k0, cks, cke, 2, '\nWork Section: ' + wrksect + '\n' + lookL[5] + '\t\tOpen Bracket View\t\t' + lookR[9]);
                        if (wrksect == 'Start') { // only time to start off with wrksect, all other lookL & lookR
                            if (lookL[3] == '' || lookL[4] == '') {
                                // First Bracket establishing the start of a dictionary
                                keyCT++; // must be done only when one of the choices are selected
                                actpt.push(k0);
                                vewAct(k0, cks, cke, 3, '\tKey Location with-in Original:\t' + actpt);
                                wrksect = 'opBrack';
                                // sayIt('First Bracket establishing the start of a dictionary');
                            } else {
                                tmpsay = 'OPEN BRACKET Response Not Setup';
                                vewAct(k0, cks, cke, 4, '\n\nKey Count: ' + keyCT + '\n(683) This' + tmpsay + '.\n\t\t'+orig.substring(k0-10, k0+10)+'\nLast: ' + lookL[9] + '\nNext: ' + lookR[9]);
                                if (k0 > cks && k0 < cke && tmpsay != '') {
                                    sayIt(tmpsay + ' Line ' + k0);
                                };
                            };
                        } else if ((['&#39;: ','&#34;: '].indexOf(lookL[7]) != -1 && ['{u&#39;','{u&#34;'].indexOf(lookR[7]) != -1) ||
                            ["': ",'": '].indexOf(lookL[3]) != -1 && ["{u'",'{u"'].indexOf(lookR[3]) != -1) {
                            // another open key
                            actpt.push(k0);

                            if (wrksect == '???'){
                                //
                            } else if (['coMma','coLon'].indexOf(wrksect) != -1) {
                                vewAct(k0, cks, cke, 7, 'Prepare for something');

                            } else {
                                tmpsay = 'OPEN BRACKET Response Not Setup';
                                vewAct(k0, cks, cke, 4, '\n\nKey Count: ' + keyCT + '\n(62183) This ' + tmpsay +'.\n\t\t'+orig.substring(k0-10, k0+10)+'\nLast: ' + lookL[9] + '\nNext: ' + lookR[9]);
                                if (k0 > cks && k0 < cke && tmpsay != '') {
                                    sayIt(tmpsay + ' Line ' + k0);
                                };
                            };

                            vewAct(k0, cks, cke, 5, 'Start Position of Creating Another KEY, make Action Points:\n' + actpt);
                            wrksect = 'opBrack';
                        } else if ((['&#39;: ','&#34;: '].indexOf(lookL[7]) != -1 && ['{&#39;','{&#34;'].indexOf(lookR[6]) != -1) ||
                            ["': ",'": '].indexOf(lookL[3]) != -1 && ["{'",'{"'].indexOf(lookR[2]) != -1) {
                            // another open key
                            actpt.push(k0);

                            if (wrksect == '???'){
                                //
                            } else if (['coMma','coLon'].indexOf(wrksect) != -1) {
                                vewAct(k0, cks, cke, 7, 'Prepare for something');
                            } else if (['clBrack'].indexOf(wrksect) != -1) {
                                vewAct(k0, cks, cke, 5, 'Start of a New Key');

                            } else {
                                tmpsay = 'OPEN BRACKET Response Not Setup';
                                vewAct(k0, cks, cke, 4, '\n\nKey Count: ' + keyCT + '\n(62183) This ' + tmpsay +'.\n\t\t'+orig.substring(k0-10, k0+10)+'\nLast: ' + lookL[9] + '\nNext: ' + lookR[9]);
                                if (k0 > cks && k0 < cke && tmpsay != '') {
                                    sayIt(tmpsay + ' Line ' + k0);
                                };
                            };

                            vewAct(k0, cks, cke, 5, 'Start Position of Creating Another KEY, make Action Points:\n' + actpt);
                            wrksect = 'opBrack';
                        } else {
                            tmpsay = "Open Bracket Instructions Not Setup";
                            console.log('\n\t\t\t*********************************************');
                            console.log('\t\t\t*\t' + tmpsay + '\t*');
                            console.log('\t\t\t*********************************************\n');
                            //} else if ([].indexOf(lookL[]) != -1 && [].indexOf(lookR[]) != -1) {
                            if (k0 > cks && k0 < cke && tmpsay != '') {
                                sayIt(tmpsay + ' Line ' + k0);
                            };
                        };
                    } else if (lookL[0] == ':') {
                        // colon: for seperating keys from its value
                        sect = 'Colon';
                        vewAct(k0, cks, cke, 6, '\nWork Section: ' + wrksect + '\n' + lookL[5] + '\t\tColon View\t\t' + lookR[9]);
                        if ((['&#39;', '&#34;'].indexOf(lookL[5]) != -1 && [': {u&#39;', ': {u&#34;'].indexOf(lookR[9]) != -1) ||
                            (["'",'"'].indexOf(lookL[1]) != -1 && [": {u'",': {u"'].indexOf(lookR[5]) != -1)) {
                            // colon is to close out something
                            if (wrksect == 'opBrack') {
                                // obtain the key
                                vewAct(k0, cks, cke, 9, 'actpt' + '\n' + orig.substring(actpt[actpt.length -1], k0));
                                keyvalue = orig.substring(actpt[actpt.length - 1], k0);
                                actpt.push(k0);

                                adjval = cleaNewDic1Val(keyvalue, k0);

                                // note: Automatically push the key and add count, plus else
                                thekeys.push(adjval); // place value in total key variable
                                pthKeys = curKeys; // path keys do not use the last location
                                curKeys += ' <~> ' + adjval // start the key string observer
                                chKeys = conPath(curKeys); // all except the last, however last is present. not using last though
                                keyCT++; // track the key count
                                tmpsay = "" // setup speech response
                                xit = false;
                                lct1 = -1;
                                lct2 = -1;
                                lct3 = -1;
                                lct4 = -1;
                                // --- end auto ---

                                vewAct(k0, cks, cke, 4, 'Key Count: ' + keyCT + '\tKey Value: ' + keyvalue + '\nActions Points: ' + 'actpt');
                                vewAct(k0, cks, cke, 8, '\n\no\t' + adjval + '\to\n\n');

                                if (keyCT == 1) {
                                    result.push( adjval, [] ); // create area for entire data
                                    // result.push( '<PATH>', [adjval]);// create path location for first round, is self evident, nope no path for 1st round
                                } else if (keyCT == 2) {
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[lct1] == chKeys[0]) {
                                            // console.log('Found it: ' + result[a]);
                                            lct1++;
                                            result[lct1].push( adjval, [] );
                                            break;
                                        };
                                    };
                                    // result[lct1].push( '<PATH>', [pthKeys] )
                                } else if (keyCT == 3) {
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1');
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found it: ' + result[lct1][b]);
                                                    lct2++;
                                                    result[lct1][lct2].push( adjval, [] );
                                                    xit = true;
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };
                                    // result[lct1][lct2].push( '<PATH>', [pthKeys] )
                                } else if (keyCT == 4) {
                                    tmpsay = 'Section ' + keyCT + ' Not Setup';
                                    vewAct(k0, cks, cke, 13, '<<' + tmpsay + '>>');
                                } else if (keyCT == 5) {
                                    tmpsay = 'Section ' + keyCT + ' Not Setup';
                                    vewAct(k0, cks, cke, 13, '<<' + tmpsay + '>>');
                                };
                                if (k0 > cks && k0 < cke && tmpsay != '') {
                                    sayIt(tmpsay + ' Line ' + k0);
                                };
                                vewAct(k0, cks, cke, 14, '\n\nooooooo>\tKeys: ' + conPath(curKeys) + '\n' + 'result' + '\n\n');
                                vewAct(k0, cks, cke, 11, result);
                                wrksect = 'coLon';
                            } else if (wrksect == 'coMma') {
                                // obtain the key
                                vewAct(k0, cks, cke, 9, 'actpt' + '\n' + orig.substring(actpt[actpt.length -1], k0));
                                keyvalue = orig.substring(actpt[actpt.length - 1], k0);
                                actpt.push(k0);

                                adjval = cleaNewDic1Val(keyvalue, k0);

                                // note: Automatically push the key and add count, plus else
                                thekeys.push(adjval); // place value in total key variable
                                pthKeys = curKeys; // path keys do not use the last location
                                curKeys += ' <~> ' + adjval // start the key string observer
                                chKeys = conPath(curKeys); // all except the last, however last is present. not using last though
                                keyCT++; // track the key count
                                tmpsay = "" // setup speech response
                                xit = false;
                                lct1 = -1;
                                lct2 = -1;
                                lct3 = -1;
                                lct4 = -1;
                                // --- end auto ---

                                vewAct(k0, cks, cke, 4, 'Key Count: ' + keyCT + '\tKey Value: ' + keyvalue + '\nActions Points: ' + 'actpt');
                                vewAct(k0, cks, cke, 8, '\n\no\t' + adjval + '\to\n\n');
                                // for (var i = 0; i < 88; i++) {
                                //     console.log('Are You being used at ALL ' + i); // 863
                                // };

                                if (keyCT == 1) {
                                    // first line key
                                    // make adjustment here because starting with first level key (try reset)
                                    // vewAct(k0, cks, cke, 18, '<<Section 2 Working ON #863 >>\t' + chKeys);
                                    result.push( adjval, [] );
                                } else if (keyCT == 1) {
                                    tmpsay = 'Section ' + keyCT + ' Not Setup';
                                } else if (keyCT == 2) {
                                    // tmpsay = 'Section ' + keyCT + ' Not Setup';
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found it: ' + result[a]);
                                            lct1++;
                                            result[lct1].push( adjval, [] );
                                            break;
                                        };
                                    };
                                } else if (keyCT == 3) {
                                    // tmpsay = 'Section ' + keyCT + ' Not Setup';
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1');
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found it: ' + result[lct1][b]);
                                                    lct2++;
                                                    result[lct1][lct2].push( adjval, [] );
                                                    xit = true;
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };

                                } else if (keyCT == 4) {
                                    tmpsay = 'Section ' + keyCT + ' Not Setup';
                                } else if (keyCT == 5) {
                                    tmpsay = 'Section ' + keyCT + ' Not Setup';
                                } else {
                                    tmpsay = 'Section NONE Not Setup';
                                };
                                if (k0 > cks && k0 < cke && tmpsay != '') {
                                    sayIt(tmpsay + ' Line ' + k0);
                                    vewAct(k0, cks, cke, 13, '<<' + tmpsay + '>>');
                                };
                                vewAct(k0,cks, cke, 10, '\n\nAdjustments: qqqqqqq>\tKeys: ' + conPath(curKeys) + '\n' + 'result' + '\n\n');
                                vewAct(k0, cks, cke, 11, result);
                                wrksect = 'coLon';

                            } else {
                                console.log ('\n\nKey Count: ' + keyCT + '\n(41602) This COLON Response from ' + wrksect +' Not SetUp.\n\t\t'+orig.substring(k0-10, k0+10)+'\nLast: ' + lookL[9] + '\nNext: ' + lookR[9]);
                            };
                        } else if ((['&#39;', '&#34;'].indexOf(lookL[5]) != -1 && [': {&#39;',': {&#34;'].indexOf(lookR[8]) != -1) ||
                            (["'",'"'].indexOf(lookL[1]) != -1 && [": {'",': {"'].indexOf(lookR[4]) != -1)) {
                            // colon is to close out something
                            if (wrksect == 'opBrack') {
                                // obtain the key
                                vewAct(k0, cks, cke, 9, 'actpt' + '\n' + orig.substring(actpt[actpt.length -1], k0));
                                keyvalue = orig.substring(actpt[actpt.length - 1], k0);
                                actpt.push(k0);

                                adjval = cleaNewDic1Val(keyvalue, k0);

                                // note: Automatically push the key and add count, plus else
                                thekeys.push(adjval); // place value in total key variable
                                pthKeys = curKeys; // path keys do not use the last location
                                curKeys += ' <~> ' + adjval // start the key string observer
                                chKeys = conPath(curKeys); // all except the last, however last is present. not using last though
                                keyCT++; // track the key count
                                tmpsay = "" // setup speech response
                                xit = false;
                                lct1 = -1;
                                lct2 = -1;
                                lct3 = -1;
                                lct4 = -1;
                                // --- end auto ---

                                vewAct(k0, cks, cke, 4, 'Key Count: ' + keyCT + '\tKey Value: ' + keyvalue + '\nActions Points: ' + 'actpt');
                                vewAct(k0, cks, cke, 8, '\n\no\t' + adjval + '\to\n\n');

                                if (keyCT == 1) {
                                    result.push( adjval, [] ); // create area for entire data
                                    // result.push( '<PATH>', [adjval]);// create path location for first round, is self evident, nope no path for 1st round
                                } else if (keyCT == 2) {
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found it: ' + result[a]);
                                            lct1++;
                                            result[lct1].push( adjval, [] );
                                            break;
                                        };
                                    };
                                    // result[lct1].push( '<PATH>', [pthKeys] )
                                } else if (keyCT == 3) {
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1');
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found it: ' + result[lct1][b]);
                                                    lct2++;
                                                    result[lct1][lct2].push( adjval, [] );
                                                    xit = true;
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };
                                    // result[lct1][lct2].push( '<PATH>', [pthKeys] )
                                } else if (keyCT == 4) {
                                    tmpsay = 'Section ' + keyCT + ' Not Setup';
                                    vewAct(k0, cks, cke, 13, '<<' + tmpsay + '>>');
                                } else if (keyCT == 5) {
                                    tmpsay = 'Section ' + keyCT + ' Not Setup';
                                    vewAct(k0, cks, cke, 13, '<<' + tmpsay + '>>');
                                };
                                if (k0 > cks && k0 < cke && tmpsay != '') {
                                    sayIt(tmpsay + ' Line ' + k0);
                                };
                                vewAct(k0, cks, cke, 14, '\n\nooooooo>\tKeys: ' + conPath(curKeys) + '\n' + 'result' + '\n\n');
                                vewAct(k0, cks, cke, 11, result);
                                wrksect = 'coLon';
                            } else if (wrksect == 'clBrack') {
                                // obtain the key
                                vewAct(k0, cks, cke, 9, 'actpt' + '\n' + orig.substring(actpt[actpt.length -1], k0));
                                keyvalue = orig.substring(actpt[actpt.length - 1], k0);
                                vewAct(k0, cks, cke, 16, 'check 1: ' + keyvalue);
                                actpt.push(k0);

                                adjval = cleaNewDic1Val(keyvalue, k0);

                                // note: Automatically push the key and add count, plus else
                                thekeys.push(adjval); // place value in total key variable
                                pthKeys = curKeys; // path keys do not use the last location
                                curKeys += ' <~> ' + adjval // start the key string observer
                                chKeys = conPath(curKeys); // all except the last, however last is present. not using last though
                                keyCT++; // track the key count
                                tmpsay = "" // setup speech response
                                xit = false;
                                lct1 = -1;
                                lct2 = -1;
                                lct3 = -1;
                                lct4 = -1;
                                // --- end auto ---

                                vewAct(k0, cks, cke, 4, 'Key Count: ' + keyCT + '\tKey Value: ' + keyvalue + '\nActions Points: ' + 'actpt');
                                vewAct(k0, cks, cke, 8, '\n\no\t' + adjval + '\to\n\n');

                                if (keyCT == 1) {
                                    result.push( adjval, [] ); // create area for entire data
                                    // result.push( '<PATH>', [adjval]);// create path location for first round, is self evident, nope no path for 1st round
                                } else if (keyCT == 2) {
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found it: ' + result[a]);
                                            lct1++;
                                            result[lct1].push( adjval, [] );
                                            break;
                                        };
                                    };
                                    // result[lct1].push( '<PATH>', [pthKeys] )
                                } else if (keyCT == 3) {
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1');
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found it: ' + result[lct1][b]);
                                                    lct2++;
                                                    result[lct1][lct2].push( adjval, [] );
                                                    xit = true;
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };
                                    // result[lct1][lct2].push( '<PATH>', [pthKeys] )
                                } else if (keyCT == 4) {
                                    // tmpsay = 'Section ' + keyCT + ' Not Setup';
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1');
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found it: ' + result[lct1][b]);
                                                    lct2++;
                                                    for (c in result[lct1][lct2]) {
                                                        lct3++;
                                                        // console.log(result[lct1][lct2][c]);
                                                        if (result[lct1][lct2][c] == chKeys[2]) {
                                                            // console.log('Found it: ' + result[lct1][lct2][c]);
                                                            lct3++;
                                                            result[lct1][lct2][lct3].push( adjval, [] );
                                                            xit = true;
                                                            break;
                                                        };
                                                    };
                                                };
                                                if (xit == true) {
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };
                                } else if (keyCT == 5) {
                                    // tmpsay = 'Section ' + keyCT + ' Not Setup';
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1');
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found it: ' + result[lct1][b]);
                                                    lct2++;
                                                    for (c in result[lct1][lct2]) {
                                                        lct3++;
                                                        // console.log(result[lct1][lct2][c]);
                                                        if (result[lct1][lct2][c] == chKeys[2]) {
                                                            // console.log('Found it: ' + result[lct1][lct2][c]);
                                                            lct3++;
                                                            for (d in result[lct1][lct2][lct3]) {
                                                                lct4++;
                                                                if (result[lct1][lct2][lct3][d] == chKeys[3]) {
                                                                    lct4++;
                                                                    result[lct1][lct2][lct3][lct4].push( adjval, [] );
                                                                    xit = true;
                                                                    break;
                                                                };
                                                            };
                                                        };
                                                        if (xit == true) {
                                                            break;
                                                        };
                                                    };
                                                };
                                                if (xit == true) {
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };
                                } else if (keyCT == 6) {
                                    tmpsay = 'Section ' + keyCT + ' Not Setup';
                                } else if (keyCT == 7) {
                                    tmpsay = 'Section ' + keyCT + ' Not Setup';
                                };
                                if (k0 > cks && k0 < cke && tmpsay != '') {
                                    sayIt(tmpsay + ' Line ' + k0);
                                    vewAct(k0, cks, cke, 13, '<<' + tmpsay + '>>');
                                };
                                vewAct(k0, cks, cke, 14, '\n\noCoOoPoYo>\tKeys: ' + conPath(curKeys) + '\n' + 'result' + '\n\n');
                                vewAct(k0, cks, cke, 11, result);
                                wrksect = 'clBrack';
                            } else if (wrksect == 'coMma') {
                                // obtain the key
                                vewAct(k0, cks, cke, 9, 'actpt' + '\n' + orig.substring(actpt[actpt.length -1], k0));
                                keyvalue = orig.substring(actpt[actpt.length - 1], k0);
                                vewAct(k0, cks, cke, 16, 'check 1: ' + keyvalue);
                                actpt.push(k0);

                                adjval = cleaNewDic1Val(keyvalue, k0);

                                // note: Automatically push the key and add count, plus else
                                thekeys.push(adjval); // place value in total key variable
                                pthKeys = curKeys; // path keys do not use the last location
                                curKeys += ' <~> ' + adjval // start the key string observer
                                chKeys = conPath(curKeys); // all except the last, however last is present. not using last though
                                keyCT++; // track the key count
                                tmpsay = "" // setup speech response
                                xit = false;
                                lct1 = -1;
                                lct2 = -1;
                                lct3 = -1;
                                lct4 = -1;
                                // --- end auto ---

                                vewAct(k0, cks, cke, 4, 'Key Count: ' + keyCT + '\tKey Value: ' + keyvalue + '\nActions Points: ' + 'actpt');
                                vewAct(k0, cks, cke, 8, '\n\no\t' + adjval + '\to\n\n');
                                // for (var i = 0; i < 88; i++) {
                                //     console.log('Are You being used at ALL ' + i); // 863
                                // };

                                if (keyCT == 1) {
                                    // first line key
                                    // make adjustment here because starting with first level key (try reset)
                                    // vewAct(k0, cks, cke, 18, '<<Section 2 Working ON #863 >>\t' + chKeys);
                                    result.push( adjval, [] );
                                } else if (keyCT == 1) {
                                    tmpsay = 'Section ' + keyCT + ' Not Setup';
                                } else if (keyCT == 2) {
                                    tmpsay = 'Section ' + keyCT + ' Not Setup';
                                } else if (keyCT == 3) {
                                    tmpsay = 'Working ON,  Section ' + keyCT + ' Not Setup';
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1');
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found it: ' + result[lct1][b]);
                                                    lct2++;
                                                    result[lct1][lct2].push( adjval, [] );
                                                    xit = true;
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };
                                } else if (keyCT == 4) {
                                    tmpsay = 'Section ' + keyCT + ' Not Setup';
                                } else if (keyCT == 5) {
                                    tmpsay = 'Section ' + keyCT + ' Not Setup';
                                } else {
                                    tmpsay = 'Section NONE Not Setup';
                                };
                                if (k0 > cks && k0 < cke && tmpsay != '') {
                                    sayIt(tmpsay + ' Line ' + k0);
                                    vewAct(k0, cks, cke, 13, '<<' + tmpsay + '>>');
                                };
                                vewAct(k0,cks, cke, 10, '\n\nAdjustments: qqCqOqPqYqq>\tKeys: ' + conPath(curKeys) + '\n' + 'result' + '\n\n');
                                vewAct(k0, cks, cke, 11, result);
                                wrksect = 'coLon';

                            } else {
                                console.log ('\n\nKey Count: ' + keyCT + '\n(416802) This COLON Response from ' + wrksect +' Not SetUp.\n\t\t'+orig.substring(k0-10, k0+10)+'\nLast: ' + lookL[9] + '\nNext: ' + lookR[9]);
                            };
                        } else if ((['&#39;', '&#34;'].indexOf(lookL[5]) != -1 && [': u&#39;',': u&#34;'].indexOf(lookR[8]) != -1) || (["'",'"'].indexOf(lookL[1]) != -1 && [": u'",': u"'].indexOf(lookR[4]) != -1)) {
                            // colon is to close out something
                            if (wrksect == 'opBrack') {
                                // obtain the key
                                vewAct(k0, cks, cke, 9, 'actpt' + '\n' + orig.substring(actpt[actpt.length -1], k0));
                                keyvalue = orig.substring(actpt[actpt.length - 1], k0);
                                actpt.push(k0);

                                adjval = cleaNewDic1Val(keyvalue, k0);

                                // note: Automatically push the key and add count, plus else
                                thekeys.push(adjval); // place value in total key variable
                                pthKeys = curKeys; // path keys do not use the last location
                                curKeys += ' <~> ' + adjval // start the key string observer
                                chKeys = conPath(curKeys); // all except the last, however last is present. not using last though
                                keyCT++; // track the key count
                                tmpsay = "" // setup speech response
                                xit = false;
                                lct1 = -1;
                                lct2 = -1;
                                lct3 = -1;
                                lct4 = -1;
                                // --- end auto ---

                                vewAct(k0, cks, cke, 4, 'Key Count: ' + keyCT + '\tKey Value: ' + keyvalue + '\nActions Points: ' + 'actpt');
                                vewAct(k0, cks, cke, 8, '\n\no\t' + adjval + '\to\n\n');

                                if (keyCT == 1) {
                                    tmpsay = 'Working on Section ' +  keyCT + ' Not Setup';
                                    result.push( adjval, [] );
                                } else if (keyCT == 2) {
                                    tmpsay = "";
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1: ' + result[a]);
                                            lct1++;
                                            result[lct1].push( adjval, [] );
                                        };
                                    };
                                    // vewAct(k0, cks, cke, 18, '<<Section 2 Work ON #881 >>');

                                } else if (keyCT == 3) {
                                    // tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                    // tmpsay = 'Section ' +  keyCT + ' Working On';
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1: ' + result[a]);
                                            lct1++;
                                            for (b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found it: ' + result[lct1][b]);
                                                    lct2++;
                                                    result[lct1][lct2].push( adjval, [] );
                                                    xit = true;
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };
                                } else if (keyCT == 4) {
                                    tmpsay = "";
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1: ' + result[a]);
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found 2');
                                                    lct2++;
                                                    for (c in result[lct1][lct2]) {
                                                        lct3++;
                                                        if (result[lct1][lct2][c] == chKeys[2]) {
                                                            // console.log('Found it: ' + result[lct1][lct2][c]);
                                                            lct3++;
                                                            result[lct1][lct2][lct3].push( adjval, [] );
                                                            xit = true;
                                                            break;
                                                        };
                                                    };
                                                };
                                                if (xit == true) {
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };
                                    // result[lct1][lct2][lct3].push( '<PATH>', [pthKeys] ) // check 1
                                    // result[lct1][lct2][lct3].push( '<PATH>', [] ) // check 1
                                } else if (keyCT == 5) {
                                    tmpsay = "";
                                } else {
                                    tmpsay = 'Section NONE Not Setup';
                                };
                                //} else if ([].indexOf(lookL[]) != -1 && [].indexOf(lookR[]) != -1) {
                                if (k0 > cks && k0 < cke && tmpsay != '') {
                                    sayIt(tmpsay + ' Line ' + k0);
                                    vewAct(k0, cks, cke, 17, '<<' + tmpsay +'>>');
                                };


                                vewAct(k0, cks, cke, 14, '\n\n+++++++>\tKeys: ' + conPath(curKeys) + '\n' + 'result' + '\n\n');
                                vewAct(k0, cks, cke, 11, result);
                                wrksect = 'coLon';
                            } else if (wrksect == 'coMma') {
                                // obtain the key
                                vewAct(k0, cks, cke, 9, 'actpt' + '\n' + orig.substring(actpt[actpt.length -1], k0));
                                keyvalue = orig.substring(actpt[actpt.length - 1], k0);
                                actpt.push(k0);

                                adjval = cleaNewDic1Val(keyvalue, k0);

                                // note: Automatically push the key and add count, plus else
                                thekeys.push(adjval); // place value in total key variable
                                pthKeys = curKeys; // path keys do not use the last location
                                curKeys += ' <~> ' + adjval // start the key string observer
                                chKeys = conPath(curKeys); // all except the last, however last is present. not using last though
                                keyCT++; // track the key count
                                tmpsay = "" // setup speech response
                                xit = false;
                                lct1 = -1;
                                lct2 = -1;
                                lct3 = -1;
                                lct4 = -1;
                                // --- end auto ---

                                vewAct(k0, cks, cke, 4, 'Key Count: ' + keyCT + '\tKey Value: ' + keyvalue + '\nActions Points: ' + 'actpt');
                                vewAct(k0, cks, cke, 8, '\n\no\t' + adjval + '\to\n\n');

                                if (keyCT == 1) { // note: keyCT 1&2 are the same
                                    tmpsay = "";
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1 ' + result[a]);
                                            lct1++;
                                            result[lct1].push( adjval, [] );
                                            break;
                                        };
                                    };
                                } else if (keyCT == 2) {
                                    tmpsay = "";
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1: ' + result[a]);
                                            lct1++;
                                            result[lct1].push( adjval, []);
                                            break;
                                        };
                                    };
                                    // #918
                                } else if (keyCT == 3) {
                                    // tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1');
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found 2');
                                                    lct2++;
                                                    result[lct1][lct2].push ( adjval, [] );
                                                    xit = true;
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };
                                } else if (keyCT == 4) {
                                    // tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                    tmpsay = "";
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1: ' + result[a]);
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found 2');
                                                    lct2++;
                                                    for (c in result[lct1][lct2]) {
                                                        lct3++;
                                                        if (result[lct1][lct2][c] == chKeys[2]) {
                                                            // console.log('Found it: ' + result[lct1][lct2][c]);
                                                            lct3++;
                                                            result[lct1][lct2][lct3].push( adjval, [] );
                                                            xit = true;
                                                            break;
                                                        };
                                                    };
                                                };
                                                if (xit == true) {
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };
                                    // note: remove last key add new one... mainly for visual right now.
                                    // console.log('Current Keys: ' + curKeys);
                                    tmp1 = curKeys.lastIndexOf(" <~> ");
                                    tmp2 = curKeys.substring(0, tmp1 + 5);
                                    tmp3 = tmp2 + adjval;
                                    // console.log('New Keys: ' + tmp3);
                                    curKeys = tmp3;
                                } else if (keyCT == 5) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                } else {
                                    tmpsay = 'Section NONE Not Setup';
                                };
                                //} else if ([].indexOf(lookL[]) != -1 && [].indexOf(lookR[]) != -1) {
                                if (k0 > cks && k0 < cke && tmpsay != '') {
                                    sayIt(tmpsay + ' Line ' + k0);
                                    vewAct(k0, cks, cke, 17, '<<' + tmpsay +'>>');
                                };


                                vewAct(k0,cks, cke, 10, '\n\nAdjustments: .......>\tKeys: ' + conPath(curKeys) + '\n' + 'result' + '\n\n');
                                vewAct(k0, cks, cke, 11, result);
                                wrksect = 'coLon';
                            } else if (wrksect == 'coLon') {
                                // setup colon process.
                                // obtain the key
                                vewAct(k0, cks, cke, 9, 'actpt' + '\n' + orig.substring(actpt[actpt.length -1], k0));
                                keyvalue = orig.substring(actpt[actpt.length - 1], k0);
                                actpt.push(k0);

                                adjval = cleaNewDic1Val(keyvalue, k0);

                                // note: Automatically push the key and add count, plus else
                                thekeys.push(adjval); // place value in total key variable
                                pthKeys = curKeys; // path keys do not use the last location
                                curKeys += ' <~> ' + adjval // start the key string observer
                                chKeys = conPath(curKeys); // all except the last, however last is present. not using last though
                                keyCT++; // track the key count
                                tmpsay = "" // setup speech response
                                xit = false;
                                lct1 = -1;
                                lct2 = -1;
                                lct3 = -1;
                                lct4 = -1;
                                // --- end auto ---

                                vewAct(k0, cks, cke, 4, 'Key Count: ' + keyCT + '\tKey Value: ' + keyvalue + '\nActions Points: ' + 'actpt');
                                vewAct(k0, cks, cke, 8, '\n\no\t' + adjval + '\to\n\n');

                                if (keyCT == 1) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                    vewAct(k0, cks, cke, 17, '<<' + tmpsay +'>>');
                                } else if (keyCT == 2) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                    vewAct(k0, cks, cke, 17, '<<' + tmpsay +'>>');
                                } else if (keyCT == 3) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                    vewAct(k0, cks, cke, 17, '<<' + tmpsay +'>>');
                                } else if (keyCT == 4) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                    vewAct(k0, cks, cke, 17, '<<' + tmpsay +'>>');
                                } else if (keyCT == 5) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                    vewAct(k0, cks, cke, 17, '<<' + tmpsay +'>>');
                                } else if (keyCT == 6) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                    vewAct(k0, cks, cke, 17, '<<' + tmpsay +'>>');
                                } else if (keyCT == 7) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                    vewAct(k0, cks, cke, 17, '<<' + tmpsay +'>>');
                                } else {
                                    tmpsay = 'Section NONE Not Setup';
                                    vewAct(k0, cks, cke, 18, '<<Section NONE Not Setup>>');
                                };
                                //} else if ([].indexOf(lookL[]) != -1 && [].indexOf(lookR[]) != -1) {
                                if (k0 > cks && k0 < cke && tmpsay != '') {
                                    sayIt(tmpsay + ' Line ' + k0);
                                };

                            } else {
                                tmpsay = 'COLON Response from ' + wrksect +' Not SetUp';
                                console.log ('\n\nKey Count: ' + keyCT + '\n(416203) This ' + tmpsay + '.\n\t\t'+orig.substring(k0-10, k0+10)+'\nLast: ' + lookL[9] + '\nNext: ' + lookR[9]);
                                if (k0 > cks && k0 < cke && tmpsay != '') {
                                    sayIt(tmpsay + ' Line ' + k0);
                                };
                            };
                        } else if ((['&#39;', '&#34;'].indexOf(lookL[5]) != -1 && [': &#39;',': &#34;'].indexOf(lookR[7]) != -1) || (["'",'"'].indexOf(lookL[1]) != -1 && [": '",': "'].indexOf(lookR[3]) != -1)) {
                            // colon is to close out something
                            if (wrksect == 'opBrack') {
                                // obtain the key
                                vewAct(k0, cks, cke, 9, 'actpt' + '\n' + orig.substring(actpt[actpt.length -1], k0));
                                keyvalue = orig.substring(actpt[actpt.length - 1], k0);
                                actpt.push(k0);

                                adjval = cleaNewDic1Val(keyvalue, k0);

                                // note: Automatically push the key and add count, plus else
                                thekeys.push(adjval); // place value in total key variable
                                pthKeys = curKeys; // path keys do not use the last location
                                curKeys += ' <~> ' + adjval // start the key string observer
                                chKeys = conPath(curKeys); // all except the last, however last is present. not using last though
                                keyCT++; // track the key count
                                tmpsay = "" // setup speech response
                                xit = false;
                                lct1 = -1;
                                lct2 = -1;
                                lct3 = -1;
                                lct4 = -1;
                                // --- end auto ---

                                vewAct(k0, cks, cke, 4, 'Key Count: ' + keyCT + '\tKey Value: ' + keyvalue + '\nActions Points: ' + 'actpt');
                                vewAct(k0, cks, cke, 8, '\n\no\t' + adjval + '\to\n\n');

                                if (keyCT == 1) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                } else if (keyCT == 2) {
                                    tmpsay = "";
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1: ' + result[a]);
                                            lct1++;
                                            result[lct1].push( adjval, []);
                                        };
                                    };
                                    // vewAct(k0, cks, cke, 18, '<<Section 2 Work ON #881 >>');

                                } else if (keyCT == 3) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                } else if (keyCT == 4) {
                                    tmpsay = "";
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1: ' + result[a]);
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found 2');
                                                    lct2++;
                                                    for (c in result[lct1][lct2]) {
                                                        lct3++;
                                                        if (result[lct1][lct2][c] == chKeys[2]) {
                                                            // console.log('Found it: ' + result[lct1][lct2][c]);
                                                            lct3++;
                                                            result[lct1][lct2][lct3].push( adjval, [] );
                                                            xit = true;
                                                            break;
                                                        };
                                                    };
                                                };
                                                if (xit == true) {
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };
                                    // result[lct1][lct2][lct3].push( '<PATH>', [pthKeys] ) // check 2
                                } else if (keyCT == 5) {
                                    tmpsay = "";
                                } else {
                                    tmpsay = 'Section NONE Not Setup';
                                };
                                //} else if ([].indexOf(lookL[]) != -1 && [].indexOf(lookR[]) != -1) {
                                if (k0 > cks && k0 < cke && tmpsay != '') {
                                    sayIt(tmpsay + ' Line ' + k0);
                                    vewAct(k0, cks, cke, 17, '<<' + tmpsay +'>>');
                                };


                                vewAct(k0, cks, cke, 14, '\n\n+++++++>\tKeys: ' + conPath(curKeys) + '\n' + 'result' + '\n\n');
                                vewAct(k0, cks, cke, 11, result);
                                wrksect = 'coLon';
                            } else if (wrksect == 'coMma') {
                                // obtain the key
                                vewAct(k0, cks, cke, 9, 'actpt' + '\n' + orig.substring(actpt[actpt.length -1], k0));
                                keyvalue = orig.substring(actpt[actpt.length - 1], k0);
                                actpt.push(k0);

                                adjval = cleaNewDic1Val(keyvalue, k0);

                                // note: Automatically push the key and add count, plus else
                                thekeys.push(adjval); // place value in total key variable
                                pthKeys = curKeys; // path keys do not use the last location
                                curKeys += ' <~> ' + adjval // start the key string observer
                                chKeys = conPath(curKeys); // all except the last, however last is present. not using last though
                                keyCT++; // track the key count
                                tmpsay = "" // setup speech response
                                xit = false;
                                lct1 = -1;
                                lct2 = -1;
                                lct3 = -1;
                                lct4 = -1;
                                // --- end auto ---

                                vewAct(k0, cks, cke, 4, 'Key Count: ' + keyCT + '\tKey Value: ' + keyvalue + '\nActions Points: ' + 'actpt');
                                vewAct(k0, cks, cke, 8, '\n\no\t' + adjval + '\to\n\n');

                                if (keyCT == 1) { // note: keyCT 1&2 are the same
                                    tmpsay = "";
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1 ' + result[a]);
                                            lct1++;
                                            result[lct1].push( adjval, [] );
                                            break;
                                        };
                                    };
                                } else if (keyCT == 2) {
                                    tmpsay = "";
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1: ' + result[a]);
                                            lct1++;
                                            result[lct1].push( adjval, []);
                                            break;
                                        };
                                    };
                                    // #918
                                } else if (keyCT == 3) {
                                    // tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1');
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found 2');
                                                    lct2++;
                                                    result[lct1][lct2].push ( adjval, [] );
                                                    xit = true;
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    }
                                } else if (keyCT == 4) {
                                    tmpsay = "";
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1');
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found 2');
                                                    lct2++;
                                                    for (c in result[lct1][lct2]) {
                                                        lct3++;
                                                        if (result[lct1][lct2][c] == chKeys[2]) {
                                                            // console.log('Found it: ' + result[lct1][lct2][c]);
                                                            lct3++;
                                                            result[lct1][lct2][lct3].push( adjval, [] );
                                                            xit = true;
                                                            break;
                                                        };
                                                    };
                                                };
                                                if (xit == true) {
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };
                                    // note: remove last key add new one... mainly for visual right now.
                                    // console.log('Current Keys: ' + curKeys);
                                    tmp1 = curKeys.lastIndexOf(" <~> ");
                                    tmp2 = curKeys.substring(0, tmp1 + 5);
                                    tmp3 = tmp2 + adjval;
                                    // console.log('New Keys: ' + tmp3);
                                    curKeys = tmp3;
                                } else if (keyCT == 5) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                } else {
                                    tmpsay = 'Section NONE Not Setup';
                                };
                                //} else if ([].indexOf(lookL[]) != -1 && [].indexOf(lookR[]) != -1) {
                                if (k0 > cks && k0 < cke && tmpsay != '') {
                                    sayIt(tmpsay + ' Line ' + k0);
                                    vewAct(k0, cks, cke, 17, '<<' + tmpsay +'>>');
                                };


                                vewAct(k0,cks, cke, 10, '\n\nAdjustments: .......>\tKeys: ' + conPath(curKeys) + '\n' + 'result' + '\n\n');
                                vewAct(k0, cks, cke, 11, result);
                                wrksect = 'coLon';
                            } else if (wrksect == 'coLon') {
                                // setup colon process.
                                // obtain the key
                                vewAct(k0, cks, cke, 9, 'actpt' + '\n' + orig.substring(actpt[actpt.length -1], k0));
                                keyvalue = orig.substring(actpt[actpt.length - 1], k0);
                                actpt.push(k0);

                                adjval = cleaNewDic1Val(keyvalue, k0);

                                // note: Automatically push the key and add count, plus else
                                thekeys.push(adjval); // place value in total key variable
                                pthKeys = curKeys; // path keys do not use the last location
                                curKeys += ' <~> ' + adjval // start the key string observer
                                chKeys = conPath(curKeys); // all except the last, however last is present. not using last though
                                keyCT++; // track the key count
                                tmpsay = "" // setup speech response
                                xit = false;
                                lct1 = -1;
                                lct2 = -1;
                                lct3 = -1;
                                lct4 = -1;
                                // --- end auto ---

                                vewAct(k0, cks, cke, 4, 'Key Count: ' + keyCT + '\tKey Value: ' + keyvalue + '\nActions Points: ' + 'actpt');
                                vewAct(k0, cks, cke, 8, '\n\no\t' + adjval + '\to\n\n');

                                if (keyCT == 1) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                    vewAct(k0, cks, cke, 17, '<<' + tmpsay +'>>');
                                } else if (keyCT == 2) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                    vewAct(k0, cks, cke, 17, '<<' + tmpsay +'>>');
                                } else if (keyCT == 3) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                    vewAct(k0, cks, cke, 17, '<<' + tmpsay +'>>');
                                } else if (keyCT == 4) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                    vewAct(k0, cks, cke, 17, '<<' + tmpsay +'>>');
                                } else if (keyCT == 5) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                    vewAct(k0, cks, cke, 17, '<<' + tmpsay +'>>');
                                } else if (keyCT == 6) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                    vewAct(k0, cks, cke, 17, '<<' + tmpsay +'>>');
                                } else if (keyCT == 7) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                    vewAct(k0, cks, cke, 17, '<<' + tmpsay +'>>');
                                } else {
                                    tmpsay = 'Section NONE Not Setup';
                                    vewAct(k0, cks, cke, 18, '<<Section NONE Not Setup>>');
                                };
                                //} else if ([].indexOf(lookL[]) != -1 && [].indexOf(lookR[]) != -1) {
                                if (k0 > cks && k0 < cke && tmpsay != '') {
                                    sayIt(tmpsay + ' Line ' + k0);
                                };

                            } else {
                                tmpsay = 'COLON Response from ' + wrksect +' Not SetUp';
                                console.log ('\n\nKey Count: ' + keyCT + '\n(41623) This ' + tmpsay + '.\n\t\t'+orig.substring(k0-10, k0+10)+'\nLast: ' + lookL[9] + '\nNext: ' + lookR[9]);
                                if (k0 > cks && k0 < cke && tmpsay != '') {
                                    sayIt(tmpsay + ' Line ' + k0);
                                };
                            };
                        } else if ((['&#39;','&#34;'].indexOf(lookL[5]) != -1 && [': [u&#39;',': [u&#34;'].indexOf(lookR[9]) != -1) || (["'",'"'].indexOf(lookL[1]) != -1 && [": [u'",': [u"'].indexOf(lookR[5]) != -1)) {
                            // colon: store key, prepare to square bracket
                            if (wrksect == 'clBrack') {
                                console.log('Currently EMPTY');
                            } else if (['opBrack','coMma'].indexOf(wrksect) != -1) { // 5467
                                // obtain the key
                                vewAct(k0, cks, cke, 9, 'actpt' + '\n' + orig.substring(actpt[actpt.length -1], k0));
                                keyvalue = orig.substring(actpt[actpt.length - 1], k0);
                                actpt.push(k0);

                                adjval = cleaNewDic1Val(keyvalue, k0);

                                // note: Automatically push the key and add count, plus else
                                thekeys.push(adjval); // place value in total key variable
                                pthKeys = curKeys; // path keys do not use the last location
                                curKeys += ' <~> ' + adjval // start the key string observer
                                chKeys = conPath(curKeys); // all except the last, however last is present. not using last though
                                keyCT++; // track the key count
                                tmpsay = "" // setup speech response
                                xit = false;
                                lct1 = -1;
                                lct2 = -1;
                                lct3 = -1;
                                lct4 = -1;
                                lct5 = -1;
                                lct6 = -1;
                                lct7 = -1;
                                // --- end auto ---

                                vewAct(k0, cks, cke, 4, 'Key Count: ' + keyCT + '\tKey Value: ' + keyvalue + '\nActions Points: ' + 'actpt');
                                vewAct(k0, cks, cke, 8, '\n\no\t' + adjval + '\to\n\n');

                                if (keyCT == 1) {
                                    // tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                    tmpsay = "";
                                    result.push( adjval, [] );
                                } else if (keyCT == 2) {
                                    tmpsay = "";
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1: ' + result[a]);
                                            lct1++;
                                            result[lct1].push( adjval, [] );
                                        };
                                    };

                                } else if (keyCT == 3) {
                                    // tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                    tmpsay = "";
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a])
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1: ' + result[a]);
                                            lct1++;
                                            for (b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found 2');
                                                    lct2++;
                                                    result[lct1][lct2].push( adjval, [] );
                                                    xit = true;
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };
                                } else if (keyCT == 4) {
                                    tmpsay = "";
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1: ' + result[a]);
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found 2');
                                                    lct2++;
                                                    for (c in result[lct1][lct2]) {
                                                        lct3++;
                                                        if (result[lct1][lct2][c] == chKeys[2]) {
                                                            // console.log('Found it: ' + result[lct1][lct2][c]);
                                                            lct3++;
                                                            result[lct1][lct2][lct3].push( adjval, [] );
                                                            xit = true;
                                                            break;
                                                        };
                                                    };
                                                };
                                                if (xit == true) {
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };
                                    // result[lct1][lct2][lct3].push( '<PATH>', [pthKeys] ) // check 3
                                } else if (keyCT == 5) {
                                    // tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1: ' + result[a]);
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found 2');
                                                    lct2++;
                                                    for (c in result[lct1][lct2]) {
                                                        lct3++;
                                                        if (result[lct1][lct2][c] == chKeys[2]) {
                                                            // console.log('Found it: ' + result[lct1][lct2][c]);
                                                            lct3++;
                                                            for (d in result[lct1][lct2][lct3]) {
                                                                lct4++;
                                                                if (result[lct1][lct2][lct3][d] == chKeys[3]) {
                                                                    // console.log('Found it: ' + result[lct1][lct2][lct3][d]);
                                                                    lct4++;
                                                                    result[lct1][lct2][lct3][lct4].push( adjval, [] );
                                                                    xit = true;
                                                                    break;
                                                                };
                                                            };
                                                        };
                                                        if (xit == true) {
                                                            break;
                                                        };
                                                    };
                                                };
                                                if (xit == true) {
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };
                                } else if (keyCT == 6) {
                                    // tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1: ' + result[a]);
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found 2');
                                                    lct2++;
                                                    for (c in result[lct1][lct2]) {
                                                        lct3++;
                                                        if (result[lct1][lct2][c] == chKeys[2]) {
                                                            // console.log('Found it: ' + result[lct1][lct2][c]);
                                                            lct3++;
                                                            for (d in result[lct1][lct2][lct3]) {
                                                                lct4++;
                                                                if (result[lct1][lct2][lct3][d] == chKeys[3]) {
                                                                    // console.log('Found it: ' + result[lct1][lct2][lct3][d]);
                                                                    lct4++;
                                                                    for (e in result[lct1][lct2][lct3][lct4]) {
                                                                        lct5++;
                                                                        if (result[lct1][lct2][lct3][lct4][e] == chKeys[4]) {
                                                                            lct5++;
                                                                            result[lct1][lct2][lct3][lct4][lct5].push( adjval, [] );
                                                                            xit = true;
                                                                            break;
                                                                        };
                                                                    };
                                                                };
                                                                if (xit == true) {
                                                                    break;
                                                                };
                                                            };
                                                        };
                                                        if (xit == true) {
                                                            break;
                                                        };
                                                    };
                                                };
                                                if (xit == true) {
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };
                                } else if (keyCT == 7) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                } else if (keyCT == 8) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                } else if (keyCT == 9) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                } else {
                                    tmpsay = 'Section NONE Not Setup';
                                };
                                //} else if ([].indexOf(lookL[]) != -1 && [].indexOf(lookR[]) != -1) {
                                if (k0 > cks && k0 < cke && tmpsay != '') {
                                    sayIt(tmpsay + ' Line ' + k0);
                                    vewAct(k0, cks, cke, 17, '<<' + tmpsay +'>>');
                                };


                                vewAct(k0,cks, cke, 10, '\n\nAdjustments: ++C+O+P+Y++>\tKeys: ' + conPath(curKeys) + '\n' + 'result' + '\n\n');
                                vewAct(k0, cks, cke, 11, result);
                                wrksect = 'coLon';
                            } else {
                                tmpsay = 'COLON Response from ' + wrksect +' Not SetUp';
                                console.log ('\n\nKey Count: ' + keyCT + '\n(985162) This ' + tmpsay + '.\n\t\t'+orig.substring(k0-10, k0+10)+'\nLast: ' + lookL[9] + '\nNext: ' + lookR[9]);
                                if (k0 > cks && k0 < cke && tmpsay != '') {
                                    sayIt(tmpsay + ' Line ' + k0);
                                };
                            };
                        } else if ((['&#39;','&#34;'].indexOf(lookL[5]) != -1 && [': [&#39;',': [&#34;'].indexOf(lookR[8]) != -1) || (["'",'"'].indexOf(lookL[1]) != -1 && [": ['",': ["'].indexOf(lookR[4]) != -1)) {
                            // colon: store key, prepare to square bracket
                            if (wrksect == 'clBrack') {
                                console.log('Currently EMPTY');
                            } else if (wrksect == 'opBrack') {
                                // obtain the key
                                vewAct(k0, cks, cke, 9, 'actpt' + '\n' + orig.substring(actpt[actpt.length -1], k0));
                                keyvalue = orig.substring(actpt[actpt.length - 1], k0);
                                actpt.push(k0);

                                adjval = cleaNewDic1Val(keyvalue, k0);

                                // note: Automatically push the key and add count, plus else
                                thekeys.push(adjval); // place value in total key variable
                                pthKeys = curKeys; // path keys do not use the last location
                                curKeys += ' <~> ' + adjval // start the key string observer
                                chKeys = conPath(curKeys); // all except the last, however last is present. not using last though
                                keyCT++; // track the key count
                                tmpsay = "" // setup speech response
                                xit = false;
                                lct1 = -1;
                                lct2 = -1;
                                lct3 = -1;
                                lct4 = -1;
                                // --- end auto ---

                                vewAct(k0, cks, cke, 4, 'Key Count: ' + keyCT + '\tKey Value: ' + keyvalue + '\nActions Points: ' + 'actpt');
                                vewAct(k0, cks, cke, 8, '\n\no\t' + adjval + '\to\n\n');

                                if (keyCT == 1) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                } else if (keyCT == 2) {
                                    tmpsay = "";
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1: ' + result[a]);
                                            lct1++;
                                            result[lct1].push( adjval, []);
                                        };
                                    };

                                } else if (keyCT == 3) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                } else if (keyCT == 4) {
                                    tmpsay = "";
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1: ' + result[a]);
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found 2');
                                                    lct2++;
                                                    for (c in result[lct1][lct2]) {
                                                        lct3++;
                                                        if (result[lct1][lct2][c] == chKeys[2]) {
                                                            // console.log('Found it: ' + result[lct1][lct2][c]);
                                                            lct3++;
                                                            result[lct1][lct2][lct3].push( adjval, [] );
                                                            xit = true;
                                                            break;
                                                        };
                                                    };
                                                };
                                                if (xit == true) {
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };
                                    // result[lct1][lct2][lct3].push( '<PATH>', [pthKeys] ) // check 4
                                } else if (keyCT == 5) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                } else {
                                    tmpsay = 'Section NONE Not Setup';
                                };
                                //} else if ([].indexOf(lookL[]) != -1 && [].indexOf(lookR[]) != -1) {
                                if (k0 > cks && k0 < cke && tmpsay != '') {
                                    sayIt(tmpsay + ' Line ' + k0);
                                    vewAct(k0, cks, cke, 17, '<<' + tmpsay +'>>');
                                };


                                vewAct(k0,cks, cke, 10, '\n\nAdjustments: ++C+O+P+Y++>\tKeys: ' + conPath(curKeys) + '\n' + 'result' + '\n\n');
                                vewAct(k0, cks, cke, 11, result);
                                wrksect = 'coLon';
                            } else {
                                tmpsay = 'COLON Response from ' + wrksect +' Not SetUp';
                                console.log ('\n\nKey Count: ' + keyCT + '\n(935162) This ' + tmpsay + '.\n\t\t'+orig.substring(k0-10, k0+10)+'\nLast: ' + lookL[9] + '\nNext: ' + lookR[9]);
                                if (k0 > cks && k0 < cke && tmpsay != '') {
                                    sayIt(tmpsay + ' Line ' + k0);
                                };
                            };
                        } else if ((['&#39;','&#34;'].indexOf(lookL[5]) != -1 && [': 0',': 1',': 2',': 3',': 4',': 5',': 6',': 7',': 8',': 9'].indexOf(lookR[3]) != -1) || (["'",'"'].indexOf(lookL[1]) != -1 && [': 0',': 1',': 2',': 3',': 4',': 5',': 6',': 7',': 8',': 9'].indexOf(lookR[3]) != -1)) {
                            // if (wrksect == 'opBrack') {
                            if (['opBrack','coMma'].indexOf(wrksect) != -1) {
                                // obtain the key
                                vewAct(k0, cks, cke, 9, 'actpt' + '\n' + orig.substring(actpt[actpt.length -1], k0));
                                keyvalue = orig.substring(actpt[actpt.length - 1], k0);
                                actpt.push(k0);

                                adjval = cleaNewDic1Val(keyvalue, k0);

                                // note: Automatically push the key and add count, plus else
                                thekeys.push(adjval); // place value in total key variable
                                pthKeys = curKeys; // path keys do not use the last location
                                curKeys += ' <~> ' + adjval // start the key string observer
                                chKeys = conPath(curKeys); // all except the last, however last is present. not using last though
                                keyCT++; // track the key count
                                tmpsay = "" // setup speech response
                                xit = false;
                                lct1 = -1;
                                lct2 = -1;
                                lct3 = -1;
                                lct4 = -1;
                                // --- end auto ---

                                vewAct(k0, cks, cke, 4, 'Key Count: ' + keyCT + '\tKey Value: ' + keyvalue + '\nActions Points: ' + 'actpt');
                                vewAct(k0, cks, cke, 8, '\n\no\t' + adjval + '\to\n\n');


                                if (keyCT == 1) {
                                    result.push( adjval, [] ); // create area for entire data
                                    // result.push( '<PATH>', [adjval]);// create path location for first round, is self evident, nope no path for 1st round
                                } else if (keyCT == 2) {
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found it: ' + result[a]);
                                            lct1++;
                                            result[lct1].push( adjval, [] );
                                            break;
                                        };
                                    };
                                    // result[lct1].push( '<PATH>', [pthKeys] )
                                } else if (keyCT == 3) {
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1');
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found it: ' + result[lct1][b]);
                                                    lct2++;
                                                    result[lct1][lct2].push( adjval, [] );
                                                    xit = true;
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };
                                    // result[lct1][lct2].push( '<PATH>', [pthKeys] )
                                } else if (keyCT == 4) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                    vewAct(k0, cks, cke, 17, '<<' + tmpsay +'>>');
                                } else if (keyCT == 5) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                    vewAct(k0, cks, cke, 17, '<<' + tmpsay +'>>');
                                };
                                //} else if ([].indexOf(lookL[]) != -1 && [].indexOf(lookR[]) != -1) {
                                if (k0 > cks && k0 < cke && tmpsay != '') {
                                    sayIt(tmpsay + ' Line ' + k0);
                                };
                                vewAct(k0, cks, cke, 14, '\n\ncccccccc>\tKeys: ' + conPath(curKeys) + '\n' + 'result' + '\n\n');
                                vewAct(k0, cks, cke, 11, result);
                                wrksect = 'coLon';
                            } else {
                                console.log ('\n\nKey Count: ' + keyCT + '\n(448602) This COLON Response from ' + wrksect +' Not SetUp.\n\t\t'+orig.substring(k0-10, k0+10)+'\nLast: ' + lookL[9] + '\nNext: ' + lookR[9]);
                            };
                        } else {
                            tmpsay = "Colon Instructions Not Setup";
                            console.log('\n\t\t\t*********************************************');
                            console.log('\t\t\t*\t' + tmpsay + '\t*');
                            console.log('\t\t\t*********************************************\n');
                            //} else if ([].indexOf(lookL[]) != -1 && [].indexOf(lookR[]) != -1) {
                            if (k0 > cks && k0 < cke && tmpsay != '') {
                                sayIt(tmpsay + ' Line ' + k0);
                            };
                        };
                    } else if (lookL[0] == ',') {
                        // Seperate value to value, value to key ...don't know which one for future
                        // Comma section not working with ( cleanNewDicVal(keyvalue)  )
                                vewAct(k0, cks, cke, 15, '\n\n\t\t\t\tThis is the area   ZERO\n\n');
                        sect = 'Comma';
                        vewAct(k0, cks, cke, 6, '\nWork Section: ' + wrksect + '\n' + lookL[5] + '\t\tComma View\t\t' + lookR[8]);
                        if ((['&#39;]}','&#34;]}'].indexOf(lookL[7]) != -1 && [', &#39;',', &#34;'].indexOf(lookR[7]) != -1) || (["']}",'"]}'].indexOf(lookL[3]) != -1 && [", '",', "'].indexOf(lookR[3]) != -1)) {
                            if (wrksect == 'clBrack') {
                                // no need to obtain value from part of a python list, value area obtain
                                vewAct(k0, cks, cke, 9, 'actpt' + '\n' + orig.substring(actpt[actpt.length -1], k0));
                                valvalue = orig.substring(actpt[actpt.length - 1], k0);
                                actpt.push(k0);

                                adjval = cleaNewDic1Val(valvalue, k0);

                                vewAct(k0, cks, cke, 4, 'Key Count: ' + keyCT + '\tVALUE Value: ' + valvalue + '\nActions Points: ' + 'actpt');
                                vewAct(k0, cks, cke, 8, '\n\no\t' + adjval + '\to\n\n');


                                // note: Automatically remove the key and subtract count, plus else
                                // thekeys.push(adjval); // place value in total key variable
                                // pthKeys = curKeys; // path keys do not use the last location
                                // curKeys += ' <~> ' + adjval // start the key string observer
                                chKeys = conPath(curKeys); // all except the last, however last is present. not using last though
                                xit = false;
                                lct1 = -1;
                                lct2 = -1;
                                lct3 = -1;
                                lct4 = -1;
                                // --- end auto ---

                                // Auto Removal... note keyCT will deduct.
                                tmp1 = curKeys.lastIndexOf(" <~> "); // visual purpose
                                tmp2 = curKeys.substring(0, tmp1);
                                curKeys = tmp2;
                                keyCT--; // track the key count
                                // --- auto end

                                vewAct(k0, cks, cke, 14, '\n\nAdjustments: ==C=O=P=Y===>\tKeys: ' + conPath(curKeys) + '\n' + 'result' + '\n\n');
                                vewAct(k0, cks, cke, 11, result);
                                wrksect = 'coMma';
                            } else {
                                tmpsay = 'COMMA Response from ' + wrksect +' Not SetUp';
                                console.log ('\n\nKey Count: ' + keyCT + '\n(47823) This ' + tmpsay + '.\n\t\t'+orig.substring(k0-10, k0+10)+'\nLast: ' + lookL[9] + '\nNext: ' + lookR[9]);
                                if (k0 > cks && k0 < cke && tmpsay != '') {
                                    sayIt(tmpsay + ' Line ' + k0);
                                };
                            };
                        } else if (['&#39;', '&#34;'].indexOf(lookL[5]) != -1 && [', u&#39;', ', u&#34;'].indexOf(lookR[8]) != -1) {
                            //
                            if (wrksect == 'coLon') {
                                // obtain the value and remove visual key... even next trans is a key, retrieve key by its value
                                vewAct(k0, cks, cke, 9, 'actpt' + '\n' + orig.substring(actpt[actpt.length -1], k0));
                                valvalue = orig.substring(actpt[actpt.length - 1], k0);
                                actpt.push(k0);

                                adjval = cleaNewDic1Val(valvalue, k0);

                                vewAct(k0, cks, cke, 4, 'Key Count: ' + keyCT + '\tVALUE Value: ' + valvalue + '\nActions Points: ' + 'actpt');
                                vewAct(k0, cks, cke, 8, '\n\no\t' + adjval + '\to\n\n');


                                // note: Automatically remove the key and subtract count, plus else
                                // thekeys.push(adjval); // place value in total key variable
                                // pthKeys = curKeys; // path keys do not use the last location
                                // curKeys += ' <~> ' + adjval // start the key string observer
                                chKeys = conPath(curKeys); // all except the last, however last is present. not using last though
                                xit = false;
                                lct1 = -1;
                                lct2 = -1;
                                lct3 = -1;
                                lct4 = -1;
                                // --- end auto ---


                                if (keyCT == 1) { // 1&2 same
                                    tmpsay = "";
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1');
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found 2: ' + result[lct1][b]);
                                                    lct2++;
                                                    result[lct1][lct2].push(adjval);
                                                    xit = true;
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };
                                } else if (keyCT == 2) {
                                    tmpsay = "";
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1: ' + result[a]);
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found 2: ' + result[lct1][b]);
                                                    lct2++;
                                                    result[lct1][lct2].push(adjval);
                                                    xit = true;
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };
                                    // vewAct(k0, cks, cke, 18, '<<Section 2 Working ON #652, #899 >>\t' + chKeys);
                                } else if (keyCT == 3) {
                                    // tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1');
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found 2');
                                                    lct2++;
                                                    for (c in result[lct1][lct2]) {
                                                        lct3++;
                                                        if (result[lct1][lct2][c] == chKeys[2]) {
                                                            // console.log('Found 3');
                                                            lct3++;
                                                            result[lct1][lct2][lct3].push( adjval );
                                                            xit = true;
                                                            break;
                                                        };
                                                    };
                                                };
                                                if (xit == true) {
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };
                                } else if (keyCT == 4) {
                                    // tmpsay = 'Section ' +  keyCT + ' Working On '; // 215
                                    // tmpsay = "";
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1');
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found 2');
                                                    lct2++;
                                                    for (c in result[lct1][lct2]) {
                                                        lct3++;
                                                        if (result[lct1][lct2][c] == chKeys[2]) {
                                                            // console.log('Found 3');
                                                            lct3++;
                                                            for (d in result[lct1][lct2][lct3]) {
                                                                lct4++;
                                                                // cant get key loc #2 all will go there
                                                                // console.log('\n\nShow Me the Keys: ' + curKeys);
                                                                if (result[lct1][lct2][lct3][d] == chKeys[3]) {
                                                                    // console.log('Found it: ' + result[lct1][lct2][lct3][d]);
                                                                    // console.log('last key: ' + thekeys[thekeys.length - 1]);
                                                                    lct4++;
                                                                    result[lct1][lct2][lct3][lct4].push( adjval ); // adding just the value
                                                                    xit = true;
                                                                    break;
                                                                };
                                                            };
                                                        };
                                                        if (xit == true) {
                                                            break;
                                                        };
                                                    };
                                                };
                                                // goes after every if except the initial
                                                if (xit == true) {
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };
                                } else {
                                    tmpsay = 'Section NONE Not Setup';
                                };
                                //} else if ([].indexOf(lookL[]) != -1 && [].indexOf(lookR[]) != -1) {
                                if (k0 > cks && k0 < cke && tmpsay != '') {
                                    sayIt(tmpsay + ' Line ' + k0);
                                    vewAct(k0, cks, cke, 17, '<<' + tmpsay +'>>');
                                };

                                // Auto Removal... note keyCT will deduct.
                                tmp1 = curKeys.lastIndexOf(" <~> "); // visual purpose
                                tmp2 = curKeys.substring(0, tmp1);
                                curKeys = tmp2;
                                keyCT--; // track the key count
                                // --- auto end

                                vewAct(k0,cks, cke, 10, '\n\nAdjustments: ========>\tKeys: ' + conPath(curKeys) + '\n' + 'result' + '\n\n');
                                vewAct(k0, cks, cke, 11, result);
                                wrksect = 'coMma';
                            } else if (wrksect == 'opSquare') {
                                // no need to obtain value from part of a python list, value area obtain???
                                vewAct(k0, cks, cke, 9, 'actpt' + '\n' + orig.substring(actpt[actpt.length -1], k0));
                                valvalue = orig.substring(actpt[actpt.length - 1], k0);
                                actpt.push(k0);

                                adjval = cleaNewDic1Val(valvalue, k0);

                                vewAct(k0, cks, cke, 4, 'Key Count: ' + keyCT + '\tVALUE Value: ' + valvalue + '\nActions Points: ' + 'actpt');
                                vewAct(k0, cks, cke, 8, '\n\no\t' + adjval + '\to\n\n');


                                // note: Automatically remove the key and subtract count, plus else
                                // thekeys.push(adjval); // place value in total key variable
                                // pthKeys = curKeys; // path keys do not use the last location
                                // curKeys += ' <~> ' + adjval // start the key string observer
                                chKeys = conPath(curKeys); // all except the last, however last is present. not using last though
                                xit = false;
                                lct1 = -1;
                                lct2 = -1;
                                lct3 = -1;
                                lct4 = -1;
                                lct5 = -1;
                                lct6 = -1;
                                lct7 = -1;
                                // --- end auto ---


                                if (keyCT == 1) { // 1&2 same
                                    tmpsay = "";
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1');
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found 2: ' + result[lct1][b]);
                                                    lct2++;
                                                    result[lct1][lct2].push(adjval);
                                                    xit = true;
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };
                                } else if (keyCT == 2) {
                                    tmpsay = "";
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1: ' + result[a]);
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found 2: ' + result[lct1][b]);
                                                    lct2++;
                                                    result[lct1][lct2].push(adjval);
                                                    xit = true;
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };
                                    // vewAct(k0, cks, cke, 18, '<<Section 2 Working ON #652, #899 >>\t' + chKeys);
                                } else if (keyCT == 3) {
                                    // tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1');
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found 2');
                                                    lct2++;
                                                    for (c in result[lct1][lct2]) {
                                                        lct3++;
                                                        if (result[lct1][lct2][c] == chKeys[2]) {
                                                            // console.log('Found 3');
                                                            lct3++;
                                                            result[lct1][lct2][lct3].push( adjval );
                                                            xit = true;
                                                            break;
                                                        };
                                                    };
                                                };
                                                if (xit == true) {
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };
                                } else if (keyCT == 4) {
                                    // tmpsay = 'Section ' +  keyCT + ' Working On '; // 215
                                    // tmpsay = "";
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1');
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found 2');
                                                    lct2++;
                                                    for (c in result[lct1][lct2]) {
                                                        lct3++;
                                                        if (result[lct1][lct2][c] == chKeys[2]) {
                                                            // console.log('Found 3');
                                                            lct3++;
                                                            for (d in result[lct1][lct2][lct3]) {
                                                                lct4++;
                                                                // cant get key loc #2 all will go there
                                                                // console.log('\n\nShow Me the Keys: ' + curKeys);
                                                                if (result[lct1][lct2][lct3][d] == chKeys[3]) {
                                                                    // console.log('Found it: ' + result[lct1][lct2][lct3][d]);
                                                                    // console.log('last key: ' + thekeys[thekeys.length - 1]);
                                                                    lct4++;
                                                                    result[lct1][lct2][lct3][lct4].push( adjval ); // adding just the value
                                                                    xit = true;
                                                                    break;
                                                                };
                                                            };
                                                        };
                                                        if (xit == true) {
                                                            break;
                                                        };
                                                    };
                                                };
                                                if (xit == true) {
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };
                                } else if (keyCT == 5) {
                                    // tmpsay = 'Section ' +  keyCT + ' Working On '; // 215
                                    // tmpsay = "";
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1');
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found 2');
                                                    lct2++;
                                                    for (c in result[lct1][lct2]) {
                                                        lct3++;
                                                        if (result[lct1][lct2][c] == chKeys[2]) {
                                                            // console.log('Found 3');
                                                            lct3++;
                                                            for (d in result[lct1][lct2][lct3]) {
                                                                lct4++;
                                                                // cant get key loc #2 all will go there
                                                                // console.log('\n\nShow Me the Keys: ' + curKeys);
                                                                if (result[lct1][lct2][lct3][d] == chKeys[3]) {
                                                                    // console.log('Found it: ' + result[lct1][lct2][lct3][d]);
                                                                    // console.log('last key: ' + thekeys[thekeys.length - 1]);
                                                                    lct4++;
                                                                    for (e in result[lct1][lct2][lct3][lct4]) {
                                                                        lct5++;
                                                                        if (result[lct1][lct2][lct3][lct4][e] == chKeys[4]) {
                                                                            lct5++;
                                                                            result[lct1][lct2][lct3][lct4][lct5].push( adjval ); // adding just the value
                                                                            xit = true;
                                                                            break;
                                                                        };
                                                                    };
                                                                };
                                                                if (xit == true) {
                                                                    break;
                                                                };
                                                            };
                                                        };
                                                        if (xit == true) {
                                                            break;
                                                        };
                                                    };
                                                };
                                                if (xit == true) {
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };
                                } else if (keyCT == 6) {
                                    // tmpsay = 'Section ' +  keyCT + ' Working On '; // 215
                                    // tmpsay = "";
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1');
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found 2');
                                                    lct2++;
                                                    for (c in result[lct1][lct2]) {
                                                        lct3++;
                                                        if (result[lct1][lct2][c] == chKeys[2]) {
                                                            // console.log('Found 3');
                                                            lct3++;
                                                            for (d in result[lct1][lct2][lct3]) {
                                                                lct4++;
                                                                // cant get key loc #2 all will go there
                                                                // console.log('\n\nShow Me the Keys: ' + curKeys);
                                                                if (result[lct1][lct2][lct3][d] == chKeys[3]) {
                                                                    // console.log('Found it: ' + result[lct1][lct2][lct3][d]);
                                                                    // console.log('last key: ' + thekeys[thekeys.length - 1]);
                                                                    lct4++;
                                                                    for (e in result[lct1][lct2][lct3][lct4]) {
                                                                        lct5++;
                                                                        if (result[lct1][lct2][lct3][lct4][e] == chKeys[4]) {
                                                                            lct5++;
                                                                            for (f in result[lct1][lct2][lct3][lct4][lct5]) {
                                                                                lct6++;
                                                                                if (result[lct1][lct2][lct3][lct4][lct5][f] == chKeys[4]) {
                                                                                    lct6++;
                                                                                    result[lct1][lct2][lct3][lct4][lct5][lct6].push( adjval ); // adding just the value
                                                                                    xit = true;
                                                                                    break;
                                                                                };
                                                                            };
                                                                        };
                                                                        if (xit == true) {
                                                                            break;
                                                                        };
                                                                    };
                                                                };
                                                                if (xit == true) {
                                                                    break;
                                                                };
                                                            };
                                                        };
                                                        if (xit == true) {
                                                            break;
                                                        };
                                                    };
                                                };
                                                if (xit == true) {
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };
                                } else if (keyCT == 7) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup ';
                                } else {
                                    tmpsay = 'Section Open Square Not Setup';
                                };


                                if (k0 > cks && k0 < cke && tmpsay != '') {
                                    sayIt(tmpsay + ' Line ' + k0);
                                    vewAct(k0, cks, cke, 17, '<<' + tmpsay +'>>');
                                };

                                if (sect == 'Close Square') {
                                    // Auto Removal... note keyCT will deduct.
                                    tmp1 = curKeys.lastIndexOf(" <~> "); // visual purpose
                                    tmp2 = curKeys.substring(0, tmp1);
                                    curKeys = tmp2;
                                    keyCT--; // track the key count
                                    // --- auto end
                                };

                                vewAct(k0,cks, cke, 10, '\n\nAdjustments: ==C=O=P=Y==>\tKeys: ' + conPath(curKeys) + '\n' + 'result' + '\n\n');
                                vewAct(k0, cks, cke, 11, result);
                                wrksect = 'coMma';
                            } else if (wrksect == 'coMma') {
                                // no need to obtain value from part of a python list, value area obtain???
                                // Changes made in THIS AREA IS FAILING
                                // console.log('HERE!');
                                vewAct(k0, cks, cke, 9, 'actpt' + '\n' + orig.substring(actpt[actpt.length -1], k0));
                                valvalue = orig.substring(actpt[actpt.length - 1], k0);
                                actpt.push(k0);

                                adjval = cleaNewDic1Val(valvalue, k0);

                                vewAct(k0, cks, cke, 4, 'Key Count: ' + keyCT + '\tVALUE Value: ' + valvalue + '\nActions Points: ' + 'actpt');
                                vewAct(k0, cks, cke, 8, '\n\no\t' + adjval + '\to\n\n');


                                // note: Automatically remove the key and subtract count, plus else
                                // thekeys.push(adjval); // place value in total key variable
                                // pthKeys = curKeys; // path keys do not use the last location
                                // curKeys += ' <~> ' + adjval // start the key string observer
                                chKeys = conPath(curKeys); // all except the last, however last is present. not using last though
                                xit = false;
                                lct1 = -1;
                                lct2 = -1;
                                lct3 = -1;
                                lct4 = -1;
                                lct5 = -1;
                                lct6 = -1;
                                lct7 = -1;
                                // --- end auto ---


                                if (keyCT == 1) { // 1&2 same
                                    tmpsay = "";
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1');
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found 2: ' + result[lct1][b]);
                                                    lct2++;
                                                    result[lct1][lct2].push(adjval);
                                                    xit = true;
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };
                                } else if (keyCT == 2) {
                                    tmpsay = "";
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1: ' + result[a]);
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found 2: ' + result[lct1][b]);
                                                    lct2++;
                                                    result[lct1][lct2].push(adjval);
                                                    xit = true;
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };
                                    // vewAct(k0, cks, cke, 18, '<<Section 2 Working ON #652, #899 >>\t' + chKeys);
                                } else if (keyCT == 3) {
                                    // tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1');
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found 2');
                                                    lct2++;
                                                    for (c in result[lct1][lct2]) {
                                                        lct3++;
                                                        if (result[lct1][lct2][c] == chKeys[2]) {
                                                            // console.log('Found 3');
                                                            lct3++;
                                                            result[lct1][lct2][lct3].push( adjval );
                                                            xit = true;
                                                            break;
                                                        };
                                                    };
                                                };
                                                if (xit == true) {
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };
                                } else if (keyCT == 4) {
                                    // tmpsay = 'Section ' +  keyCT + ' Working On '; // 215
                                    // tmpsay = "";
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1');
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found 2');
                                                    lct2++;
                                                    for (c in result[lct1][lct2]) {
                                                        lct3++;
                                                        if (result[lct1][lct2][c] == chKeys[2]) {
                                                            // console.log('Found 3');
                                                            lct3++;
                                                            for (d in result[lct1][lct2][lct3]) {
                                                                lct4++;
                                                                // cant get key loc #2 all will go there
                                                                // console.log('\n\nShow Me the Keys: ' + curKeys);
                                                                if (result[lct1][lct2][lct3][d] == chKeys[3]) {
                                                                    // console.log('Found it: ' + result[lct1][lct2][lct3][d]);
                                                                    // console.log('last key: ' + thekeys[thekeys.length - 1]);
                                                                    lct4++;
                                                                    result[lct1][lct2][lct3][lct4].push( adjval ); // adding just the value
                                                                    xit = true;
                                                                    break;
                                                                };
                                                            };
                                                        };
                                                        if (xit == true) {
                                                            break;
                                                        };
                                                    };
                                                };
                                                if (xit == true) {
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };
                                } else if (keyCT == 5) {
                                    // tmpsay = 'Section ' +  keyCT + ' Working On '; // 215
                                    // tmpsay = "";
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1');
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found 2');
                                                    lct2++;
                                                    for (c in result[lct1][lct2]) {
                                                        lct3++;
                                                        if (result[lct1][lct2][c] == chKeys[2]) {
                                                            // console.log('Found 3');
                                                            lct3++;
                                                            for (d in result[lct1][lct2][lct3]) {
                                                                lct4++;
                                                                // cant get key loc #2 all will go there
                                                                // console.log('\n\nShow Me the Keys: ' + curKeys);
                                                                if (result[lct1][lct2][lct3][d] == chKeys[3]) {
                                                                    // console.log('Found it: ' + result[lct1][lct2][lct3][d]);
                                                                    // console.log('last key: ' + thekeys[thekeys.length - 1]);
                                                                    lct4++;
                                                                    for (e in result[lct1][lct2][lct3][lct4]) {
                                                                        lct5++;
                                                                        if (result[lct1][lct2][lct3][lct4][e] == chKeys[4]) {
                                                                            lct5++;
                                                                            result[lct1][lct2][lct3][lct4][lct5].push( adjval ); // adding just the value
                                                                            xit = true;
                                                                            break;
                                                                        };
                                                                    };
                                                                };
                                                                if (xit == true) {
                                                                    break;
                                                                };
                                                            };
                                                        };
                                                        if (xit == true) {
                                                            break;
                                                        };
                                                    };
                                                };
                                                if (xit == true) {
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };
                                } else if (keyCT == 6) {
                                    // tmpsay = 'Section ' +  keyCT + ' Working On '; // 215
                                    // tmpsay = "";
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1');
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found 2');
                                                    lct2++;
                                                    for (c in result[lct1][lct2]) {
                                                        lct3++;
                                                        if (result[lct1][lct2][c] == chKeys[2]) {
                                                            // console.log('Found 3');
                                                            lct3++;
                                                            for (d in result[lct1][lct2][lct3]) {
                                                                lct4++;
                                                                // cant get key loc #2 all will go there
                                                                // console.log('\n\nShow Me the Keys: ' + curKeys);
                                                                if (result[lct1][lct2][lct3][d] == chKeys[3]) {
                                                                    // console.log('Found it: ' + result[lct1][lct2][lct3][d]);
                                                                    // console.log('last key: ' + thekeys[thekeys.length - 1]);
                                                                    lct4++;
                                                                    for (e in result[lct1][lct2][lct3][lct4]) {
                                                                        lct5++;
                                                                        if (result[lct1][lct2][lct3][lct4][e] == chKeys[4]) {
                                                                            lct5++;
                                                                            for (f in result[lct1][lct2][lct3][lct4][lct5]) {
                                                                                lct6++;
                                                                                if (result[lct1][lct2][lct3][lct4][lct5][f] == chKeys[4]) {
                                                                                    lct6++;
                                                                                    result[lct1][lct2][lct3][lct4][lct5][lct6].push( adjval ); // adding just the value
                                                                                    xit = true;
                                                                                    break;
                                                                                };
                                                                            };
                                                                        };
                                                                        if (xit == true) {
                                                                            break;
                                                                        };
                                                                    };
                                                                };
                                                                if (xit == true) {
                                                                    break;
                                                                };
                                                            };
                                                        };
                                                        if (xit == true) {
                                                            break;
                                                        };
                                                    };
                                                };
                                                if (xit == true) {
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };
                                } else if (keyCT == 7) {
                                    tmpsay = 'Section ' + keyCT + ' Not Setup ';
                                } else {
                                    tmpsay = 'Section Comma Not Setup';
                                };


                                if (k0 > cks && k0 < cke && tmpsay != '') {
                                    sayIt(tmpsay + ' Line ' + k0);
                                    vewAct(k0, cks, cke, 17, '<<' + tmpsay +'>>');
                                };

                                if (sect == 'Close Square') {
                                    // Auto Removal... note keyCT will deduct.
                                    tmp1 = curKeys.lastIndexOf(" <~> "); // visual purpose
                                    tmp2 = curKeys.substring(0, tmp1);
                                    curKeys = tmp2;
                                    keyCT--; // track the key count
                                    // --- auto end
                                };

                                vewAct(k0,cks, cke, 10, '\n\nAdjustments: ==C=O=P=Y==>\tKeys: ' + conPath(curKeys) + '\n' + 'result' + '\n\n');
                                vewAct(k0, cks, cke, 11, result);
                                wrksect = 'coMma';
                            } else {
                                tmpsay = 'COMMA Response from ' + wrksect +' Not SetUp';
                                console.log ('\n\nKey Count: ' + keyCT + '\n(46723) This ' + tmpsay + '.\n\t\t'+orig.substring(k0-10, k0+10)+'\nLast: ' + lookL[9] + '\nNext: ' + lookR[9]);
                                if (k0 > cks && k0 < cke && tmpsay != '') {
                                    sayIt(tmpsay + ' Line ' + k0);
                                };
                            };
                        } else if ((['&#39;', '&#34;'].indexOf(lookL[5]) != -1 && [', &#39;', ', &#34;'].indexOf(lookR[7]) != -1) || (["'",'"'].indexOf(lookL[1]) != -1 && [", '",', "'].indexOf(lookR[3]) != -1)) {
                            // if (wrksect == 'coLon') {
                                vewAct(k0, cks, cke, 15, '\n\n\t\t\t\tThis is the   ONE: \n\n');
                            if (['coLon'].indexOf(wrksect) != -1) {
                                // obtain the value and remove visual key...
                                // even next trans is a key, retrieve key by its value, sometimes is an additional value that needs to be push
                                vewAct(k0, cks, cke, 9, 'actpt' + '\n' + orig.substring(actpt[actpt.length -1], k0));
                                valvalue = orig.substring(actpt[actpt.length - 1], k0);
                                actpt.push(k0);

                                adjval = cleaNewDic1Val(valvalue, k0); // note these are valvalue/keyvalue

                                vewAct(k0, cks, cke, 4, 'Key Count: ' + keyCT + '\tVALUE Value: ' + valvalue + '\nActions Points: ' + 'actpt');
                                vewAct(k0, cks, cke, 8, '\n\no\t' + adjval + '\to\n\n');


                                // note: Automatically remove the key and subtract count, plus else
                                // thekeys.push(adjval); // place value in total key variable
                                // pthKeys = curKeys; // path keys do not use the last location
                                // curKeys += ' <~> ' + adjval // start the key string observer
                                chKeys = conPath(curKeys); // all except the last, however last is present. not using last though
                                xit = false;
                                lct1 = -1;
                                lct2 = -1;
                                lct3 = -1;
                                lct4 = -1;
                                // --- end auto ---


                                if (keyCT == 1) { // 1&2 same
                                    tmpsay = "";
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1');
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found 2: ' + result[lct1][b]);
                                                    lct2++;
                                                    result[lct1][lct2].push(adjval);
                                                    xit = true;
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };
                                } else if (keyCT == 2) {
                                    tmpsay = "";
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1: ' + result[a]);
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found 2: ' + result[lct1][b]);
                                                    lct2++;
                                                    result[lct1][lct2].push(adjval);
                                                    xit = true;
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };
                                    // vewAct(k0, cks, cke, 18, '<<Section 2 Working ON #652, #899 >>\t' + chKeys);
                                } else if (keyCT == 3) {
                                    // tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1');
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found 2');
                                                    lct2++;
                                                    for (c in result[lct1][lct2]) {
                                                        lct3++;
                                                        if (result[lct1][lct2][c] == chKeys[2]) {
                                                            // console.log('Found 3');
                                                            lct3++;
                                                            result[lct1][lct2][lct3].push( adjval );
                                                            xit = true;
                                                            break;
                                                        };
                                                    };
                                                };
                                                if (xit == true) {
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };
                                } else if (keyCT == 4) {
                                    tmpsay = "";
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1');
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found 2');
                                                    lct2++;
                                                    for (c in result[lct1][lct2]) {
                                                        lct3++;
                                                        if (result[lct1][lct2][c] == chKeys[2]) {
                                                            // console.log('Found 3');
                                                            lct3++;
                                                            for (d in result[lct1][lct2][lct3]) {
                                                                lct4++;
                                                                // cant get key loc #2 all will go there
                                                                // console.log('\n\nShow Me the Keys: ' + curKeys);
                                                                if (result[lct1][lct2][lct3][d] == chKeys[3]) {
                                                                    // console.log('Found it: ' + result[lct1][lct2][lct3][d]);
                                                                    // console.log('last key: ' + thekeys[thekeys.length - 1]);
                                                                    lct4++;
                                                                    result[lct1][lct2][lct3][lct4].push( adjval ); // adding just the value
                                                                    xit = true;
                                                                    break;
                                                                };
                                                            };
                                                        };
                                                        if (xit == true) {
                                                            break;
                                                        };
                                                    };
                                                };
                                                if (xit == true) {
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };
                                } else {
                                    tmpsay = 'Section NONE Not Setup';
                                };
                                //} else if ([].indexOf(lookL[]) != -1 && [].indexOf(lookR[]) != -1) {
                                if (k0 > cks && k0 < cke && tmpsay != '') {
                                    sayIt(tmpsay + ' Line ' + k0);
                                    vewAct(k0, cks, cke, 17, '<<' + tmpsay +'>>');
                                };

                                // Auto Removal... note keyCT will deduct.
                                tmp1 = curKeys.lastIndexOf(" <~> "); // visual purpose
                                tmp2 = curKeys.substring(0, tmp1);
                                curKeys = tmp2;
                                keyCT--; // track the key count
                                // --- auto end

                                vewAct(k0,cks, cke, 10, '\n\nAdjustments: ========>\tKeys: ' + conPath(curKeys) + '\n' + 'result' + '\n\n');
                                vewAct(k0, cks, cke, 11, result);
                                wrksect = 'coMma';
                            } else if (['opSquare'].indexOf(wrksect) != -1) {
                                // your in square bracket process
                                vewAct(k0, cks, cke, 15, '\n\n\t\t\t\tThis is the   AREA: ' + spOpt + '\n\n');
                                vewAct(k0, cks, cke, 9, 'actpt' + '\n' + orig.substring(actpt[actpt.length -1], k0));
                                valvalue = orig.substring(actpt[actpt.length - 1], k0);
                                actpt.push(k0);

                                adjval = cleaNewDic1Val(valvalue, k0);

                                // var tmpc = stringCount(adjval,"'",false);
                                // console.log('\nthis is: ' + tmpc);  // adjustment Fix
                                if (stringCount(adjval,"'",false) == 1) {
                                    // console.log('\t\t-> ' + adjval.substring(adjval.length - 1, adjval.length) + '\t\tLine : ' + k0 + '\t\t' + viewpos);
                                    if (adjval.substring(0,1) == "'") {
                                        vewAct(k0, cks, cke, 20, '\tAdjustment made to Front: ' + adjval);
                                        adjval = adjval.substring(1,adjval.length);
                                    } else if (adjval.substring(adjval.length - 1, adjval.length) == "'") {
                                        vewAct(k0, cks, cke, 20, '\tAdjustment made to Back: ' + adjval)
                                        adjval = adjval.substring(adjval.length - 1, adjval.length);
                                    } else {
                                        vewAct(k0, cks, cke, 21, 'Option Not Available');
                                    };
                                };

                                vewAct(k0, cks, cke, 4, 'Key Count: ' + keyCT + '\tVALUE Value: ' + valvalue + '\nActions Points: ' + 'actpt');
                                vewAct(k0, cks, cke, 8, '\n\no\t' + adjval + '\to\n\n');


                                // note: Automatically remove the key and subtract count, plus else
                                // thekeys.push(adjval); // place value in total key variable
                                // pthKeys = curKeys; // path keys do not use the last location
                                // curKeys += ' <~> ' + adjval // start the key string observer
                                chKeys = conPath(curKeys); // all except the last, however last is present. not using last though
                                xit = false;
                                lct1 = -1;
                                lct2 = -1;
                                lct3 = -1;
                                lct4 = -1;
                                // --- end auto ---


                                if (wrksqre == true) {
                                    // working within array (square bracket)
                                    // console.log('\n\n\t\tProcess Within Array\n\n');
                                    if (keyCT == 1) {
                                        // vewAct(k0, cks, cke,'Working on Key ONE');
                                        tmpsay = "";
                                        for (a in result) {
                                            lct1++;
                                            if (result[a] == chKeys[0]) {
                                                lct1++;
                                                result[lct1].push( adjval );
                                                break;
                                            };
                                        };
                                    } else if (keyCT == 2) {
                                        // tmpsay = 'Section ' + keyCT + ' Not Setup';
                                        tmpsay = "";
                                        for (a in result) {
                                            lct1++;
                                            // console.log(result[a]);
                                            if (result[a] == chKeys[0]) {
                                                // console.log('Found 1: ' + result[a]);
                                                lct1++;
                                                for(b in result[lct1]) {
                                                    lct2++;
                                                    // console.log(result[lct1][b]);
                                                    if (result[lct1][b] == chKeys[1]) {
                                                        // console.log('Found 2: ' + result[lct1][b]);
                                                        lct2++;
                                                        result[lct1][lct2].push(adjval);
                                                        xit = true;
                                                        break;
                                                    };
                                                };
                                            };
                                            if (xit == true) {
                                                break;
                                            };
                                        };
                                    } else if (keyCT == 2) {
                                        // tmpsay = 'Section ' + keyCT + ' Not Setup';
                                        tmpsay = "";
                                        for (a in result) {
                                            lct1++;
                                            // console.log(result[a]);
                                            if (result[a] == chKeys[0]) {
                                                // console.log('Found 1: ' + result[a]);
                                                lct1++;
                                                for(b in result[lct1]) {
                                                    lct2++;
                                                    // console.log(result[lct1][b]);
                                                    if (result[lct1][b] == chKeys[1]) {
                                                        // console.log('Found 2: ' + result[lct1][b]);
                                                        lct2++;
                                                        result[lct1][lct2].push(adjval);
                                                        xit = true;
                                                        break;
                                                    };
                                                };
                                            };
                                            if (xit == true) {
                                                break;
                                            };
                                        };
                                    } else if (keyCT == 3) {
                                        tmpsay = 'Section ' + keyCT + ' Not Setup';
                                    } else if (keyCT == 4) {
                                        tmpsay = 'Section ' + keyCT + ' Not Setup';
                                    } else if (keyCT == 5) {
                                        tmpsay = 'Section ' + keyCT + ' Not Setup';
                                    } else {
                                        tmpsay = 'Section NONE Not Setup';
                                    };
                                    if (k0 > cks && k0 < cke && tmpsay != '') {
                                        sayIt(tmpsay + ' Line ' + k0);
                                        vewAct(k0, cks, cke, 13, '<<' + tmpsay + '>>');
                                    };
                                    vewAct(k0, cks, cke, 14, '\n\nAdjustments: qqCqOqPqYqq>\n\tKeys: ' + conPath(curKeys) + '\nResult:\n');
                                    vewAct(k0, cks, cke, 11, result); // when result on same line data result is mess up
                                    vewAct(k0, cks, cke, '\n');
                                    wrksect = 'coMma';

                                } else {
                                    // process not within array
                                    console.log('\n\n\t\tProcess not within Array 2\n\n');
                                }


                            } else if (['coMma','clSquare'].indexOf(wrksect) != -1) {
                                // added clSquare test pass
                                // your in square bracket process
                                vewAct(k0, cks, cke, 9, 'actpt' + '\n' + orig.substring(actpt[actpt.length -1], k0));
                                valvalue = orig.substring(actpt[actpt.length - 1], k0);
                                actpt.push(k0);

                                adjval = cleaNewDic1Val(valvalue, k0);

                                vewAct(k0, cks, cke, 4, 'Key Count: ' + keyCT + '\tVALUE Value: ' + valvalue + '\nActions Points: ' + 'actpt');
                                vewAct(k0, cks, cke, 8, '\n\no\t' + adjval + '\to\n\n');


                                // note: Automatically remove the key and subtract count, plus else
                                // thekeys.push(adjval); // place value in total key variable
                                // pthKeys = curKeys; // path keys do not use the last location
                                // curKeys += ' <~> ' + adjval // start the key string observer
                                chKeys = conPath(curKeys); // all except the last, however last is present. not using last though
                                xit = false;
                                lct1 = -1;
                                lct2 = -1;
                                lct3 = -1;
                                lct4 = -1;
                                // --- end auto ---


                                if (wrksqre == true) {
                                    // working within array (square bracket)
                                    // console.log('\n\n\t\tProcess Within Array\n\n');
                                    if (keyCT == 1) {
                                        tmpsay = 'Section ' + keyCT + ' Not Setup'; // 134
                                        tmpsay = "";
                                        for (a in result) {
                                            lct1++;
                                            if (result[a] == chKeys[0]) {
                                                lct1++;
                                                result[lct1].push( adjval );
                                                break;
                                            };
                                        };
                                    } else if (keyCT == 2) {
                                        // tmpsay = 'Section ' + keyCT + ' Not Setup';
                                        tmpsay = "";
                                        for (a in result) {
                                            lct1++;
                                            // console.log(result[a]);
                                            if (result[a] == chKeys[0]) {
                                                // console.log('Found 1: ' + result[a]);
                                                lct1++;
                                                for(b in result[lct1]) {
                                                    lct2++;
                                                    // console.log(result[lct1][b]);
                                                    if (result[lct1][b] == chKeys[1]) {
                                                        // console.log('Found 2: ' + result[lct1][b]);
                                                        lct2++;
                                                        result[lct1][lct2].push(adjval);
                                                        xit = true;
                                                        break;
                                                    };
                                                };
                                            };
                                            if (xit == true) {
                                                break;
                                            };
                                        };
                                    } else if (keyCT == 3) {
                                        tmpsay = 'Section ' + keyCT + ' Not Setup';
                                    } else if (keyCT == 4) {
                                        tmpsay = 'Section ' + keyCT + ' Not Setup';
                                    } else if (keyCT == 5) {
                                        tmpsay = 'Section ' + keyCT + ' Not Setup';
                                    } else {
                                        tmpsay = 'Section NONE Not Setup';
                                    };
                                    if (k0 > cks && k0 < cke && tmpsay != '') {
                                        sayIt(tmpsay + ' Line ' + k0);
                                        vewAct(k0, cks, cke, 13, '<<' + tmpsay + '>>');
                                    };
                                    vewAct(k0,cks, cke, 10, '\n\nAdjustments: qqCqOqPqYqqq>\tKeys: ' + conPath(curKeys) + '\n' + 'result' + '\n\n');
                                    vewAct(k0, cks, cke, 11, result);
                                    wrksect = 'coMma';

                                } else {
                                    // process not within array
                                    console.log('\n\n\t\tProcess not within Array 1\n\n'); // never tested below

                                    if (keyCT == 1) {
                                        tmpsay = 'Section ' + keyCT + ' Not Setup';
                                    } else if (keyCT == 1) {
                                        tmpsay = 'Section ' + keyCT + ' Not Setup';
                                    } else if (keyCT == 2) {
                                        // tmpsay = 'Section ' + keyCT + ' Not Setup';
                                        tmpsay = "";
                                        for (a in result) {
                                            lct1++;
                                            // console.log(result[a]);
                                            if (result[a] == chKeys[0]) {
                                                // console.log('Found 1: ' + result[a]);
                                                lct1++;
                                                for(b in result[lct1]) {
                                                    lct2++;
                                                    // console.log(result[lct1][b]);
                                                    if (result[lct1][b] == chKeys[1]) {
                                                        // console.log('Found 2: ' + result[lct1][b]);
                                                        lct2++;
                                                        result[lct1][lct2].push(adjval);
                                                        xit = true;
                                                        break;
                                                    };
                                                };
                                            };
                                            if (xit == true) {
                                                break;
                                            };
                                        };
                                    } else if (keyCT == 3) {
                                        tmpsay = 'Section ' + keyCT + ' Not Setup';
                                    } else if (keyCT == 4) {
                                        tmpsay = 'Section ' + keyCT + ' Not Setup';
                                    } else if (keyCT == 5) {
                                        tmpsay = 'Section ' + keyCT + ' Not Setup';
                                    } else {
                                        tmpsay = 'Section NONE Not Setup';
                                    };
                                    if (k0 > cks && k0 < cke && tmpsay != '') {
                                        sayIt(tmpsay + ' Line ' + k0);
                                        vewAct(k0, cks, cke, 13, '<<' + tmpsay + '>>');
                                    };
                                    vewAct(k0,cks, cke, 10, '\n\nAdjustments: qqCqOqPqYqq>\tKeys: ' + conPath(curKeys) + '\n' + 'result' + '\n\n');
                                    vewAct(k0, cks, cke, 11, result);
                                    wrksect = 'coMma';
                                };

                            } else {
                                tmpsay = 'COMMA Response from ' + wrksect +' Not SetUp';
                                console.log ('\n\nKey Count: ' + keyCT + '\n(467273) This ' + tmpsay + '.\n\t\t'+orig.substring(k0-10, k0+10)+'\nLast: ' + lookL[9] + '\nNext: ' + lookR[9]);
                                if (k0 > cks && k0 < cke && tmpsay != '') {
                                    sayIt(tmpsay + ' Line ' + k0);
                                };
                            };
                        } else if (['&#39;]}','&#34;]}'].indexOf(lookL[7]) != -1 && [', u&#39;',', u&#34;'].indexOf(lookR[8]) != -1) {
                            // droping a key and preping for new key
                            if (wrksect == 'clBrack') {
                                // acknowledge start new key
                                vewAct(k0, cks, cke, 22, '<< Really No Sections 1 >>');
                                vewAct(k0, cks, cke, 22, '<< Working on Section >>');
                                vewAct(k0, cks, cke, 9, 'actpt' + '\n' + orig.substring(actpt[actpt.length -1], k0));
                                valvalue = orig.substring(actpt[actpt.length - 1], k0);
                                actpt.push(k0);

                                adjval = cleaNewDic1Val(valvalue, k0);

                                vewAct(k0, cks, cke, 4, 'Key Count: ' + keyCT + '\tVALUE Value: ' + valvalue + '\nActions Points: ' + 'actpt');
                                vewAct(k0, cks, cke, 8, '\n\no\t' + adjval + '\to\n\n');


                                // note: Automatically remove the key and subtract count, plus else
                                // thekeys.push(adjval); // place value in total key variable
                                // pthKeys = curKeys; // path keys do not use the last location
                                // curKeys += ' <~> ' + adjval // start the key string observer
                                chKeys = conPath(curKeys); // all except the last, however last is present. not using last though
                                xit = false;
                                lct1 = -1;
                                lct2 = -1;
                                lct3 = -1;
                                lct4 = -1;
                                // --- end auto ---

                                // Auto Removal... note keyCT will deduct.
                                tmp1 = curKeys.lastIndexOf(" <~> "); // visual purpose
                                tmp2 = curKeys.substring(0, tmp1);
                                curKeys = tmp2;
                                keyCT--; // track the key count
                                // --- auto end

                                vewAct(k0, cks, cke, 26, '\n\t Drop Key... count: ' + keyCT + '\tKeys: ' + conPath(curKeys) + '\n');

                                vewAct(k0, cks, cke, 27, '\n\n<===== Acknowledge Start of New Key =====>\t' + chKeys[keyCT - 1]);// right now doing nothing..., must initiate actpt though
                                vewAct(k0, cks, cke, 11, result);
                                wrksect = 'coMma';
                            } else {
                                tmpsay = 'COMMA Response from ' + wrksect +' Not SetUp';
                                console.log ('\n\nKey Count: ' + keyCT + '\n(71682) This ' + tmpsay + '.\n\t\t'+orig.substring(k0-10, k0+10)+'\nLast: ' + lookL[9] + '\nNext: ' + lookR[9]);
                                if (k0 > cks && k0 < cke && tmpsay != '') {
                                    sayIt(tmpsay + ' Line ' + k0);
                                };
                            };
                        } else if (['&#39;}}','&#34;}}'].indexOf(lookL[7]) != -1 && [', u&#39;',', u&#34;'].indexOf(lookR[8]) != -1) {
                            // console.log('\t\t\t\t*******Pick it up here 1************');
                            if (wrksect == 'clBrack') {
                                // acknowledge start new key
                                vewAct(k0, cks, cke, 22, '<< Really No Sections 1 >>');
                                vewAct(k0, cks, cke, 22, '<< Working on Section >>');
                                vewAct(k0, cks, cke, 9, 'actpt' + '\n' + orig.substring(actpt[actpt.length -1], k0));
                                valvalue = orig.substring(actpt[actpt.length - 1], k0);
                                actpt.push(k0);

                                adjval = cleaNewDic1Val(valvalue, k0);

                                vewAct(k0, cks, cke, 4, 'Key Count: ' + keyCT + '\tVALUE Value: ' + valvalue + '\nActions Points: ' + 'actpt');
                                vewAct(k0, cks, cke, 8, '\n\no\t' + adjval + '\to\n\n');


                                // note: Automatically remove the key and subtract count, plus else
                                // thekeys.push(adjval); // place value in total key variable
                                // pthKeys = curKeys; // path keys do not use the last location
                                // curKeys += ' <~> ' + adjval // start the key string observer
                                chKeys = conPath(curKeys); // all except the last, however last is present. not using last though
                                xit = false;
                                lct1 = -1;
                                lct2 = -1;
                                lct3 = -1;
                                lct4 = -1;
                                // --- end auto ---

                                // Auto Removal... note keyCT will deduct.
                                tmp1 = curKeys.lastIndexOf(" <~> "); // visual purpose
                                tmp2 = curKeys.substring(0, tmp1);
                                curKeys = tmp2;
                                keyCT--; // track the key count
                                // --- auto end

                                vewAct(k0, cks, cke, 26, '\n\t Drop Key... count: ' + keyCT + '\tKeys: ' + conPath(curKeys) + '\n');

                                vewAct(k0, cks, cke, 27, '\n\n<===== Acknowledge Start of New Key =====>\t' + chKeys[keyCT - 1]);// right now doing nothing..., must initiate actpt though
                                vewAct(k0, cks, cke, 11, result);
                                wrksect = 'coMma';
                            } else {
                                tmpsay = 'COMMA Response from ' + wrksect +' Not SetUp';
                                console.log ('\n\nKey Count: ' + keyCT + '\n(71682) This ' + tmpsay + '.\n\t\t'+orig.substring(k0-10, k0+10)+'\nLast: ' + lookL[9] + '\nNext: ' + lookR[9]);
                                if (k0 > cks && k0 < cke && tmpsay != '') {
                                    sayIt(tmpsay + ' Line ' + k0);
                                };
                            };
                        } else if ((['&#39;}}','&#34;}}'].indexOf(lookL[7]) != -1 && [', &#39;',', &#34;'].indexOf(lookR[7]) != -1) || (["'}}",'"}}'].indexOf(lookL[3]) != -1 && [", '",', "'].indexOf(lookR[3]) != -1)) {
                            // console.log('\t\t\t\t*******Pick it up here 1************');
                            if (wrksect == 'clBrack') {
                                // acknowledge start new key
                                vewAct(k0, cks, cke, 22, '<< Really No Sections 2 >>'); // 623
                                vewAct(k0, cks, cke, 22, '<< Working on Section >>');
                                vewAct(k0, cks, cke, 9, 'actpt' + '\n' + orig.substring(actpt[actpt.length -1], k0));
                                valvalue = orig.substring(actpt[actpt.length - 1], k0);
                                actpt.push(k0);

                                adjval = cleaNewDic1Val(valvalue, k0);

                                vewAct(k0, cks, cke, 4, 'Key Count: ' + keyCT + '\tVALUE Value: ' + valvalue + '\nActions Points: ' + 'actpt');
                                vewAct(k0, cks, cke, 8, '\n\no\t' + adjval + '\to\n\n');


                                // note: Automatically remove the key and subtract count, plus else
                                // thekeys.push(adjval); // place value in total key variable
                                // pthKeys = curKeys; // path keys do not use the last location
                                // curKeys += ' <~> ' + adjval // start the key string observer
                                chKeys = conPath(curKeys); // all except the last, however last is present. not using last though
                                xit = false;
                                lct1 = -1;
                                lct2 = -1;
                                lct3 = -1;
                                lct4 = -1;
                                // --- end auto ---

                                // Auto Removal... note keyCT will deduct.
                                tmp1 = curKeys.lastIndexOf(" <~> "); // visual purpose
                                tmp2 = curKeys.substring(0, tmp1);
                                curKeys = tmp2;
                                keyCT--; // track the key count
                                // --- auto end

                                vewAct(k0, cks, cke, 26, '\n\t Drop Key... count: ' + keyCT + '\tKeys: ' + conPath(curKeys) + '\n');

                                vewAct(k0, cks, cke, 27, '\n\n<===== Acknowledge Start of New Key =====>\t' + chKeys[keyCT - 1]);// right now doing nothing..., must initiate actpt though
                                vewAct(k0, cks, cke, 11, result);
                                wrksect = 'coMma';
                            } else {
                                tmpsay = 'COMMA Response from ' + wrksect +' Not SetUp';
                                console.log ('\n\nKey Count: ' + keyCT + '\n(37162) This ' + tmpsay + '.\n\t\t'+orig.substring(k0-10, k0+10)+'\nLast: ' + lookL[9] + '\nNext: ' + lookR[9]);
                                if (k0 > cks && k0 < cke && tmpsay != '') {
                                    sayIt(tmpsay + ' Line ' + k0);
                                };
                            };
                        } else if ((['&#39;}','&#34;}'].indexOf(lookL[6]) != -1 && [', u&#39;',', u&#34;'].indexOf(lookR[8]) != -1) || (["'}",'"}'].indexOf(lookL[2]) != -1 && [", u'",', u"'].indexOf(lookR[4]) != -1)) {
                            if (wrksect == 'clBrack') {
                                // acknowledge start new key

                                // vewAct(k0, cks, cke, 22, '<< Working on Section >>');
                                vewAct(k0, cks, cke, 9, 'actpt' + '\n' + orig.substring(actpt[actpt.length -1], k0));
                                valvalue = orig.substring(actpt[actpt.length - 1], k0);
                                actpt.push(k0);

                                adjval = cleaNewDic1Val(valvalue, k0);

                                vewAct(k0, cks, cke, 4, 'Key Count: ' + keyCT + '\tVALUE Value: ' + valvalue + '\nActions Points: ' + 'actpt');
                                vewAct(k0, cks, cke, 8, '\n\no\t' + adjval + '\to\n\n');


                                // note: Automatically remove the key and subtract count, plus else
                                // thekeys.push(adjval); // place value in total key variable
                                // pthKeys = curKeys; // path keys do not use the last location
                                // curKeys += ' <~> ' + adjval // start the key string observer
                                chKeys = conPath(curKeys); // all except the last, however last is present. not using last though
                                xit = false;
                                lct1 = -1;
                                lct2 = -1;
                                lct3 = -1;
                                lct4 = -1;
                                // --- end auto ---

                                // Auto Removal... note keyCT will deduct.
                                tmp1 = curKeys.lastIndexOf(" <~> "); // visual purpose
                                tmp2 = curKeys.substring(0, tmp1);
                                curKeys = tmp2;
                                keyCT--; // track the key count
                                // --- auto end

                                vewAct(k0, cks, cke, 26, '\n\t Drop Key... count: ' + keyCT + '\tKeys: ' + conPath(curKeys) + '\n');



                                vewAct(k0, cks, cke, 27, '\n\n<===== AcknowledgeStart of New Key (from Beginning) =====>\t' + thekeys[keyCT - 1]);// right now doing nothing..., must initiate actpt though
                                vewAct(k0, cks, cke, 11, result);
                                wrksect = 'coMma';
                            } else {
                                tmpsay = 'COMMA Response from ' + wrksect +' Not SetUp';
                                console.log ('\n\nKey Count: ' + keyCT + '\n(3716082) This ' + tmpsay + '.\n\t\t'+orig.substring(k0-10, k0+10)+'\nLast: ' + lookL[9] + '\nNext: ' + lookR[9]);
                                if (k0 > cks && k0 < cke && tmpsay != '') {
                                    sayIt(tmpsay + ' Line ' + k0);
                                };
                            };
                        } else if ((EngNum.indexOf(lookL[1]) != -1 && [', &#39;',', &#34;'].indexOf(lookR[7]) != -1) || (EngNum.indexOf(lookL[1]) != -1 && [", '"].indexOf(lookR[3]) != -1)) {
                            if (wrksect == 'coLon') {
                                // obtain the value and remove visual key... even next trans is a key, retrieve key by its value
                                vewAct(k0, cks, cke, 9, 'actpt' + '\n' + orig.substring(actpt[actpt.length -1], k0));
                                valvalue = orig.substring(actpt[actpt.length - 1], k0);
                                actpt.push(k0);

                                adjval = cleaNewDic1Val(valvalue, k0);

                                vewAct(k0, cks, cke, 4, 'Key Count: ' + keyCT + '\tVALUE Value: ' + valvalue + '\nActions Points: ' + 'actpt');
                                vewAct(k0, cks, cke, 8, '\n\n' + 'Interger Value\n' + 'o\t' + adjval + '\to\n\n');


                                // note: Automatically remove the key and subtract count, plus else
                                // thekeys.push(adjval); // place value in total key variable
                                // pthKeys = curKeys; // path keys do not use the last location
                                // curKeys += ' <~> ' + adjval // start the key string observer
                                chKeys = conPath(curKeys); // all except the last, however last is present. not using last though
                                xit = false;
                                lct1 = -1;
                                lct2 = -1;
                                lct3 = -1;
                                lct4 = -1;
                                // --- end auto ---


                                if (keyCT == 1) { // 1&2 same
                                    vewAct(k0, cks, cke, 23, '<< Location Section 1>>');
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1');
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found 2: ' + result[lct1][b]);
                                                    lct2++;
                                                    result[lct1][lct2].push(adjval);
                                                    xit = true;
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };
                                } else if (keyCT == 2) {
                                    vewAct(k0, cks, cke, 23, '<< Location Section 2>>');
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1: ' + result[a]);
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found 2: ' + result[lct1][b]);
                                                    lct2++;
                                                    result[lct1][lct2].push(adjval);
                                                    xit = true;
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };
                                    // vewAct(k0, cks, cke, 18, '<<Section 2 Working ON #652, #899 >>\t' + chKeys);
                                } else if (keyCT == 3) {
                                    // result[1].push([valvalue.substring(1, valvalue.length -1)]);
                                    vewAct(k0, cks, cke, 18, '<<Section 3 Not Setup>>');
                                } else if (keyCT == 4) {
                                    vewAct(k0, cks, cke, 23, '<< Location Section 4>>');
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1');
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found 2');
                                                    lct2++;
                                                    for (c in result[lct1][lct2]) {
                                                        lct3++;
                                                        if (result[lct1][lct2][c] == chKeys[2]) {
                                                            // console.log('Found 3');
                                                            lct3++;
                                                            for (d in result[lct1][lct2][lct3]) {
                                                                lct4++;
                                                                // cant get key loc #2 all will go there
                                                                // console.log('\n\nShow Me the Keys: ' + curKeys);
                                                                if (result[lct1][lct2][lct3][d] == chKeys[3]) {
                                                                    // console.log('Found it: ' + result[lct1][lct2][lct3][d]);
                                                                    // console.log('last key: ' + thekeys[thekeys.length - 1]);
                                                                    lct4++;
                                                                    result[lct1][lct2][lct3][lct4].push( adjval ); // adding just the value
                                                                    xit = true;
                                                                    break;
                                                                };
                                                            };
                                                            if (xit == true) {
                                                                break;
                                                            };
                                                        };
                                                    };
                                                    if (xit == true) {
                                                        break;
                                                    };
                                                };
                                            };
                                            if (xit == true) {
                                                break;
                                            };
                                        };
                                    };
                                };

                                // Auto Removal... note keyCT will deduct.
                                tmp1 = curKeys.lastIndexOf(" <~> "); // visual purpose
                                tmp2 = curKeys.substring(0, tmp1);
                                curKeys = tmp2;
                                keyCT--; // track the key count
                                // --- auto end

                                vewAct(k0,cks, cke, 10, '\n\nAdjustments: ===C=O=P=Y==>\tKeys: ' + conPath(curKeys) + '\n' + 'result' + '\n\n');
                                vewAct(k0, cks, cke, 11, result);
                                wrksect = 'coMma';
                            } else {
                                tmpsay = 'COMMA Response from ' + wrksect +' Not SetUp';
                                console.log ('\n\nKey Count: ' + keyCT + '\n(95823) This ' + tmpsay + '.\n\t\t'+orig.substring(k0-10, k0+10)+'\nLast: ' + lookL[9] + '\nNext: ' + lookR[9]);
                                if (k0 > cks && k0 < cke && tmpsay != '') {
                                    sayIt(tmpsay + ' Line ' + k0);
                                };
                            };
                        } else if ((['&#39;}','&#34;}'].indexOf(lookL[6]) != -1 && [', &#39;',', &#34;'].indexOf(lookR[7]) != -1) || (["'}",'"}'].indexOf(lookL[2]) != -1 && [", '",', "'].indexOf(lookR[3]) != -1)) { // something wrong with factors... allowing through when it should not.
                            // console.log('\t\t\t\t*******Pick it up here ************');
                            // console.log(lookL[6] + '\t\tIndex: ' + ['&#39;}','&#34;}'].indexOf(lookL[6]));
                            // console.log(lookL[2] + '\t\tIndex: ' + ["'}",'"}'].indexOf(lookL[2]));
                            // console.log(lookR[7] + '\t\tIndex: ' + [', &#39;',', &#34;'].indexOf(lookR[7]));
                            // console.log(lookR[2] + '\t\tIndex: ' + ["'}",'"}'].indexOf(lookR[2]));
                            if (wrksect == 'clBrack') {
                                // acknowledge start new key
                                // console.log('are you sure?');

                                vewAct(k0, cks, cke, 9, 'actpt' + '\n' + orig.substring(actpt[actpt.length -1], k0));
                                valvalue = orig.substring(actpt[actpt.length - 1], k0);
                                actpt.push(k0);

                                adjval = cleaNewDic1Val(valvalue, k0);

                                vewAct(k0, cks, cke, 4, 'Key Count: ' + keyCT + '\tVALUE Value: ' + valvalue + '\nActions Points: ' + 'actpt');
                                vewAct(k0, cks, cke, 8, '\n\no\t' + adjval + '\to\n\n');


                                // note: Automatically remove the key and subtract count, plus else
                                // thekeys.push(adjval); // place value in total key variable
                                // pthKeys = curKeys; // path keys do not use the last location
                                // curKeys += ' <~> ' + adjval // start the key string observer
                                chKeys = conPath(curKeys); // all except the last, however last is present. not using last though
                                xit = false;
                                lct1 = -1;
                                lct2 = -1;
                                lct3 = -1;
                                lct4 = -1;
                                // --- end auto ---

                                // Auto Removal... note keyCT will deduct.
                                tmp1 = curKeys.lastIndexOf(" <~> "); // visual purpose
                                tmp2 = curKeys.substring(0, tmp1);
                                curKeys = tmp2;
                                keyCT--; // track the key count
                                // --- auto end

                                vewAct(k0, cks, cke, 26, '\n\t Drop Key... count: ' + keyCT + '\tKeys: ' + conPath(curKeys) + '\n');



                                vewAct(k0, cks, cke, 27, '\n\n<===== AcknowledgeStart of New Key (from Beginning) =====>\t' + thekeys[keyCT - 1]);// right now doing nothing..., must initiate actpt though
                                vewAct(k0, cks, cke, 11, result);
                                wrksect = 'coMma';
                            } else {
                                tmpsay = 'COMMA Response from ' + wrksect +' Not SetUp';
                                console.log ('\n\nKey Count: ' + keyCT + '\n(371682) This ' + tmpsay + '.\n\t\t'+orig.substring(k0-10, k0+10)+'\nLast: ' + lookL[9] + '\nNext: ' + lookR[9]);
                                if (k0 > cks && k0 < cke && tmpsay != '') {
                                    sayIt(tmpsay + ' Line ' + k0);
                                };
                            };
                        } else if (['&#39;]','&#34;]'].indexOf(lookL[6]) != -1 && [', u&#39;',', u&#34;'].indexOf(lookR[8]) != -1) {
                            // drop down
                            if (wrksect == 'coMma') {
                                // acknowledge start new key
                                // console.log('are you sure?');

                                vewAct(k0, cks, cke, 9, 'actpt' + '\n' + orig.substring(actpt[actpt.length -1], k0));
                                valvalue = orig.substring(actpt[actpt.length - 1], k0);
                                actpt.push(k0);

                                adjval = cleaNewDic1Val(valvalue, k0);

                                vewAct(k0, cks, cke, 4, 'Key Count: ' + keyCT + '\tVALUE Value: ' + valvalue + '\nActions Points: ' + 'actpt');
                                vewAct(k0, cks, cke, 8, '\n\no\t' + adjval + '\to\n\n');


                                // note: Automatically remove the key and subtract count, plus else
                                // thekeys.push(adjval); // place value in total key variable
                                // pthKeys = curKeys; // path keys do not use the last location
                                // curKeys += ' <~> ' + adjval // start the key string observer
                                chKeys = conPath(curKeys); // all except the last, however last is present. not using last though
                                xit = false;
                                lct1 = -1;
                                lct2 = -1;
                                lct3 = -1;
                                lct4 = -1;
                                // --- end auto ---

                                // Auto Removal... note keyCT will deduct.
                                tmp1 = curKeys.lastIndexOf(" <~> "); // visual purpose
                                tmp2 = curKeys.substring(0, tmp1);
                                curKeys = tmp2;
                                keyCT--; // track the key count
                                // --- auto end

                                vewAct(k0, cks, cke, 26, '\n\t Drop Key... count: ' + keyCT + '\tKeys: ' + conPath(curKeys) + '\n');



                                vewAct(k0, cks, cke, 27, '\n\n<===== AcknowledgeStart of New Key (from Beginning) =====>\t' + thekeys[keyCT - 1]);// right now doing nothing..., must initiate actpt though
                                vewAct(k0, cks, cke, 11, result);
                                wrksect = 'coMma';
                            } else {
                                tmpsay = 'COMMA Response from ' + wrksect +' Not SetUp';
                                console.log ('\n\nKey Count: ' + keyCT + '\n(374682) This ' + tmpsay + '.\n\t\t'+orig.substring(k0-10, k0+10)+'\nLast: ' + lookL[9] + '\nNext: ' + lookR[9]);
                                if (k0 > cks && k0 < cke && tmpsay != '') {
                                    sayIt(tmpsay + ' Line ' + k0);
                                };
                            };

                        } else if ((['&#39;','&#34;'].indexOf(lookL[5]) != -1 && [', &#39;',', &#34;'].indexOf(lookR[7]) != -1) || (["'",'"'].indexOf(lookL[1]) != -1 && [", '",', "'].indexOf(lookR[3]) != -1)) {
                            // obtain the value
                            // add value as array
                            if (wrksect == 'opSquare') {
                                vewAct(k0, cks, cke, 9, 'actpt' + '\n' + orig.substring(actpt[actpt.length -1], k0));
                                valvalue = orig.substring(actpt[actpt.length - 1], k0);
                                actpt.push(k0);

                                adjval = cleaNewDic1Val(valvalue, k0);

                                vewAct(k0, cks, cke, 4, 'Key Count: ' + keyCT + '\tVALUE Value: ' + valvalue + '\nActions Points: ' + 'actpt');
                                vewAct(k0, cks, cke, 8, '\n\no\t' + adjval + '\to\n\n');


                                // note: Automatically remove the key and subtract count, plus else
                                // thekeys.push(adjval); // place value in total key variable
                                // pthKeys = curKeys; // path keys do not use the last location
                                // curKeys += ' <~> ' + adjval // start the key string observer
                                chKeys = conPath(curKeys); // all except the last, however last is present. not using last though
                                xit = false;
                                lct1 = -1;
                                lct2 = -1;
                                lct3 = -1;
                                lct4 = -1;
                                // --- end auto ---

                                if (keyCT == 1) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                } else if (keyCT == 2) {
                                    tmpsay = '';
                                    // tmpsay = 'Working IN: ' + sect + ' Section, area: ' + wrksect + ', Key Count: ' + keyCT;
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1: ' + result[a]);
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found 2: ' + result[lct1][b]);
                                                    lct2++;
                                                    result[lct1][lct2].push(adjval);
                                                    xit = true;
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };

                                } else if (keyCT == 3) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                } else if (keyCT == 4) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                } else if (keyCT == 5) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                } else if (keyCT == 6) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                } else if (keyCT == 7) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                } else {
                                    tmpsay = 'Section NONE Not Setup';
                                };
                                //} else if ([].indexOf(lookL[]) != -1 && [].indexOf(lookR[]) != -1) {
                                if (k0 > cks && k0 < cke && tmpsay != '') {
                                    sayIt(tmpsay + ' Line ' + k0);
                                    vewAct(k0, cks, cke, 17, '<<' + tmpsay +'>>');
                                };


                                // --- auto removal... None to remove

                                vewAct(k0,cks, cke, 10, '\n\nAdjustments: ===C=O=P=Y==>\tKeys: ' + conPath(curKeys) + '\n' + 'result' + '\n\n');
                                vewAct(k0, cks, cke, 11, result);
                                wrksect = 'coMma';
                            } else if (wrksect == 'coMma') {
                                vewAct(k0, cks, cke, 9, 'actpt' + '\n' + orig.substring(actpt[actpt.length -1], k0));
                                valvalue = orig.substring(actpt[actpt.length - 1], k0);
                                actpt.push(k0);

                                adjval = cleaNewDic1Val(valvalue, k0);

                                vewAct(k0, cks, cke, 4, 'Key Count: ' + keyCT + '\tVALUE Value: ' + valvalue + '\nActions Points: ' + 'actpt');
                                vewAct(k0, cks, cke, 8, '\n\no\t' + adjval + '\to\n\n');


                                // note: Automatically remove the key and subtract count, plus else
                                // thekeys.push(adjval); // place value in total key variable
                                // pthKeys = curKeys; // path keys do not use the last location
                                // curKeys += ' <~> ' + adjval // start the key string observer
                                chKeys = conPath(curKeys); // all except the last, however last is present. not using last though
                                xit = false;
                                lct1 = -1;
                                lct2 = -1;
                                lct3 = -1;
                                lct4 = -1;
                                // --- end auto ---

                                if (keyCT == 1) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                } else if (keyCT == 2) {
                                    tmpsay = '';
                                    // tmpsay = 'Working IN: ' + sect + ' Section, area: ' + wrksect + ', Key Count: ' + keyCT;
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1: ' + result[a]);
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found 2: ' + result[lct1][b]);
                                                    lct2++;
                                                    result[lct1][lct2].push(adjval);
                                                    xit = true;
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };

                                } else if (keyCT == 3) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                } else if (keyCT == 4) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                } else if (keyCT == 5) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                } else if (keyCT == 6) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                } else if (keyCT == 7) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                } else {
                                    tmpsay = 'Section NONE Not Setup';
                                };
                                //} else if ([].indexOf(lookL[]) != -1 && [].indexOf(lookR[]) != -1) {
                                if (k0 > cks && k0 < cke && tmpsay != '') {
                                    sayIt(tmpsay + ' Line ' + k0);
                                    vewAct(k0, cks, cke, 17, '<<' + tmpsay +'>>');
                                };


                                // --- auto removal... None to remove

                                vewAct(k0,cks, cke, 10, '\n\nAdjustments: ===C=O=P=Y==>\tKeys: ' + conPath(curKeys) + '\n' + 'result' + '\n\n');
                                vewAct(k0, cks, cke, 11, result);
                                wrksect = 'coMma';

                            } else {
                                tmpsay = 'COMMA Response from ' + wrksect +' Not SetUp';
                                console.log ('\n\nKey Count: ' + keyCT + '\n(47823) This ' + tmpsay + '.\n\t\t'+orig.substring(k0-10, k0+10)+'\nLast: ' + lookL[9] + '\nNext: ' + lookR[9]);
                                if (k0 > cks && k0 < cke && tmpsay != '') {
                                    sayIt(tmpsay + ' Line ' + k0);
                                };
                            };
                        } else if (['&#39;}}}','&#34;}}}'].indexOf(lookL[8]) != -1 && [', u&#39;',', u&#34;'].indexOf(lookR[8]) != -1) {
                            // This should not be a passable comma.
                            if (wrksect == 'clBrack') {
                                // acknowledge start new key
                                // console.log('are you sure?');

                                vewAct(k0, cks, cke, 9, 'actpt' + '\n' + orig.substring(actpt[actpt.length -1], k0));
                                valvalue = orig.substring(actpt[actpt.length - 1], k0);
                                actpt.push(k0);

                                adjval = cleaNewDic1Val(valvalue, k0);

                                vewAct(k0, cks, cke, 4, 'Key Count: ' + keyCT + '\tVALUE Value: ' + valvalue + '\nActions Points: ' + 'actpt');
                                vewAct(k0, cks, cke, 8, '\n\no\t' + adjval + '\to\n\n');


                                // note: Automatically remove the key and subtract count, plus else
                                // thekeys.push(adjval); // place value in total key variable
                                // pthKeys = curKeys; // path keys do not use the last location
                                // curKeys += ' <~> ' + adjval // start the key string observer
                                chKeys = conPath(curKeys); // all except the last, however last is present. not using last though
                                xit = false;
                                lct1 = -1;
                                lct2 = -1;
                                lct3 = -1;
                                lct4 = -1;
                                // --- end auto ---

                                // Auto Removal... note keyCT will deduct.
                                tmp1 = curKeys.lastIndexOf(" <~> "); // visual purpose
                                tmp2 = curKeys.substring(0, tmp1);
                                curKeys = tmp2;
                                keyCT--; // track the key count
                                // --- auto end

                                vewAct(k0, cks, cke, 26, '\n\t Drop Key... count: ' + keyCT + '\tKeys: ' + conPath(curKeys) + '\n');



                                vewAct(k0, cks, cke, 27, '\n\n<===== AcknowledgeStart of New Key (from Beginning) =====>\t' + thekeys[keyCT - 1]);// right now doing nothing..., must initiate actpt though
                                vewAct(k0, cks, cke, 11, result);
                                wrksect = 'coMma';
                            } else {
                                tmpsay = 'COMMA Response from ' + wrksect +' Not SetUp';
                                console.log ('\n\nKey Count: ' + keyCT + '\n(330682) This ' + tmpsay + '.\n\t\t'+orig.substring(k0-10, k0+10)+'\nLast: ' + lookL[9] + '\nNext: ' + lookR[9]);
                                if (k0 > cks && k0 < cke && tmpsay != '') {
                                    sayIt(tmpsay + ' Line ' + k0);
                                };
                            };
                        } else if (EngNum.indexOf(lookL[1]) != -1 && spComKar2.indexOf(lookR[3]) != -1) {
                            // similar to a comma between date, year
                            vewAct(k0,cks, cke, 33, '-->\tPassable COMMA 1\t<--');
                        } else if (spComKar1.indexOf(lookL[1]) != -1 && spComKar2.indexOf(lookR[3]) != -1) {
                            // similar to a comma between date, year
                            vewAct(k0,cks, cke, 33, '-->\tPassable COMMA 2 \t<--');
                        } else if (['}'].indexOf(lookL[1]) != -1 && [', '].indexOf(lookR[2]) != -1) {
                            // comma part of the string
                            vewAct(k0,cks, cke, 33, '-->\tPassable COMMA 3\t<--');
                        } else if (EngNum.indexOf(lookL[1]) != -1 && EngComNum.indexOf(lookR[2]) != -1) {
                            // similar to a comma between date, year
                            vewAct(k0, cks, cke, 34, '-->\tComma Between Two Numbers... Passable\t<--');
                        // } else if (speChk(lookL[5]) == false && speChk(lookR[6]) == true){
                        //     if (['coLon'].indexOf(wrksect) != -1) {
                        //         vewAct(k0, cks, cke, 'Non-Important Comma;\tSkip this...\n -->\tPassable COMMA 4\t<--');
                        //     };
                        //     // wrksect = 'opSquare'; don't change position.
                        // } else if (speChk(lookL[5]) == false && speChk(lookR[6]) == false) {
                        //     if (['coLon'].indexOf(wrksect) != -1) {
                        //         vewAct(k0, cks, cke, 'Non-Important Comma;\tSkip this...\n -->\tPassable COMMA 5\t<--');
                        //     };
                        } else if (passableChk(lookL[0],'Jadeilmnorsy .','BCDJR&#394 admnory',viewpos)) {
                            // passable comma brackets MyModel
                            console.log('\nNon-Important Comma;\tSkip this...\n -->\tPassable COMMA 4\t<--\n'+viewpos);
                        } else {
                            tmpsay = "Comma Instructions Not Setup\t\tLine: " + k0;
                            console.log('\n\t\t\t*************************************************************');
                            console.log('\t\t\t*\t' + tmpsay + '\t\t*' );
                            console.log('\t\t\t*\t\t' + viewpos + '\t*');
                            console.log('\t\t\t*************************************************************\n');
                            tmp = passableChk(lookL[0],'Jadeilmnorsy .','BCDJR&#394 admnory',viewpos);
                            if (k0 > cks && k0 < cke && tmpsay != '') {
                                sayIt(tmpsay);
                            };
                        };
                    } else if (lookL[0] == '}') {
                        // cleanNewDicVal here causing the artist on the tag to not work
                        // close bracket: for ending a value and/or starting a new key
                        sect = 'Close Bracket';
                        vewAct(k0, cks, cke, 6, '\nWork Section: ' + wrksect + '\n' + lookL[5] + '\t\tClose Bracket View\t\t' + lookR[8]);
                        if (['&#39;}}','&#34;}}'].indexOf(lookL[7]) != -1 && ['}, u&#39;','}, u&#34;'].indexOf(lookR[9]) != -1) {
                            if (wrksect == 'clBrack'){
                                // after storing arrays value, this portion need to do nothing. values was already stored.
                                vewAct(k0, cks, cke, 9, 'actpt' + '\n' + orig.substring(actpt[actpt.length -1], k0));
                                valvalue = orig.substring(actpt[actpt.length - 1], k0);
                                actpt.push(k0);

                                adjval = cleaNewDic1Val(valvalue, k0);

                                vewAct(k0, cks, cke, 4, 'Key Count: ' + keyCT + '\tVALUE Value: ' + valvalue + '\nActions Points: ' + 'actpt');
                                vewAct(k0, cks, cke, 8, '\n\no\t' + adjval + '\to\n\n');


                                // note: Automatically remove the key and subtract count, plus else
                                // thekeys.push(adjval); // place value in total key variable
                                // pthKeys = curKeys; // path keys do not use the last location
                                // curKeys += ' <~> ' + adjval // start the key string observer
                                chKeys = conPath(curKeys); // all except the last, however last is present. not using last though
                                xit = false;
                                lct1 = -1;
                                lct2 = -1;
                                lct3 = -1;
                                lct4 = -1;
                                // --- end auto ---

                                // Auto Removal... note keyCT will deduct.
                                tmp1 = curKeys.lastIndexOf(" <~> "); // visual purpose
                                tmp2 = curKeys.substring(0, tmp1);
                                curKeys = tmp2;
                                keyCT--; // track the key count
                                // --- auto end

                                vewAct(k0, cks, cke, 26, '\n\t Drop Key... count: ' + keyCT + '\tKeys: ' + conPath(curKeys) + '\n');

                                vewAct(k0,cks, cke, 10, '\n\nAdjustments: ^^C^O^P^Y^^>\tKeys: ' + conPath(curKeys) + '\n' + 'result' + '\n\n');
                                vewAct(k0, cks, cke, 11, result);
                                wrksect = 'clBrack';

                            } else {
                                tmpsay = 'Close Bracket Response from ' + wrksect +' Not SetUp';
                                console.log ('\n\nKey Count: ' + keyCT + '\n(379882) This ' + tmpsay + '.\n\t\t'+orig.substring(k0-10, k0+10)+'\nLast: ' + lookL[9] + '\nNext: ' + lookR[9]);
                                if (k0 > cks && k0 < cke && tmpsay != '') {
                                    sayIt(tmpsay + ' Line ' + k0);
                                };
                            };
                        } else if ((['&#39;]','&#34;]'].indexOf(lookL[6]) != -1 && ["}, &#39;",'}, &#34;'].indexOf(lookR[8]) != -1) || (["']",'"]'].indexOf(lookL[2]) != -1 && ["}, '",'}, "'].indexOf(lookR[4]) != -1)) {
                            if (wrksect == 'clSquare'){
                                // after storing arrays value, this portion need to do nothing. values was already stored.
                                vewAct(k0, cks, cke, 9, 'actpt' + '\n' + orig.substring(actpt[actpt.length -1], k0));
                                valvalue = orig.substring(actpt[actpt.length - 1], k0);
                                actpt.push(k0);

                                adjval = cleaNewDic1Val(valvalue, k0);

                                vewAct(k0, cks, cke, 4, 'Key Count: ' + keyCT + '\tVALUE Value: ' + valvalue + '\nActions Points: ' + 'actpt');
                                vewAct(k0, cks, cke, 8, '\n\no\t' + adjval + '\to\n\n');


                                // note: Automatically remove the key and subtract count, plus else
                                // thekeys.push(adjval); // place value in total key variable
                                // pthKeys = curKeys; // path keys do not use the last location
                                // curKeys += ' <~> ' + adjval // start the key string observer
                                chKeys = conPath(curKeys); // all except the last, however last is present. not using last though
                                xit = false;
                                lct1 = -1;
                                lct2 = -1;
                                lct3 = -1;
                                lct4 = -1;
                                // --- end auto ---

                                // Auto Removal... note keyCT will deduct.
                                tmp1 = curKeys.lastIndexOf(" <~> "); // visual purpose
                                tmp2 = curKeys.substring(0, tmp1);
                                curKeys = tmp2;
                                keyCT--; // track the key count
                                // --- auto end

                                vewAct(k0, cks, cke, 26, '\n\t Drop Key... count: ' + keyCT + '\tKeys: ' + conPath(curKeys) + '\n');

                                vewAct(k0,cks, cke, 10, '\n\nAdjustments: ^^C^O^P^Y^^>\tKeys: ' + conPath(curKeys) + '\n' + 'result' + '\n\n');
                                vewAct(k0, cks, cke, 11, result);
                                wrksect = 'clBrack';
                            } else {
                                tmpsay = 'Close Bracket Response from ' + wrksect +' Not SetUp';
                                console.log ('\n\nKey Count: ' + keyCT + '\n(370782) This ' + tmpsay + '.\n\t\t'+orig.substring(k0-10, k0+10)+'\nLast: ' + lookL[9] + '\nNext: ' + lookR[9]);
                                if (k0 > cks && k0 < cke && tmpsay != '') {
                                    sayIt(tmpsay + ' Line ' + k0);
                                };
                            };
                        } else if ((['&#39;','&#34;'].indexOf(lookL[5]) != -1 && ['}, u&#39;','}, u&#34;'].indexOf(lookR[9]) != -1) ||
                            (["'",'"'].indexOf(lookL[1]) != -1 && ["}, u'",'}, u"'].indexOf(lookR[5]) != -1)) {
                            // console.log('\t\t\t\t*******Pick it up here ************');
                            // console.log(lookL[1] + '\t\tIndex: ' + ["'",'"'].indexOf(lookL[1]));
                            // console.log(lookL[5] + '\t\tIndex: ' + ['&#39;','&#34;'].indexOf(lookL[5]));
                            // console.log(lookR[8] + '\t\tIndex: ' + ['}, u&#39;','}, u&#34;'].indexOf(lookR[9]));
                            // console.log(lookR[4] + '\t\tIndex: ' + ["}, '",'}, "'].indexOf(lookR[4]));
                            if (wrksect == 'coLon') {
                                // storing value, plus drop key count by 1 after storing value
                                vewAct(k0, cks, cke, 9, 'actpt' + '\n' + orig.substring(actpt[actpt.length -1], k0));
                                valvalue = orig.substring(actpt[actpt.length - 1], k0);
                                actpt.push(k0);

                                adjval = cleaNewDic1Val(valvalue, k0);

                                vewAct(k0, cks, cke, 4, 'Key Count: ' + keyCT + '\tVALUE Value: ' + valvalue + '\nActions Points: ' + 'actpt');
                                vewAct(k0, cks, cke, 8, '\n\no\t' + adjval + '\to\n\n');


                                // note: Automatically remove the key and subtract count, plus else
                                // thekeys.push(adjval); // place value in total key variable
                                // pthKeys = curKeys; // path keys do not use the last location
                                // curKeys += ' <~> ' + adjval // start the key string observer
                                chKeys = conPath(curKeys); // all except the last, however last is present. not using last though
                                xit = false;
                                lct1 = -1;
                                lct2 = -1;
                                lct3 = -1;
                                lct4 = -1;
                                // --- end auto ---


                                if (keyCT == 1) {
                                    vewAct(k0, cks, cke, 23, '<< Location Section 1>>');
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1');
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    lct2++;
                                                    result[lct1][lct2].push(adjval);
                                                xit = true;
                                                break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };
                                } else if (keyCT == 2) {
                                    vewAct(k0, cks, cke, 23, '<< Location Section 2>>');
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1: ' + result[a]);
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found 2: ' + result[lct1][b]);
                                                    lct2++;
                                                    result[lct1][lct2].push(adjval);
                                                xit = true;
                                                break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };

                                    // vewAct(k0, cks, cke, 18, '<<Section 2 Working ON #830 >>\t' + chKeys);
                                } else if (keyCT == 3) {
                                    // result[1].push([valvalue.substring(1, valvalue.length -1)]);
                                    vewAct(k0, cks, cke, 18, '<<Section 3 Not Setup>>');
                                } else if (keyCT == 4) {
                                    vewAct(k0, cks, cke, 23, '<< Location Section 4>>');
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1');
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found 2');
                                                    lct2++;
                                                    for (c in result[lct1][lct2]) {
                                                        lct3++;
                                                        if (result[lct1][lct2][c] == chKeys[2]) {
                                                            // console.log('Found 3');
                                                            lct3++;
                                                            for (d in result[lct1][lct2][lct3]) {
                                                                lct4++;
                                                                // cant get key loc #2 all will go there
                                                                // console.log('\n\nShow Me the Keys: ' + curKeys);
                                                                if (result[lct1][lct2][lct3][d] == chKeys[3]) {
                                                                    // console.log('Found it: ' + result[lct1][lct2][lct3][d]);
                                                                    // console.log('last key: ' + thekeys[thekeys.length - 1]);
                                                                    lct4++;
                                                                    result[lct1][lct2][lct3][lct4].push( adjval ); // adding just the value
                                                                    xit = true;
                                                                    break;
                                                                };
                                                            };
                                                        };
                                                        if (xit == true) {
                                                            break;
                                                        };
                                                    };
                                                };
                                                if (xit == true) {
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };
                                };

                                // Auto Removal... note keyCT will deduct.
                                tmp1 = curKeys.lastIndexOf(" <~> "); // visual purpose
                                tmp2 = curKeys.substring(0, tmp1);
                                curKeys = tmp2;
                                keyCT--; // track the key count
                                // --- auto end

                                vewAct(k0, cks, cke, 26, '\n\t Drop Key... count: ' + keyCT + '\tKeys: ' + conPath(curKeys) + '\n');

                                vewAct(k0,cks, cke, 10, '\n\nAdjustments: ^^^^^^>\tKeys: ' + conPath(curKeys) + '\n' + 'result' + '\n\n');
                                vewAct(k0, cks, cke, 11, result);
                                wrksect = 'clBrack';
                            } else if (wrksect == 'clSquare'){
                                // after storing arrays value, this portion need to do nothing. values was already stored.
                                vewAct(k0, cks, cke, 9, 'actpt' + '\n' + orig.substring(actpt[actpt.length -1], k0));
                                valvalue = orig.substring(actpt[actpt.length - 1], k0);
                                actpt.push(k0);

                                adjval = cleaNewDic1Val(valvalue, k0);

                                vewAct(k0, cks, cke, 4, 'Key Count: ' + keyCT + '\tVALUE Value: ' + valvalue + '\nActions Points: ' + 'actpt');
                                vewAct(k0, cks, cke, 8, '\n\no\t' + adjval + '\to\n\n');


                                // note: Automatically remove the key and subtract count, plus else
                                // thekeys.push(adjval); // place value in total key variable
                                // pthKeys = curKeys; // path keys do not use the last location
                                // curKeys += ' <~> ' + adjval // start the key string observer
                                chKeys = conPath(curKeys); // all except the last, however last is present. not using last though
                                xit = false;
                                lct1 = -1;
                                lct2 = -1;
                                lct3 = -1;
                                lct4 = -1;
                                // --- end auto ---

                                // Auto Removal... note keyCT will deduct.
                                tmp1 = curKeys.lastIndexOf(" <~> "); // visual purpose
                                tmp2 = curKeys.substring(0, tmp1);
                                curKeys = tmp2;
                                keyCT--; // track the key count
                                // --- auto end

                                vewAct(k0, cks, cke, 26, '\n\t Drop Key... count: ' + keyCT + '\tKeys: ' + conPath(curKeys) + '\n');

                                vewAct(k0,cks, cke, 10, '\n\nAdjustments: ^^C^O^P^Y^^>\tKeys: ' + conPath(curKeys) + '\n' + 'result' + '\n\n');
                                vewAct(k0, cks, cke, 11, result);
                                wrksect = 'clBrack';
                            } else if (wrksect == 'clBrack'){
                                // after storing arrays value, this portion need to do nothing. values was already stored.
                                vewAct(k0, cks, cke, 9, 'actpt' + '\n' + orig.substring(actpt[actpt.length -1], k0));
                                valvalue = orig.substring(actpt[actpt.length - 1], k0);
                                actpt.push(k0);

                                adjval = cleaNewDic1Val(valvalue, k0);

                                vewAct(k0, cks, cke, 4, 'Key Count: ' + keyCT + '\tVALUE Value: ' + valvalue + '\nActions Points: ' + 'actpt');
                                vewAct(k0, cks, cke, 8, '\n\no\t' + adjval + '\to\n\n');


                                // note: Automatically remove the key and subtract count, plus else
                                // thekeys.push(adjval); // place value in total key variable
                                // pthKeys = curKeys; // path keys do not use the last location
                                // curKeys += ' <~> ' + adjval // start the key string observer
                                chKeys = conPath(curKeys); // all except the last, however last is present. not using last though
                                xit = false;
                                lct1 = -1;
                                lct2 = -1;
                                lct3 = -1;
                                lct4 = -1;
                                // --- end auto ---

                                // Auto Removal... note keyCT will deduct.
                                tmp1 = curKeys.lastIndexOf(" <~> "); // visual purpose
                                tmp2 = curKeys.substring(0, tmp1);
                                curKeys = tmp2;
                                keyCT--; // track the key count
                                // --- auto end

                                vewAct(k0, cks, cke, 26, '\n\t Drop Key... count: ' + keyCT + '\tKeys: ' + conPath(curKeys) + '\n');

                                vewAct(k0,cks, cke, 10, '\n\nAdjustments: ^^C^O^P^Y^^>\tKeys: ' + conPath(curKeys) + '\n' + 'result' + '\n\n');
                                vewAct(k0, cks, cke, 11, result);
                                wrksect = 'clBrack';


                            } else {
                                tmpsay = 'Close Bracket Response from ' + wrksect +' Not SetUp';
                                console.log ('\n\nKey Count: ' + keyCT + '\n(37882) This ' + tmpsay + '.\n\t\t'+orig.substring(k0-10, k0+10)+'\nLast: ' + lookL[9] + '\nNext: ' + lookR[9]);
                                if (k0 > cks && k0 < cke && tmpsay != '') {
                                    sayIt(tmpsay + ' Line ' + k0);
                                };
                            };
                        } else if ((['&#39;','&#34;'].indexOf(lookL[5]) != -1 && ['}, &#39;','}, &#34;'].indexOf(lookR[8]) != -1) ||
                            (["'",'"'].indexOf(lookL[1]) != -1 && ["}, '",'}, "'].indexOf(lookR[4]) != -1)) {
                            // console.log('\t\t\t\t*******Pick it up here ************');
                            // console.log(lookL[1] + '\t\tIndex: ' + ["'",'"'].indexOf(lookL[1]));
                            // console.log(lookL[5] + '\t\tIndex: ' + ['&#39;','&#34;'].indexOf(lookL[5]));
                            // console.log(lookR[8] + '\t\tIndex: ' + ['}, u&#39;','}, u&#34;'].indexOf(lookR[9]));
                            // console.log(lookR[4] + '\t\tIndex: ' + ["}, '",'}, "'].indexOf(lookR[4]));
                            if (wrksect == 'coLon') {
                                // storing value, plus drop key count by 1 after storing value
                                vewAct(k0, cks, cke, 9, 'actpt' + '\n' + orig.substring(actpt[actpt.length -1], k0));
                                valvalue = orig.substring(actpt[actpt.length - 1], k0);
                                actpt.push(k0);

                                adjval = cleaNewDic1Val(valvalue, k0);

                                vewAct(k0, cks, cke, 4, 'Key Count: ' + keyCT + '\tVALUE Value: ' + valvalue + '\nActions Points: ' + 'actpt');
                                vewAct(k0, cks, cke, 8, '\n\no\t' + adjval + '\to\n\n');


                                // note: Automatically remove the key and subtract count, plus else
                                // thekeys.push(adjval); // place value in total key variable
                                // pthKeys = curKeys; // path keys do not use the last location
                                // curKeys += ' <~> ' + adjval // start the key string observer
                                chKeys = conPath(curKeys); // all except the last, however last is present. not using last though
                                xit = false;
                                lct1 = -1;
                                lct2 = -1;
                                lct3 = -1;
                                lct4 = -1;
                                lct5 = -1;
                                lct6 = -1;
                                lct7 = -1;
                                lct8 = -1;
                                // --- end auto ---


                                if (keyCT == 1) {
                                    tmpsay = "";
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1');
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    lct2++;
                                                    result[lct1][lct2].push(adjval);
                                                xit = true;
                                                break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };
                                } else if (keyCT == 2) {
                                    tmpsay = "";
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1: ' + result[a]);
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found 2: ' + result[lct1][b]);
                                                    lct2++;
                                                    result[lct1][lct2].push(adjval);
                                                xit = true;
                                                break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };

                                    // vewAct(k0, cks, cke, 18, '<<Section 2 Working ON #830 >>\t' + chKeys);
                                } else if (keyCT == 3) {
                                    // result[1].push([valvalue.substring(1, valvalue.length -1)]);
                                    // vewAct(k0, cks, cke, 18, '<<Section !3! Not Setup>>');
                                    tmpsay = "";
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1: ' + result[a]);
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found 2: ' + result[lct1][b]);
                                                    lct2++;
                                                    for (c in result[lct1][lct2]) {
                                                        lct3++;
                                                        if (result[lct1][lct2][c] == chKeys[2]) {
                                                            lct3++;
                                                            result[lct1][lct2][lct3].push( adjval );
                                                            xit = true;
                                                            break;
                                                        };
                                                    };
                                                };
                                                if (xit == true) {
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };
                                } else if (keyCT == 4) {
                                    tmpsay = "";
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1');
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found 2');
                                                    lct2++;
                                                    for (c in result[lct1][lct2]) {
                                                        lct3++;
                                                        if (result[lct1][lct2][c] == chKeys[2]) {
                                                            // console.log('Found 3');
                                                            lct3++;
                                                            for (d in result[lct1][lct2][lct3]) {
                                                                lct4++;
                                                                // cant get key loc #2 all will go there
                                                                // console.log('\n\nShow Me the Keys: ' + curKeys);
                                                                if (result[lct1][lct2][lct3][d] == chKeys[3]) {
                                                                    // console.log('Found it: ' + result[lct1][lct2][lct3][d]);
                                                                    // console.log('last key: ' + thekeys[thekeys.length - 1]);
                                                                    lct4++;
                                                                    result[lct1][lct2][lct3][lct4].push( adjval ); // adding just the value
                                                                    xit = true;
                                                                    break;
                                                                };
                                                            };
                                                        };
                                                        if (xit == true) {
                                                            break;
                                                        };
                                                    };
                                                };
                                                if (xit == true) {
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };
                                };

                                // Auto Removal... note keyCT will deduct.
                                tmp1 = curKeys.lastIndexOf(" <~> "); // visual purpose
                                tmp2 = curKeys.substring(0, tmp1);
                                curKeys = tmp2;
                                keyCT--; // track the key count


                                if (k0 > cks && k0 < cke && tmpsay != '') {
                                    sayIt(tmpsay + ' Line ' + k0);
                                    vewAct(k0, cks, cke, 17, '<<' + tmpsay +'>>');
                                };

                                vewAct(k0, cks, cke, 26, '\n\t Drop Key... count: ' + keyCT + '\tKeys: ' + conPath(curKeys) + '\n');
                                vewAct(k0, cks, cke, 10, '\n\nAdjustments: ^^C^O^P^Y^^>\tKeys: ' + conPath(curKeys) + '\n' + 'result' + '\n\n');
                                vewAct(k0, cks, cke, 11, result);
                                wrksect = 'clBrack';
                                wrksqre = false;
                            } else if (wrksect == 'clSquare'){
                                // after storing arrays value, this portion need to do nothing. values was already stored.
                                vewAct(k0, cks, cke, 9, 'actpt' + '\n' + orig.substring(actpt[actpt.length -1], k0));
                                valvalue = orig.substring(actpt[actpt.length - 1], k0);
                                actpt.push(k0);

                                adjval = cleaNewDic1Val(valvalue, k0);

                                vewAct(k0, cks, cke, 4, 'Key Count: ' + keyCT + '\tVALUE Value: ' + valvalue + '\nActions Points: ' + 'actpt');
                                vewAct(k0, cks, cke, 8, '\n\no\t' + adjval + '\to\n\n');


                                // note: Automatically remove the key and subtract count, plus else
                                // thekeys.push(adjval); // place value in total key variable
                                // pthKeys = curKeys; // path keys do not use the last location
                                // curKeys += ' <~> ' + adjval // start the key string observer
                                chKeys = conPath(curKeys); // all except the last, however last is present. not using last though
                                xit = false;
                                lct1 = -1;
                                lct2 = -1;
                                lct3 = -1;
                                lct4 = -1;
                                // --- end auto ---

                                // Auto Removal... note keyCT will deduct.
                                tmp1 = curKeys.lastIndexOf(" <~> "); // visual purpose
                                tmp2 = curKeys.substring(0, tmp1);
                                curKeys = tmp2;
                                keyCT--; // track the key count
                                // --- auto end

                                vewAct(k0, cks, cke, 26, '\n\t Drop Key... count: ' + keyCT + '\tKeys: ' + conPath(curKeys) + '\n');

                                vewAct(k0,cks, cke, 10, '\n\nAdjustments: ^^C^O^P^Y^^>\tKeys: ' + conPath(curKeys) + '\n' + 'result' + '\n\n');
                                vewAct(k0, cks, cke, 11, result);
                                wrksect = 'clBrack';
                            } else if (wrksect == 'clBrack'){
                                // after storing arrays value, this portion need to do nothing. values was already stored.
                                vewAct(k0, cks, cke, 9, 'actpt' + '\n' + orig.substring(actpt[actpt.length -1], k0));
                                valvalue = orig.substring(actpt[actpt.length - 1], k0);
                                actpt.push(k0);

                                adjval = cleaNewDic1Val(valvalue, k0);

                                vewAct(k0, cks, cke, 4, 'Key Count: ' + keyCT + '\tVALUE Value: ' + valvalue + '\nActions Points: ' + 'actpt');
                                vewAct(k0, cks, cke, 8, '\n\no\t' + adjval + '\to\n\n');


                                // note: Automatically remove the key and subtract count, plus else
                                // thekeys.push(adjval); // place value in total key variable
                                // pthKeys = curKeys; // path keys do not use the last location
                                // curKeys += ' <~> ' + adjval // start the key string observer
                                chKeys = conPath(curKeys); // all except the last, however last is present. not using last though
                                xit = false;
                                lct1 = -1;
                                lct2 = -1;
                                lct3 = -1;
                                lct4 = -1;
                                // --- end auto ---

                                // Auto Removal... note keyCT will deduct.
                                tmp1 = curKeys.lastIndexOf(" <~> "); // visual purpose
                                tmp2 = curKeys.substring(0, tmp1);
                                curKeys = tmp2;
                                keyCT--; // track the key count
                                // --- auto end

                                vewAct(k0, cks, cke, 26, '\n\t Drop Key... count: ' + keyCT + '\tKeys: ' + conPath(curKeys) + '\n');

                                vewAct(k0,cks, cke, 10, '\n\nAdjustments: ^^C^O^P^Y^^>\tKeys: ' + conPath(curKeys) + '\n' + 'result' + '\n\n');
                                vewAct(k0, cks, cke, 11, result);
                                wrksect = 'clBrack';
                            } else {
                                tmpsay = 'Close Bracket Response from ' + wrksect +' Not SetUp';
                                console.log ('\n\nKey Count: ' + keyCT + '\n(37882) This ' + tmpsay + '.\n\t\t'+orig.substring(k0-10, k0+10)+'\nLast: ' + lookL[9] + '\nNext: ' + lookR[9]);
                                if (k0 > cks && k0 < cke && tmpsay != '') {
                                    sayIt(tmpsay + ' Line ' + k0);
                                };
                            };
                        } else if (['&#39;R', '&#34;R'].indexOf(lookL[5]) != -1 && ['}}R'].indexOf(lookR[2]) != -1) {
                            // console.log('\t\t\t\t*******Pick it up here72************'); // you have twice...
                            if (wrksect == 'opBrack') {
                                // coming from an open bracket
                            } else if (wrksect == 'coLon') {
                                // coming from colon
                                // obtain the value not prep to prep for <all>
                                vewAct(k0, cks, cke, 9, 'actpt' + '\n' + orig.substring(actpt[actpt.length -1], k0));
                                valvalue = orig.substring(actpt[actpt.length - 1], k0);
                                actpt.push(k0);

                                adjval = cleaNewDic1Val(valvalue, k0);

                                vewAct(k0, cks, cke, 4, 'Key Count: ' + keyCT + '\tVALUE Value: ' + valvalue + '\nActions Points: ' + 'actpt');
                                vewAct(k0, cks, cke, 8, '\n\no\t' + adjval + '\to\n\n');


                                // note: Automatically remove the key and subtract count, plus else
                                // thekeys.push(adjval); // place value in total key variable
                                // pthKeys = curKeys; // path keys do not use the last location
                                // curKeys += ' <~> ' + adjval // start the key string observer
                                chKeys = conPath(curKeys); // all except the last, however last is present. not using last though
                                xit = false;
                                lct1 = -1;
                                lct2 = -1;
                                lct3 = -1;
                                lct4 = -1;
                                // --- end auto ---

                                if (keyCT == 0) {
                                    vewAct(k0, cks, cke, 18, '<<Section 0 Not Setup>>');
                                    vewAct(k0, cks, cke, 36, '\n\n*>\tKeys: ' + conPath(curKeys) + '\n' + 'result' + '\n\n');
                                } else if (keyCT == 1) {
                                    // do a <all> process. this will get a key() and a value(), similar to  python
                                    // console.log(spcKey + '\tuse this key: ' + thekeys[spcKey]);
                                    vewAct(k0, cks, cke, 18, '<<Section 1 Not Setup>>');
                                    vewAct(k0, cks, cke, 36, '\n\n*>\tKeys: ' + conPath(curKeys) + '\n' + 'result' + '\n\n');
                                } else if (keyCT == 2) { // not sure if this is working properly, above is working corretly
                                    vewAct(k0, cks, cke, 23, '<< Location Section 2>>');
                                    // note: this check is from a four key entry... yes it skips one which is modified in the intital var
                                    for (a in result) { // checking the first array
                                        lct1++; // this brings the loop count to the key variable (string)
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) { // found the match, locate the key with search data
                                            // console.log('\tFound 1: ' + chKeys[0]);
                                            lct1++; // this brings the loop count to the value variable (array)
                                            for(b in result[lct1]) { // checking the second array
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('\tFound 2: ' + chKeys[1]);
                                                    lct2++;
                                                    result[lct1][lct2].push( adjval );
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };
                                    vewAct(k0, cks, cke, 36, '\n\n***>\tKeys: ' + conPath(curKeys) + '\n' + 'result' + '\n\n');
                                } else if (keyCT == 3) {
                                    vewAct(k0, cks, cke, 23, '<< Location Section 3>> Investigate');

                                    console.log('<< Location Section 3>> Investigate');
                                    // do a <all> process. this will get a key() and a value(), similar to  python
                                    for (a in result) { // checking the first array
                                        lct1++; // this brings the loop count to the key variable (string)
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) { // found the match, locate the key with search data
                                            // console.log('Found 1');
                                            lct1++; // this brings the loop count to the value variable (array)
                                            for(b in result[lct1]) { // checking the second array
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found 2');
                                                    lct2++;
                                                    // if (result[lct1][b] == chKeys[1]) { // doing a different way
                                                    //     // console.log('Found It: ' + result[lct1][b]); // show match was found
                                                    //     for (c in result[lct1][lct2]){ // cycle through the string and array
                                                    //         // console.log(result[lct1][lct2][c]);
                                                    //         ooe = oddOrEven(c); // odd string will be the string, even will be the array
                                                    //         if (ooe == 'odd') {
                                                    //             // console.log('ODD Found it: ' + result[lct1][lct2][c]);
                                                    //             allvalues += ' <V> ' + result[lct1][lct2][c]; // group all values
                                                    //         } else if (ooe == 'even') {
                                                    //             // console.log('EVEN found it: ' + result[lct1][lct2][c]);
                                                    //             allkeys += ' <K> ' + result[lct1][lct2][c]; // group all keys
                                                    //         };
                                                    //     };
                                                    //     result[lct1][lct2].push('<KEY>', [allkeys] ); // add all keys
                                                    //     result[lct1][lct2].push('<VALUE>', [allvalues] ); // add all values
                                                    //     xit = true;
                                                    //     break;
                                                    // };
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };
                                };

                                // Auto Removal... note keyCT will deduct.
                                tmp1 = curKeys.lastIndexOf(" <~> "); // visual purpose
                                tmp2 = curKeys.substring(0, tmp1);
                                curKeys = tmp2;
                                keyCT--; // track the key count
                                // --- auto end

                                vewAct(k0, cks, cke, 26, '\n\t Drop Key... count: ' + keyCT + '\tKeys: ' + conPath(curKeys) + '\n');

                                vewAct(k0,cks, cke, 10, '\n\nAdjustments: ^^C^O^P^Y^^>\tKeys: ' + conPath(curKeys) + '\n' + 'result' + '\n\n');
                                vewAct(k0, cks, cke, 11, result);
                                wrksect = 'clBrack';


                            } else if (wrksect == 'coMma') {
                                // coming from a comma
                            } else if (wrksect == 'clBrack') {
                                // coming from close bracket
                                console.log('\n\n-->\t' + thekeys);
                            } else {
                                console.log ('\n\nKey Count: ' + keyCT + '\n(4269162) This Close Bracket Response from ' + wrksect +' Not SetUp.\n\t\t'+orig.substring(k0-10, k0+10)+'\nLast: ' + lookL[9] + '\nNext: ' + lookR[9]);
                            };
                        } else if (['&#39;}','&#34;}'].indexOf(lookL[6]) != -1 && ['}, u&#39;','}, u&#34;'].indexOf(lookR[9]) != -1) {
                            // console.log('\t\t\t\t*******Pick it up here7************');
                            if (wrksect == 'clBrack') {
                                // Setup of <ALL>
                                vewAct(k0, cks, cke, 9, 'actpt' + '\n' + orig.substring(actpt[actpt.length -1], k0));
                                valvalue = orig.substring(actpt[actpt.length - 1], k0);
                                actpt.push(k0);

                                adjval = cleaNewDic1Val(valvalue, k0);

                                vewAct(k0, cks, cke, 4, 'Key Count: ' + keyCT + '\tVALUE Value: ' + valvalue + '\nActions Points: ' + 'actpt');
                                vewAct(k0, cks, cke, 8, '\n\no\t' + adjval + '\to\n\n');

                                // note: Automatically remove the key and subtract count, plus else
                                // thekeys.push(adjval); // place value in total key variable
                                // pthKeys = curKeys; // path keys do not use the last location
                                // curKeys += ' <~> ' + adjval // start the key string observer
                                chKeys = conPath(curKeys); // all except the last, however last is present. not using last though
                                xit = false;
                                lct1 = -1;
                                lct2 = -1;
                                lct3 = -1;
                                lct4 = -1;
                                // --- end auto ---

                                if (keyCT == 0) {
                                    vewAct(k0, cks, cke, 18, '<<Section 0 Not Setup>>');
                                    vewAct(k0, cks, cke, 36, '\n\n*>\tKeys: ' + conPath(curKeys) + '\n' + 'result' + '\n\n');
                                } else if (keyCT == 1) {
                                    // do a <all> process. this will get a key() and a value(), similar to  python
                                    // console.log(spcKey + '\tuse this key: ' + thekeys[spcKey]);
                                    vewAct(k0, cks, cke, 18, '<<Section 1 Not Setup>>');
                                    vewAct(k0, cks, cke, 36, '\n\n*>\tKeys: ' + conPath(curKeys) + '\n' + 'result' + '\n\n');
                                } else if (keyCT == 2) { // not sure if this is working properly, above is working corretly
                                    vewAct(k0, cks, cke, 23, '<< Location Section 2>>');
                                    // note: this check is from a four key entry... yes it skips one which is modified in the intital var
                                    // do a <all> process. this will get a key() and a value(), similar to  python
                                    console.log('check section to make sure its working correctly');
                                    for (a in result) { // checking the first array
                                        lct1++; // this brings the loop count to the key variable (string)
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) { // found the match, locate the key with search data
                                            // console.log('Found 1');
                                            lct1++; // this brings the loop count to the value variable (array)
                                            for(b in result[lct1]) { // checking the second array
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found 2');
                                                    lct2++;
                                                    console.log('<< Location Section 33>> Investigate');
                                                    // for (c in result[lct1][lct2]) {
                                                    //     lct3++;
                                                    //     // if (result[lct1][lct2][c] == thekeys[2]) { // locate the value, below will cycle through the key,value store them
                                                    //     //     console.log('Found 3 ' + result[lct1][lct2][c]);
                                                    //     //     allkeys = "";
                                                    //     //     allvalues = "";
                                                    //     //     lct3++;
                                                    //     //     for (d in result[lct1][lct2][lct3]) {
                                                    //     //         ooe = oddOrEven(d);
                                                    //     //         lct4++;
                                                    //     //         if (ooe == 'odd') {
                                                    //     //             // console.log('ODD Found it: ' + result[lct1][lct2][lct3][d]);
                                                    //     //             allvalues += ' <V> ' + result[lct1][lct2][lct3][d];
                                                    //     //         } else if (ooe == 'even') {
                                                    //     //             // console.log('EVEN found it: ' + result[lct1][lct2][lct3][d]);
                                                    //     //             allkeys += ' <K> ' + result[lct1][lct2][lct3][d];
                                                    //     //         };
                                                    //     //     };
                                                    //     //     result[lct1][lct2][lct3].push('<KEY>', [allkeys] ); // add all keys
                                                    //     //     result[lct1][lct2][lct3].push('<VALUE>', [allvalues] ); // add all values
                                                    //     //     xit = true;
                                                    //     //     break;
                                                    //     // };
                                                    // };
                                                    // if (xit == true) {
                                                    //     break;
                                                    // };
                                                };
                                            };
                                            if (xit == true) {
                                                break;
                                            };
                                        };
                                    };
                                    vewAct(k0, cks, cke, 36, '\n\n***>\tKeys: ' + conPath(curKeys) + '\n' + 'result' + '\n\n');
                                } else if (keyCT == 3) {
                                    vewAct(k0, cks, cke, 23, '<< Location Section 3>>');
                                    // do a <all> process. this will get a key() and a value(), similar to  python
                                    for (a in result) { // checking the first array
                                        lct1++; // this brings the loop count to the key variable (string)
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) { // found the match, locate the key with search data
                                            // console.log('Found 1');
                                            lct1++; // this brings the loop count to the value variable (array)
                                            for(b in result[lct1]) { // checking the second array
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found 2');
                                                    lct2++; // doing a different way
                                                    // if (result[lct1][b] == chKeys[1]) { // the key has to match special key, cause key is going backward out of dic
                                                    //     // console.log('Found It: ' + result[lct1][b]); // show match was found
                                                    //     for (c in result[lct1][lct2]){ // cycle through the string and array
                                                    //         // console.log(result[lct1][lct2][c]);
                                                    //         ooe = oddOrEven(c); // odd string will be the string, even will be the array
                                                    //         if (ooe == 'odd') {
                                                    //             // console.log('ODD Found it: ' + result[lct1][lct2][c]);
                                                    //             allvalues += ' <V> ' + result[lct1][lct2][c]; // group all values
                                                    //         } else if (ooe == 'even') {
                                                    //             // console.log('EVEN found it: ' + result[lct1][lct2][c]);
                                                    //             allkeys += ' <K> ' + result[lct1][lct2][c]; // group all keys
                                                    //         };
                                                    //     };
                                                    //     result[lct1][lct2].push('<KEY>', [allkeys] ); // add all keys
                                                    //     result[lct1][lct2].push('<VALUE>', [allvalues] ); // add all values
                                                    //     xit = true;
                                                    //     break;
                                                    // };
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };
                                };

                                // Auto Removal... note keyCT will deduct.
                                tmp1 = curKeys.lastIndexOf(" <~> "); // visual purpose
                                tmp2 = curKeys.substring(0, tmp1);
                                curKeys = tmp2;
                                keyCT--; // track the key count
                                // --- auto end

                                vewAct(k0, cks, cke, 26, '\n\t Drop Key... count: ' + keyCT + '\tKeys: ' + conPath(curKeys) + '\n');

                                vewAct(k0,cks, cke, 10, '\n\nAdjustments: ******>\tKeys: ' + conPath(curKeys) + '\n' + 'result' + '\n\n');
                                vewAct(k0, cks, cke, 11, result);
                                wrksect = 'clBrack';
                            } else {
                                console.log ('\n\nKey Count: ' + keyCT + '\n(37162) This Close Bracket Response from ' + wrksect +' Not SetUp.\n\t\t'+orig.substring(k0-10, k0+10)+'\nLast: ' + lookL[9] + '\nNext: ' + lookR[9]);
                            };
                        } else if ((['&#39;]','&#34;]'].indexOf(lookL[6]) != -1 && ['}}'].indexOf(lookR[2]) != -1) || (["']",'"]'].indexOf(lookL[2]) != -1 && ['}}'].indexOf(lookR[2]) != -1)) {
                            if (wrksect == 'clBrack'){
                                // after storing arrays value, this portion need to do nothing. values was already stored.
                                vewAct(k0, cks, cke, 9, 'actpt' + '\n' + orig.substring(actpt[actpt.length -1], k0));
                                valvalue = orig.substring(actpt[actpt.length - 1], k0);
                                actpt.push(k0);

                                adjval = cleaNewDic1Val(valvalue, k0);

                                vewAct(k0, cks, cke, 4, 'Key Count: ' + keyCT + '\tVALUE Value: ' + valvalue + '\nActions Points: ' + 'actpt');
                                vewAct(k0, cks, cke, 8, '\n\no\t' + adjval + '\to\n\n');


                                // note: Automatically remove the key and subtract count, plus else
                                // thekeys.push(adjval); // place value in total key variable
                                // pthKeys = curKeys; // path keys do not use the last location
                                // curKeys += ' <~> ' + adjval // start the key string observer
                                chKeys = conPath(curKeys); // all except the last, however last is present. not using last though
                                xit = false;
                                lct1 = -1;
                                lct2 = -1;
                                lct3 = -1;
                                lct4 = -1;
                                // --- end auto ---

                                // Auto Removal... note keyCT will deduct.
                                tmp1 = curKeys.lastIndexOf(" <~> "); // visual purpose
                                tmp2 = curKeys.substring(0, tmp1);
                                curKeys = tmp2;
                                keyCT--; // track the key count
                                // --- auto end

                                vewAct(k0, cks, cke, 26, '\n\t Drop Key... count: ' + keyCT + '\tKeys: ' + conPath(curKeys) + '\n');

                                vewAct(k0,cks, cke, 10, '\n\nAdjustments: ^^C^O^P^Y^^>\tKeys: ' + conPath(curKeys) + '\n' + 'result' + '\n\n');
                                vewAct(k0, cks, cke, 11, result);
                                wrksect = 'clBrack';
                            } else if (wrksect == 'clSquare'){
                                // after storing arrays value, this portion need to do nothing. values was already stored.
                                vewAct(k0, cks, cke, 9, 'actpt' + '\n' + orig.substring(actpt[actpt.length -1], k0));
                                valvalue = orig.substring(actpt[actpt.length - 1], k0);
                                actpt.push(k0);

                                adjval = cleaNewDic1Val(valvalue, k0);

                                vewAct(k0, cks, cke, 4, 'Key Count: ' + keyCT + '\tVALUE Value: ' + valvalue + '\nActions Points: ' + 'actpt');
                                vewAct(k0, cks, cke, 8, '\n\no\t' + adjval + '\to\n\n');


                                // note: Automatically remove the key and subtract count, plus else
                                // thekeys.push(adjval); // place value in total key variable
                                // pthKeys = curKeys; // path keys do not use the last location
                                // curKeys += ' <~> ' + adjval // start the key string observer
                                chKeys = conPath(curKeys); // all except the last, however last is present. not using last though
                                xit = false;
                                lct1 = -1;
                                lct2 = -1;
                                lct3 = -1;
                                lct4 = -1;
                                // --- end auto ---

                                // Auto Removal... note keyCT will deduct.
                                tmp1 = curKeys.lastIndexOf(" <~> "); // visual purpose
                                tmp2 = curKeys.substring(0, tmp1);
                                curKeys = tmp2;
                                keyCT--; // track the key count
                                // --- auto end

                                vewAct(k0, cks, cke, 26, '\n\t Drop Key... count: ' + keyCT + '\tKeys: ' + conPath(curKeys) + '\n');

                                vewAct(k0,cks, cke, 10, '\n\nAdjustments: ^^C^O^P^Y^^>\tKeys: ' + conPath(curKeys) + '\n' + 'result' + '\n\n');
                                vewAct(k0, cks, cke, 11, result);
                                wrksect = 'clBrack';
                            } else {
                                tmpsay = 'Close Bracket Response from ' + wrksect +' Not SetUp';
                                console.log ('\n\nKey Count: ' + keyCT + '\n(378182) This ' + tmpsay + '.\n\t\t'+orig.substring(k0-10, k0+10)+ '\t\tLine: ' + k0 + '\nLast: ' + lookL[9] + '\nNext: ' + lookR[9]);
                                if (k0 > cks && k0 < cke && tmpsay != '') {
                                    sayIt(tmpsay + ' Line ' + k0);
                                };
                            };
                        } else if ((['&#39;]}','&#34;]}'].indexOf(lookL[7]) != -1 && ['}'].indexOf(lookR[1]) != -1) || (["']}",'"]}'].indexOf(lookL[3]) != -1 && ['}'].indexOf(lookR[1]) != -1)) {
                            if (wrksect == 'clBrack'){
                                // after storing arrays value, this portion need to do nothing. values was already stored.
                                vewAct(k0, cks, cke, 9, 'actpt' + '\n' + orig.substring(actpt[actpt.length -1], k0));
                                valvalue = orig.substring(actpt[actpt.length - 1], k0);
                                actpt.push(k0);

                                adjval = cleaNewDic1Val(valvalue, k0);

                                vewAct(k0, cks, cke, 4, 'Key Count: ' + keyCT + '\tVALUE Value: ' + valvalue + '\nActions Points: ' + 'actpt');
                                vewAct(k0, cks, cke, 8, '\n\no\t' + adjval + '\to\n\n');


                                // note: Automatically remove the key and subtract count, plus else
                                // thekeys.push(adjval); // place value in total key variable
                                // pthKeys = curKeys; // path keys do not use the last location
                                // curKeys += ' <~> ' + adjval // start the key string observer
                                chKeys = conPath(curKeys); // all except the last, however last is present. not using last though
                                xit = false;
                                lct1 = -1;
                                lct2 = -1;
                                lct3 = -1;
                                lct4 = -1;
                                // --- end auto ---

                                // Auto Removal... note keyCT will deduct.
                                tmp1 = curKeys.lastIndexOf(" <~> "); // visual purpose
                                tmp2 = curKeys.substring(0, tmp1);
                                curKeys = tmp2;
                                keyCT--; // track the key count
                                // --- auto end

                                vewAct(k0, cks, cke, 26, '\n\t Drop Key... count: ' + keyCT + '\tKeys: ' + conPath(curKeys) + '\n');

                                vewAct(k0,cks, cke, 10, '\n\nAdjustments: ^^C^O^P^Y^^>\tKeys: ' + conPath(curKeys) + '\n' + 'result' + '\n\n');
                                vewAct(k0, cks, cke, 11, result);
                                wrksect = 'clBrack';
                            } else {
                                tmpsay = 'Close Bracket Response from ' + wrksect +' Not SetUp';
                                console.log ('\n\nKey Count: ' + keyCT + '\n(378082) This ' + tmpsay + '.\n\t\t'+orig.substring(k0-10, k0+10) + '\t\tLine: ' + k0 + '\nLast: ' + lookL[9] + '\nNext: ' + lookR[9]);
                                if (k0 > cks && k0 < cke && tmpsay != '') {
                                    sayIt(tmpsay + ' Line ' + k0);
                                };
                            };
                        } else if ((['&#39;}','&#34;}'].indexOf(lookL[6]) != -1 && ['}'].indexOf(lookR[1]) != -1) || (["'}",'"}'].indexOf(lookL[2]) != -1 && ['}'].indexOf(lookR[1]) != -1)) {
                            if (wrksect == 'clBrack'){
                                // after storing arrays value, this portion need to do nothing. values was already stored.
                                vewAct(k0, cks, cke, 9, 'actpt' + '\n' + orig.substring(actpt[actpt.length -1], k0));
                                valvalue = orig.substring(actpt[actpt.length - 1], k0);
                                actpt.push(k0);

                                adjval = cleaNewDic1Val(valvalue, k0);

                                vewAct(k0, cks, cke, 4, 'Key Count: ' + keyCT + '\tVALUE Value: ' + valvalue + '\nActions Points: ' + 'actpt');
                                vewAct(k0, cks, cke, 8, '\n\no\t' + adjval + '\to\n\n');


                                // note: Automatically remove the key and subtract count, plus else
                                // thekeys.push(adjval); // place value in total key variable
                                // pthKeys = curKeys; // path keys do not use the last location
                                // curKeys += ' <~> ' + adjval // start the key string observer
                                chKeys = conPath(curKeys); // all except the last, however last is present. not using last though
                                xit = false;
                                lct1 = -1;
                                lct2 = -1;
                                lct3 = -1;
                                lct4 = -1;
                                // --- end auto ---

                                // Auto Removal... note keyCT will deduct.
                                tmp1 = curKeys.lastIndexOf(" <~> "); // visual purpose
                                tmp2 = curKeys.substring(0, tmp1);
                                curKeys = tmp2;
                                keyCT--; // track the key count
                                // --- auto end

                                vewAct(k0, cks, cke, 26, '\n\t Drop Key... count: ' + keyCT + '\tKeys: ' + conPath(curKeys) + '\n');

                                vewAct(k0,cks, cke, 10, '\n\nAdjustments: ^^C^O^P^Y^^>\tKeys: ' + conPath(curKeys) + '\n' + 'result' + '\n\n');
                                vewAct(k0, cks, cke, 11, result);
                                wrksect = 'clBrack';

                            } else {
                                tmpsay = 'Close Bracket Response from ' + wrksect +' Not SetUp';
                                console.log ('\n\nKey Count: ' + keyCT + '\n(378582) This ' + tmpsay + '.\n\t\t'+orig.substring(k0-10, k0+10)+'\nLast: ' + lookL[9] + '\nNext: ' + lookR[9]);
                                if (k0 > cks && k0 < cke && tmpsay != '') {
                                    sayIt(tmpsay + ' Line ' + k0);
                                };
                            };
                        } else if (['&#39;}}','&#34;}}'].indexOf(lookL[7]) != -1 && ['}'].indexOf(lookR[1]) != -1) {
                            if (wrksect == 'clBrack'){
                                // after storing arrays value, this portion need to do nothing. values was already stored.
                                vewAct(k0, cks, cke, 9, 'actpt' + '\n' + orig.substring(actpt[actpt.length -1], k0));
                                valvalue = orig.substring(actpt[actpt.length - 1], k0);
                                actpt.push(k0);

                                adjval = cleaNewDic1Val(valvalue, k0);

                                vewAct(k0, cks, cke, 4, 'Key Count: ' + keyCT + '\tVALUE Value: ' + valvalue + '\nActions Points: ' + 'actpt');
                                vewAct(k0, cks, cke, 8, '\n\no\t' + adjval + '\to\n\n');


                                // note: Automatically remove the key and subtract count, plus else
                                // thekeys.push(adjval); // place value in total key variable
                                // pthKeys = curKeys; // path keys do not use the last location
                                // curKeys += ' <~> ' + adjval // start the key string observer
                                chKeys = conPath(curKeys); // all except the last, however last is present. not using last though
                                xit = false;
                                lct1 = -1;
                                lct2 = -1;
                                lct3 = -1;
                                lct4 = -1;
                                // --- end auto ---

                                // Auto Removal... note keyCT will deduct.
                                tmp1 = curKeys.lastIndexOf(" <~> "); // visual purpose
                                tmp2 = curKeys.substring(0, tmp1);
                                curKeys = tmp2;
                                keyCT--; // track the key count
                                // --- auto end

                                vewAct(k0, cks, cke, 26, '\n\t Drop Key... count: ' + keyCT + '\tKeys: ' + conPath(curKeys) + '\n');

                                vewAct(k0,cks, cke, 10, '\n\nAdjustments: ^^C^O^P^Y^^>\tKeys: ' + conPath(curKeys) + '\n' + 'result' + '\n\n');
                                vewAct(k0, cks, cke, 11, result);
                                wrksect = 'clBrack';

                            } else {
                                tmpsay = 'Close Bracket Response from ' + wrksect +' Not SetUp';
                                console.log ('\n\nKey Count: ' + keyCT + '\n(371232) This ' + tmpsay + '.\n\t\t'+orig.substring(k0-10, k0+10)+'\nLast: ' + lookL[9] + '\nNext: ' + lookR[9]);
                                if (k0 > cks && k0 < cke && tmpsay != '') {
                                    sayIt(tmpsay + ' Line ' + k0);
                                };
                            };
                        } else if ((['&#39;','&#34;'].indexOf(lookL[5]) != -1 && ['}}'].indexOf(lookR[2]) != -1) || (["'",'"'].indexOf(lookL[1]) != -1 && ['}}'].indexOf(lookR[2]) != -1)) {
                            // console.log('\t\t\t\t*******Pick it up here27************'); // you have twice
                            if (wrksect == 'coLon'){
                                // this portion needs to store the value and the drop 1.
                                vewAct(k0, cks, cke, 9, 'actpt' + '\n' + orig.substring(actpt[actpt.length -1], k0));
                                valvalue = orig.substring(actpt[actpt.length - 1], k0);
                                actpt.push(k0);

                                adjval = cleaNewDic1Val(valvalue, k0);

                                vewAct(k0, cks, cke, 4, 'Key Count: ' + keyCT + '\tVALUE Value: ' + valvalue + '\nActions Points: ' + 'actpt');
                                vewAct(k0, cks, cke, 8, '\n\no\t' + adjval + '\to\n\n');


                                // note: Automatically remove the key and subtract count, plus else
                                // thekeys.push(adjval); // place value in total key variable
                                // pthKeys = curKeys; // path keys do not use the last location
                                // curKeys += ' <~> ' + adjval // start the key string observer
                                chKeys = conPath(curKeys); // all except the last, however last is present. not using last though
                                xit = false;
                                lct1 = -1;
                                lct2 = -1;
                                lct3 = -1;
                                lct4 = -1;
                                // --- end auto ---



                                if (keyCT == 1) {
                                    tmpsay = 'Section ' + keyCT + ' Not Setup';
                                } else if (keyCT == 2) {
                                    // tmpsay = 'Section ' + keyCT + ' Not Setup';
                                    tmpsay = "";
                                    for (a in result) { // checking the first array
                                        lct1++; // this brings the loop count to the key variable (string)
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) { // found the match, locate the key with search data
                                            // console.log('\tFound 1: ' + chKeys[0]);
                                            lct1++; // this brings the loop count to the value variable (array)
                                            for(b in result[lct1]) { // checking the second array
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('\tFound 2: ' + chKeys[1]);
                                                    lct2++;
                                                    result[lct1][lct2].push( adjval );
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };
                                } else if (keyCT == 3) {
                                    tmpsay = 'Section ' + keyCT + ' Not Setup'; // need to verify its working
                                    // tmpsay = "";
                                    for (a in result) { // checking the first array
                                        lct1++; // this brings the loop count to the key variable (string)
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) { // found the match, locate the key with search data
                                            // console.log('Found 1');
                                            lct1++; // this brings the loop count to the value variable (array)
                                            for(b in result[lct1]) { // checking the second array
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found 2');
                                                    lct2++; // doin a different way
                                                    // if (result[lct1][b] == chKeys[1]) { // the key has to match special key, cause key is going backward out of dic
                                                    //     // console.log('Found It: ' + result[lct1][b]); // show match was found
                                                    //     for (c in result[lct1][lct2]){ // cycle through the string and array
                                                    //         // console.log(result[lct1][lct2][c]);
                                                    //         ooe = oddOrEven(c); // odd string will be the string, even will be the array
                                                    //         if (ooe == 'odd') {
                                                    //             // console.log('ODD Found it: ' + result[lct1][lct2][c]);
                                                    //             allvalues += ' <V> ' + result[lct1][lct2][c]; // group all values
                                                    //         } else if (ooe == 'even') {
                                                    //             // console.log('EVEN found it: ' + result[lct1][lct2][c]);
                                                    //             allkeys += ' <K> ' + result[lct1][lct2][c]; // group all keys
                                                    //         };
                                                    //     };
                                                    //     result[lct1][lct2].push('<KEY>', [allkeys] ); // add all keys
                                                    //     result[lct1][lct2].push('<VALUE>', [allvalues] ); // add all values
                                                    //     xit = true;
                                                    //     break;
                                                    // };
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };
                                } else if (keyCT == 4) {
                                    // tmpsay = 'Section ' + keyCT + ' Not Setup';
                                    tmpsay = "";
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1');
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found 2');
                                                    lct2++;
                                                    for (c in result[lct1][lct2]) {
                                                        lct3++;
                                                        if (result[lct1][lct2][c] == chKeys[2]) {
                                                            // console.log('Found 3');
                                                            lct3++;
                                                            for (d in result[lct1][lct2][lct3]) {
                                                                lct4++;
                                                                // cant get key loc #2 all will go there
                                                                // console.log('\n\nShow Me the Keys: ' + curKeys);
                                                                if (result[lct1][lct2][lct3][d] == chKeys[3]) {
                                                                    // console.log('Found it: ' + result[lct1][lct2][lct3][d]);
                                                                    // console.log('last key: ' + thekeys[thekeys.length - 1]);
                                                                    lct4++;
                                                                    result[lct1][lct2][lct3][lct4].push( adjval ); // adding just the value
                                                                    xit = true;
                                                                    break;
                                                                };
                                                            };
                                                        };
                                                        if (xit == true) {
                                                            break;
                                                        };
                                                    };
                                                };
                                                if (xit == true) {
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };
                                } else if (keyCT == 5) {
                                    tmpsay = 'Section ' + keyCT + ' Not Setup';
                                } else if (keyCT == 6) {
                                    tmpsay = 'Section ' + keyCT + ' Not Setup';
                                } else if (keyCT == 7) {
                                    tmpsay = 'Section ' + keyCT + ' Not Setup';
                                } else {
                                    tmpsay = 'Section NONE Not Setup';
                                };
                                //} else if ([].indexOf(lookL[]) != -1 && [].indexOf(lookR[]) != -1) {
                                if (k0 > cks && k0 < cke && tmpsay != '') {
                                    sayIt(tmpsay + ' Line ' + k0);
                                    vewAct(k0, cks, cke, 17, '<<' + tmpsay +'>>');
                                };


                                // Auto Removal... note keyCT will deduct.
                                tmp1 = curKeys.lastIndexOf(" <~> "); // visual purpose
                                tmp2 = curKeys.substring(0, tmp1);
                                curKeys = tmp2;
                                keyCT--; // track the key count
                                // --- auto end

                                vewAct(k0, cks, cke, 26, '\n\t Drop Key... count: ' + keyCT + '\tKeys: ' + conPath(curKeys) + '\n');

                                vewAct(k0,cks, cke, 10, '\n\nAdjustments: ^^C^O^P^Y^^>\tKeys: ' + conPath(curKeys) + '\n' + 'result' + '\n\n');
                                vewAct(k0, cks, cke, 11, result);
                                wrksect = 'clBrack';

                            } else {
                                tmpsay = 'Close Bracket Response from ' + wrksect +' Not SetUp';
                                console.log ('\n\nKey Count: ' + keyCT + '\n(372382) This ' + tmpsay + '.\n\t\t'+orig.substring(k0-10, k0+10)+'\nLast: ' + lookL[9] + '\nNext: ' + lookR[9]);
                                if (k0 > cks && k0 < cke && tmpsay != '') {
                                    sayIt(tmpsay + ' Line ' + k0);
                                };
                            };
                        } else if (['&#39;]','&#34;]'].indexOf(lookL[6]) != -1 && ['}'].indexOf(lookR[1]) != -1) {
                            console.log('End Of Data');
                            vewAct(k0, cks, cke, 9, 'actpt' + '\n' + orig.substring(actpt[actpt.length -1], k0));
                            valvalue = orig.substring(actpt[actpt.length - 1], k0);
                            actpt.push(k0);

                            adjval = cleaNewDic1Val(valvalue, k0);

                            vewAct(k0, cks, cke, 4, 'Key Count: ' + keyCT + '\tVALUE Value: ' + valvalue + '\nActions Points: ' + 'actpt');
                            vewAct(k0, cks, cke, 8, '\n\no\t' + adjval + '\to\n\n');


                            // note: Automatically remove the key and subtract count, plus else
                            // thekeys.push(adjval); // place value in total key variable
                            // pthKeys = curKeys; // path keys do not use the last location
                            // curKeys += ' <~> ' + adjval // start the key string observer
                            chKeys = conPath(curKeys); // all except the last, however last is present. not using last though
                            xit = false;
                            lct1 = -1;
                            lct2 = -1;
                            lct3 = -1;
                            lct4 = -1;
                            // --- end auto ---

                            // Auto Removal... note keyCT will deduct.
                            tmp1 = curKeys.lastIndexOf(" <~> "); // visual purpose
                            tmp2 = curKeys.substring(0, tmp1);
                            curKeys = tmp2;
                            keyCT--; // track the key count
                            // --- auto end

                            vewAct(k0, cks, cke, 26, '\n\t Drop Key... count: ' + keyCT + '\tKeys: ' + conPath(curKeys) + '\n');

                            vewAct(k0,cks, cke, 10, '\n\nAdjustments: ^^C^O^P^Y^^>\tKeys: ' + conPath(curKeys) + '\n' + 'result' + '\n\n');
                            vewAct(k0, cks, cke, 11, result);
                            wrksect = 'clBrack';

                        } else {
                            tmpsay = "Close Bracket Instructions Not Setup";
                            console.log('\n\t\t\t*********************************************');
                            console.log('\t\t\t*\t' + tmpsay + '\t*');
                            console.log('\t\t\t*********************************************\n');
                            //} else if ([].indexOf(lookL[]) != -1 && [].indexOf(lookR[]) != -1) {
                            if (k0 > cks && k0 < cke && tmpsay != '') {
                                sayIt(tmpsay + ' Line ' + k0);
                            };
                        };
                    } else if (lookL[0] == '[') {
                        // open square bracket: for python list values, start array for each entry seperated by comma
                        sect = 'Open Square';
                        vewAct(k0, cks, cke, 6, '\nWork Section: ' + wrksect + '\n' + lookL[5] + '\t\tOpen Square Bracket View\t\t' + lookR[8]);
                        if ((['???'].indexOf(lookL[2]) != -1 && ['???'].indexOf(lookR[2]) != -1) || (['???'].indexOf(lookL[2]) != -1 && ['???'].indexOf(lookR[2]) != -1)) {
                            //
                        } else if ((['&#39;: ','&#34;: '].indexOf(lookL[7]) != -1 && ['[u&#39;','[u&#34;'].indexOf(lookR[7]) != -1) || (["': ",'": '].indexOf(lookL[3]) != -1 && ["[u'",'[u"'].indexOf(lookR[3]) != -1)) {
                            if (['opBrack','coLon'].indexOf(wrksect) != -1) {
                                vewAct(k0, cks, cke, 38, 'OPEN SQUARE BRACKET');
                            };
                            wrksqre = true;
                            wrksect = 'opSquare';
                        } else if ((['&#39;: ','&#34;: '].indexOf(lookL[7]) != -1 && ['[&#39;','[&#34;'].indexOf(lookR[6]) != -1) || (["': ",'": '].indexOf(lookL[3]) != -1 && ["['",'["'].indexOf(lookR[2]) != -1)) {
                            if (['opBrack','coLon'].indexOf(wrksect) != -1) {
                                vewAct(k0, cks, cke, 38, 'OPEN SQUARE BRACKET');
                            };
                            wrksqre = true;
                            wrksect = 'opSquare';
                        // } else if (speChk(lookL[5]) == false && speChk(lookR[6]) == false && wrksqre == false) {
                        //     if (['opBrack','coLon'].indexOf(wrksect) != -1) {
                        //         vewAct(k0, cks, cke, 'Non-Important Open Square Bracket;\tSkip this...');
                        //         vewAct(k0, cks, cke, 38, 'OPEN SQUARE BRACKET');
                        //     };
                        //     wrksqre = true;
                        //     wrksect = 'opSquare';
                        } else if (passableChk(lookL[0],'BPeignoy .','EVdehilptx ',viewpos)) {
                            // passable open brackets
                            console.log('\nNon-Important Open Square Bracket;\tSkip this...\n'+viewpos);
                        } else {
                            tmpsay = "Open Square Bracket Instructions Not Setup\t\tLine: " + k0;
                            console.log('\n\t\t\t*********************************************************************');
                            console.log('\t\t\t*\t' + tmpsay + '\t*' );
                            console.log('\t\t\t*\t\t' + viewpos + '\t\t\t*');
                            console.log('\t\t\t*********************************************************************\n');
                            tmp = passableChk(lookL[0],'BPeignoy .','EVdehilptx ',viewpos);
                            if (k0 > cks && k0 < cke && tmpsay != '') {
                                sayIt(tmpsay);
                            };
                        };
                    } else if (lookL[0] == ']') {
                        // Close Square section not working with ( cleanNewDicVal(keyvalue)  )
                        // close square bracket: for python list values
                        sect = 'Close Square';
                        vewAct(k0, cks, cke, 6, '\nWork Section: ' + wrksect + '\n' + lookL[5] + '\t\tClose Square Bracket View\t\t' + lookR[10]);
                        if ((['???'].indexOf(lookL[2]) != -1 && ['???'].indexOf(lookR[2]) != -1) || (['???'].indexOf(lookL[2]) != -1 && ['???'].indexOf(lookR[2]) != -1)) {
                            //
                        } else if (['&#39;','&#34;'].indexOf(lookL[5]) != -1 && ['], u&#39;','], u&#34;'].indexOf(lookR[9]) != -1 ) {
                            // close out last value... acknowledge array is close for list values
                            if (wrksect == 'coMma') {
                                vewAct(k0, cks, cke, 9, 'actpt' + '\n' + orig.substring(actpt[actpt.length -1], k0));
                                valvalue = orig.substring(actpt[actpt.length - 1], k0);
                                actpt.push(k0);

                                adjval = cleaNewDic1Val(valvalue, k0);

                                // var tmpc = stringCount(adjval,"'",false);
                                // console.log('\nthis is: ' + tmpc); // adjustment Fix
                                if (stringCount(adjval,"'",false) == 1) {
                                    // console.log('\t\t-> ' + adjval.substring(adjval.length - 1, adjval.length) + '\t\tLine : ' + k0 + '\t\t' + viewpos);
                                    if (adjval.substring(0,1) == "'") {
                                        vewAct(k0, cks, cke, 20, '\tAdjustment made to Front: ' + adjval);
                                        adjval = adjval.substring(1,adjval.length);
                                    } else if (adjval.substring(adjval.length - 1, adjval.length) == "'") {
                                        vewAct(k0, cks, cke, 20, '\tAdjustment made to Back: ' + adjval)
                                        adjval = adjval.substring(0, adjval.length - 1);
                                    } else {
                                        vewAct(k0, cks, cke, 21, 'Option Not Available');
                                    };
                                };

                                vewAct(k0, cks, cke, 4, 'Key Count: ' + keyCT + '\tVALUE Value: ' + valvalue + '\nActions Points: ' + 'actpt');
                                vewAct(k0, cks, cke, 8, '\n\no\t' + adjval + '\to\n\n');


                                // note: Automatically remove the key and subtract count, plus else
                                // thekeys.push(adjval); // place value in total key variable
                                // pthKeys = curKeys; // path keys do not use the last location
                                // curKeys += ' <~> ' + adjval // start the key string observer
                                // --- end auto ---
                                chKeys = conPath(curKeys); // all except the last, however last is present. not using last though
                                xit = false;
                                lct1 = -1;
                                lct2 = -1;
                                lct3 = -1;
                                lct4 = -1;
                                lct5 = -1;
                                lct6 = -1;
                                lct7 = -1;
                                lct8 = -1;
                                // --- end auto ---

                                if (keyCT == 1) {
                                    // tmpsay = 'Working IN: ' + sect + ' Section, area: ' + wrksect + ', Key Count: ' + keyCT;
                                    // vewAct(k0, cks, cke,'Working on Key ONE');
                                    tmpsay = "";
                                    for (a in result) {
                                        lct1++;
                                        if (result[a] == chKeys[0]) {
                                            lct1++;
                                            result[lct1].push( adjval );
                                            break;
                                        };
                                    };
                                } else if (keyCT == 2) {
                                    // tmpsay = 'Working IN: ' + sect + ' Section, area: ' + wrksect + ', Key Count: ' + keyCT;
                                    tmpsay = '';
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1: ' + result[a]);
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found 2: ' + result[lct1][b]);
                                                    lct2++;
                                                    result[lct1][lct2].push(adjval);
                                                    xit = true;
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };
                                } else if (keyCT == 3) {
                                    // tmpsay = 'Working IN: ' + sect + ' Section, area: ' + wrksect + ', Key Count: ' + keyCT;
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1: ' + result[a]);
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found 2: ' + result[lct1][b]);
                                                    lct2++;
                                                    for (c in result[lct1][lct2]) {
                                                        lct3++;
                                                        if (result[lct1][lct2][c] == chKeys[2]) {
                                                            lct3++;
                                                            result[lct1][lct2][lct3].push(adjval);
                                                            xit = true;
                                                            break;
                                                        };
                                                    };
                                                };
                                                if (xit == true) {
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };
                                } else if (keyCT == 4) {
                                    // tmpsay = 'Working IN: ' + sect + ' Section, area: ' + wrksect + ', Key Count: ' + keyCT;
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1: ' + result[a]);
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found 2: ' + result[lct1][b]);
                                                    lct2++;
                                                    for (c in result[lct1][lct2]) {
                                                        lct3++;
                                                        if (result[lct1][lct2][c] == chKeys[2]) {
                                                            lct3++;
                                                            for (d in result[lct1][lct2][lct3]) {
                                                                lct4++;
                                                                if (result[lct1][lct2][lct3][d] == chKeys[3]) {
                                                                    lct4++;
                                                                    result[lct1][lct2][lct3][lct4].push(adjval);
                                                                    xit = true;
                                                                    break;
                                                                };
                                                            };
                                                        };
                                                        if (xit == true) {
                                                            break;
                                                        };
                                                    };
                                                };
                                                if (xit == true) {
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };
                                } else if (keyCT == 5) {
                                    // tmpsay = 'Working IN: ' + sect + ' Section, area: ' + wrksect + ', Key Count: ' + keyCT;
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1: ' + result[a]);
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found 2: ' + result[lct1][b]);
                                                    lct2++;
                                                    for (c in result[lct1][lct2]) {
                                                        lct3++;
                                                        if (result[lct1][lct2][c] == chKeys[2]) {
                                                            lct3++;
                                                            for (d in result[lct1][lct2][lct3]) {
                                                                lct4++;
                                                                if (result[lct1][lct2][lct3][d] == chKeys[3]) {
                                                                    lct4++;
                                                                    for (e in result[lct1][lct2][lct3][lct4]) {
                                                                        lct5++;
                                                                        if (result[lct1][lct2][lct3][lct4][e] == chKeys[4]) {
                                                                            lct5++;
                                                                            result[lct1][lct2][lct3][lct4][lct5].push(adjval);
                                                                            xit = true;
                                                                            break;
                                                                        };
                                                                    };
                                                                };
                                                                if (xit == true) {
                                                                    break;
                                                                };
                                                            };
                                                        };
                                                        if (xit == true) {
                                                            break;
                                                        };
                                                    };
                                                };
                                                if (xit == true) {
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };
                                } else if (keyCT == 6) {
                                    tmpsay = 'Working IN: ' + sect + ' Section, area: ' + wrksect + ', Key Count: ' + keyCT;
                                } else if (keyCT == 7) {
                                    tmpsay = 'Working IN: ' + sect + ' Section, area: ' + wrksect + ', Key Count: ' + keyCT;
                                } else {
                                    tmpsay = 'Section NONE Not Setup';
                                };
                                // //} else if ([].indexOf(lookL[]) != -1 && [].indexOf(lookR[]) != -1) {
                                if (k0 > cks && k0 < cke && tmpsay != '') {
                                    sayIt(tmpsay + ' Line ' + k0);
                                    vewAct(k0, cks, cke, 17, '<<' + tmpsay +'>>');
                                };


                                // --- auto removal... None to remove

                                vewAct(k0,cks, cke, 10, '\n\nAdjustments: ===C)O{P=Y==>\tKeys: ' + conPath(curKeys) + '\n' + 'result' + '\n\n');
                                vewAct(k0, cks, cke, 11, result);
                                // Thrown off, apparently this process is being done by the next main character.  need to repair
                                // wrksect = 'clSquare';
                                wrksqre = false;
                            };

                        } else if ((['&#39;','&#34;'].indexOf(lookL[5]) != -1 && [']}}'].indexOf(lookR[3]) != -1) || (["'",'"'].indexOf(lookL[1]) != -1 && [']}}'].indexOf(lookR[3]) != -1)) {
                            //
                            if (wrksect == 'opSquare') {
                                //
                                vewAct(k0, cks, cke, 9, 'actpt' + '\n' + orig.substring(actpt[actpt.length -1], k0));
                                valvalue = orig.substring(actpt[actpt.length - 1], k0);
                                actpt.push(k0);

                                adjval = cleaNewDic1Val(valvalue, k0);

                                vewAct(k0, cks, cke, 4, 'Key Count: ' + keyCT + '\tVALUE Value: ' + valvalue + '\nActions Points: ' + 'actpt');
                                vewAct(k0, cks, cke, 8, '\n\no\t' + adjval + '\to\n\n');


                                // note: Automatically remove the key and subtract count, plus else
                                // thekeys.push(adjval); // place value in total key variable
                                // pthKeys = curKeys; // path keys do not use the last location
                                // curKeys += ' <~> ' + adjval // start the key string observer
                                chKeys = conPath(curKeys); // all except the last, however last is present. not using last though
                                xit = false;
                                lct1 = -1;
                                lct2 = -1;
                                lct3 = -1;
                                lct4 = -1;
                                lct5 = -1;
                                lct6 = -1;
                                lct7 = -1;
                                lct8 = -1;
                                // --- end auto ---

                                if (keyCT == 1) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                } else if (keyCT == 2) {
                                    tmpsay = '';
                                    // tmpsay = 'Working IN: ' + sect + ' Section, area: ' + wrksect + ', Key Count: ' + keyCT;
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1: ' + result[a]);
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found 2: ' + result[lct1][b]);
                                                    lct2++;
                                                    result[lct1][lct2].push(adjval);
                                                    xit = true;
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };
                                } else if (keyCT == 3) {
                                    // tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1: ' + result[a]);
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found 2: ' + result[lct1][b]);
                                                    lct2++;
                                                    for (c in result[lct1][lct2]) {
                                                        lct3++;
                                                        if (result[lct1][lct2][c] == chKeys[2]) {
                                                            lct3++;
                                                            result[lct1][lct2][lct3].push(adjval);
                                                            xit = true;
                                                            break;
                                                        };
                                                    };
                                                };
                                                if (xit == true) {
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };
                                } else if (keyCT == 4) {
                                    // tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1: ' + result[a]);
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found 2: ' + result[lct1][b]);
                                                    lct2++;
                                                    for (c in result[lct1][lct2]) {
                                                        lct3++;
                                                        if (result[lct1][lct2][c] == chKeys[2]) {
                                                            lct3++;
                                                            for (d in result[lct1][lct2][lct3]) {
                                                                lct4++;
                                                                if (result[lct1][lct2][lct3][d] == chKeys[3]) {
                                                                    lct4++;
                                                                    result[lct1][lct2][lct3][lct4].push(adjval);
                                                                    xit = true;
                                                                    break;
                                                                };
                                                            };
                                                        };
                                                        if (xit == true) {
                                                            break;
                                                        };
                                                    };
                                                };
                                                if (xit == true) {
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };
                                } else if (keyCT == 5) {
                                    // tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1: ' + result[a]);
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found 2: ' + result[lct1][b]);
                                                    lct2++;
                                                    for (c in result[lct1][lct2]) {
                                                        lct3++;
                                                        if (result[lct1][lct2][c] == chKeys[2]) {
                                                            lct3++;
                                                            for (d in result[lct1][lct2][lct3]) {
                                                                lct4++;
                                                                if (result[lct1][lct2][lct3][d] == chKeys[3]) {
                                                                    lct4++;
                                                                    for (e in result[lct1][lct2][lct3][lct4]) {
                                                                        lct5++;
                                                                        if (result[lct1][lct2][lct3][lct4][e] == chKeys[4]) {
                                                                            lct5++;
                                                                            result[lct1][lct2][lct3][lct4][lct5].push(adjval);
                                                                            xit = true;
                                                                            break;
                                                                        };
                                                                    };
                                                                };
                                                                if (xit == true) {
                                                                    break;
                                                                };
                                                            };
                                                        };
                                                        if (xit == true) {
                                                            break;
                                                        };
                                                    };
                                                };
                                                if (xit == true) {
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };
                                } else if (keyCT == 6) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                } else if (keyCT == 7) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                } else {
                                    tmpsay = 'Section NONE Not Setup';
                                };
                                //} else if ([].indexOf(lookL[]) != -1 && [].indexOf(lookR[]) != -1) {
                                if (k0 > cks && k0 < cke && tmpsay != '') {
                                    sayIt(tmpsay + ' Line ' + k0);
                                    vewAct(k0, cks, cke, 17, '<<' + tmpsay +'>>');
                                };


                                // --- auto removal... None to remove

                                vewAct(k0,cks, cke, 10, '\n\nAdjustments: ===C=O=P=Y==>\tKeys: ' + conPath(curKeys) + '\n' + 'result' + '\n\n');
                                vewAct(k0, cks, cke, 11, result);
                                wrksect = 'clSquare';
                                wrksqre = false;
                            } else if (wrksect = 'coMma') {
                                //
                                vewAct(k0, cks, cke, 9, 'actpt' + '\n' + orig.substring(actpt[actpt.length -1], k0));
                                valvalue = orig.substring(actpt[actpt.length - 1], k0);
                                actpt.push(k0);

                                adjval = cleaNewDic1Val(valvalue, k0);

                                vewAct(k0, cks, cke, 4, 'Key Count: ' + keyCT + '\tVALUE Value: ' + valvalue + '\nActions Points: ' + 'actpt');
                                vewAct(k0, cks, cke, 8, '\n\no\t' + adjval + '\to\n\n');


                                // note: Automatically remove the key and subtract count, plus else
                                // thekeys.push(adjval); // place value in total key variable
                                // pthKeys = curKeys; // path keys do not use the last location
                                // curKeys += ' <~> ' + adjval // start the key string observer
                                chKeys = conPath(curKeys); // all except the last, however last is present. not using last though
                                xit = false;
                                lct1 = -1;
                                lct2 = -1;
                                lct3 = -1;
                                lct4 = -1;
                                lct5 = -1;
                                lct6 = -1;
                                lct7 = -1;
                                lct8 = -1;
                                // --- end auto ---

                                if (keyCT == 1) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                } else if (keyCT == 2) {
                                    tmpsay = '';
                                    // tmpsay = 'Working IN: ' + sect + ' Section, area: ' + wrksect + ', Key Count: ' + keyCT;
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1: ' + result[a]);
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found 2: ' + result[lct1][b]);
                                                    lct2++;
                                                    result[lct1][lct2].push(adjval);
                                                    xit = true;
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };
                                } else if (keyCT == 3) {
                                    // tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1: ' + result[a]);
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found 2: ' + result[lct1][b]);
                                                    lct2++;
                                                    for (c in result[lct1][lct2]) {
                                                        lct3++;
                                                        if (result[lct1][lct2][c] == chKeys[2]) {
                                                            lct3++;
                                                            result[lct1][lct2][lct3].push(adjval);
                                                            xit = true;
                                                            break;
                                                        };
                                                    };
                                                };
                                                if (xit == true) {
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };
                                } else if (keyCT == 4) {
                                    // tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1: ' + result[a]);
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found 2: ' + result[lct1][b]);
                                                    lct2++;
                                                    for (c in result[lct1][lct2]) {
                                                        lct3++;
                                                        if (result[lct1][lct2][c] == chKeys[2]) {
                                                            lct3++;
                                                            for (d in result[lct1][lct2][lct3]) {
                                                                lct4++;
                                                                if (result[lct1][lct2][lct3][d] == chKeys[3]) {
                                                                    lct4++;
                                                                    result[lct1][lct2][lct3][lct4].push(adjval);
                                                                    xit = true;
                                                                    break;
                                                                };
                                                            };
                                                        };
                                                        if (xit == true) {
                                                            break;
                                                        };
                                                    };
                                                };
                                                if (xit == true) {
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };
                                } else if (keyCT == 5) {
                                    // tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1: ' + result[a]);
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found 2: ' + result[lct1][b]);
                                                    lct2++;
                                                    for (c in result[lct1][lct2]) {
                                                        lct3++;
                                                        if (result[lct1][lct2][c] == chKeys[2]) {
                                                            lct3++;
                                                            for (d in result[lct1][lct2][lct3]) {
                                                                lct4++;
                                                                if (result[lct1][lct2][lct3][d] == chKeys[3]) {
                                                                    lct4++;
                                                                    for (e in result[lct1][lct2][lct3][lct4]) {
                                                                        lct5++;
                                                                        if (result[lct1][lct2][lct3][lct4][e] == chKeys[4]) {
                                                                            lct5++;
                                                                            result[lct1][lct2][lct3][lct4][lct5].push(adjval);
                                                                            xit = true;
                                                                            break;
                                                                        };
                                                                    };
                                                                };
                                                                if (xit == true) {
                                                                    break;
                                                                };
                                                            };
                                                        };
                                                        if (xit == true) {
                                                            break;
                                                        };
                                                    };
                                                };
                                                if (xit == true) {
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };
                                } else if (keyCT == 6) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                } else if (keyCT == 7) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                } else {
                                    tmpsay = 'Section NONE Not Setup';
                                };
                                //} else if ([].indexOf(lookL[]) != -1 && [].indexOf(lookR[]) != -1) {
                                if (k0 > cks && k0 < cke && tmpsay != '') {
                                    sayIt(tmpsay + ' Line ' + k0);
                                    vewAct(k0, cks, cke, 17, '<<' + tmpsay +'>>');
                                };

                                // --- auto removal... None to remove

                                vewAct(k0,cks, cke, 10, '\n\nAdjustments: ==C=O==P=Y==>\tKeys: ' + conPath(curKeys) + '\n' + 'result' + '\n\n');
                                vewAct(k0, cks, cke, 11, result);
                                wrksect = 'clSquare';
                                wrksqre = false;
                            } else {
                                tmpsay = 'CLOSE SQUARE Response from ' + wrksect +' Not SetUp';
                                console.log ('\n\nKey Count: ' + keyCT + '\n(46223) This ' + tmpsay + '.\n\t\t'+orig.substring(k0-10, k0+10)+ '\t\tLine: '+ k0 +'\nLast: ' + lookL[9] + '\nNext: ' + lookR[9]);
                                if (k0 > cks && k0 < cke && tmpsay != '') {
                                    sayIt(tmpsay + ' Line ' + k0);
                                };
                            };
                        } else if ((['&#39;','&#34;'].indexOf(lookL[5]) != -1 && [']}, u&#39;',"]}, u&#34;"].indexOf(lookR[10]) != -1) || (["'",'"'].indexOf(lookL[1]) != -1 && ["]}, u'",']}, u"'].indexOf(lookR[6]) != -1)) {
                            // close out last value... acknowledge array is close for list values
                            if (wrksect == 'coMma') {
                                vewAct(k0, cks, cke, 9, 'actpt' + '\n' + orig.substring(actpt[actpt.length -1], k0));
                                valvalue = orig.substring(actpt[actpt.length - 1], k0);
                                actpt.push(k0);

                                adjval = cleaNewDic1Val(valvalue, k0);

                                vewAct(k0, cks, cke, 4, 'Key Count: ' + keyCT + '\tVALUE Value: ' + valvalue + '\nActions Points: ' + 'actpt');
                                vewAct(k0, cks, cke, 8, '\n\no\t' + adjval + '\to\n\n');


                                // note: Automatically remove the key and subtract count, plus else
                                // thekeys.push(adjval); // place value in total key variable
                                // pthKeys = curKeys; // path keys do not use the last location
                                // curKeys += ' <~> ' + adjval // start the key string observer
                                chKeys = conPath(curKeys); // all except the last, however last is present. not using last though
                                xit = false;
                                lct1 = -1;
                                lct2 = -1;
                                lct3 = -1;
                                lct4 = -1;
                                // --- end auto ---

                                if (keyCT == 1) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                } else if (keyCT == 2) {
                                    tmpsay = '';
                                    // tmpsay = 'Working IN: ' + sect + ' Section, area: ' + wrksect + ', Key Count: ' + keyCT;
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1: ' + result[a]);
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found 2: ' + result[lct1][b]);
                                                    lct2++;
                                                    result[lct1][lct2].push(adjval);
                                                    xit = true;
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };
                                } else if (keyCT == 3) {
                                    // tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                    // tmpsay = 'Working IN: ' + sect + ' Section, area: ' + wrksect + ', Key Count: ' + keyCT;
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1: ' + result[a]);
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found 2: ' + result[lct1][b]);
                                                    lct2++;
                                                    for (c in result[lct1][lct2]) {
                                                        lct3++;
                                                        if (result[lct1][lct2][c] == chKeys[2]) {
                                                            lct3++;
                                                            result[lct1][lct2][lct3].push(adjval);
                                                            xit = true;
                                                            break;
                                                        };
                                                    };
                                                };
                                                if (xit == true) {
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };
                                } else if (keyCT == 4) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                } else if (keyCT == 5) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                } else if (keyCT == 6) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                } else if (keyCT == 7) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                } else {
                                    tmpsay = 'Section NONE Not Setup';
                                };
                                //} else if ([].indexOf(lookL[]) != -1 && [].indexOf(lookR[]) != -1) {
                                if (k0 > cks && k0 < cke && tmpsay != '') {
                                    sayIt(tmpsay + ' Line ' + k0);
                                    vewAct(k0, cks, cke, 17, '<<' + tmpsay +'>>');
                                };


                                // --- auto removal... None to remove

                                vewAct(k0,cks, cke, 10, '\n\nAdjustments: ===C=O=P=Y==>\tKeys: ' + conPath(curKeys) + '\n' + 'result' + '\n\n');
                                vewAct(k0, cks, cke, 11, result);
                                wrksect = 'clSquare';
                                wrksqre = false;
                            } else if (wrksect == 'opSquare') {
                                vewAct(k0, cks, cke, 9, 'actpt' + '\n' + orig.substring(actpt[actpt.length -1], k0));
                                valvalue = orig.substring(actpt[actpt.length - 1], k0);
                                actpt.push(k0);

                                adjval = cleaNewDic1Val(valvalue, k0);

                                vewAct(k0, cks, cke, 4, 'Key Count: ' + keyCT + '\tVALUE Value: ' + valvalue + '\nActions Points: ' + 'actpt');
                                vewAct(k0, cks, cke, 8, '\n\no\t' + adjval + '\to\n\n');


                                // note: Automatically remove the key and subtract count, plus else
                                // thekeys.push(adjval); // place value in total key variable
                                // pthKeys = curKeys; // path keys do not use the last location
                                // curKeys += ' <~> ' + adjval // start the key string observer
                                chKeys = conPath(curKeys); // all except the last, however last is present. not using last though
                                xit = false;
                                lct1 = -1;
                                lct2 = -1;
                                lct3 = -1;
                                lct4 = -1;
                                // --- end auto ---

                                if (keyCT == 1) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                } else if (keyCT == 2) {
                                    tmpsay = '';
                                    // tmpsay = 'Working IN: ' + sect + ' Section, area: ' + wrksect + ', Key Count: ' + keyCT;
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1: ' + result[a]);
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found 2: ' + result[lct1][b]);
                                                    lct2++;
                                                    result[lct1][lct2].push(adjval);
                                                    xit = true;
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };

                                } else if (keyCT == 3) {
                                    // tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                    tmpsay = "";
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1: ' + result[a]);
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found 2');
                                                    lct2++;
                                                    for (c in result[lct1][lct2]) {
                                                        lct3++;
                                                        if (result[lct1][lct2][c] == chKeys[2]) {
                                                            // console.log('Found it: ' + result[lct1][lct2][c]);
                                                            lct3++;
                                                            result[lct1][lct2][lct3].push( adjval, [] );
                                                            xit = true;
                                                            break;
                                                        };
                                                    };
                                                };
                                                if (xit == true) {
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };
                                } else if (keyCT == 4) {
                                    // tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                    tmpsay = "";
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1: ' + result[a]);
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found 2');
                                                    lct2++;
                                                    for (c in result[lct1][lct2]) {
                                                        lct3++;
                                                        if (result[lct1][lct2][c] == chKeys[2]) {
                                                            // console.log('Found it: ' + result[lct1][lct2][c]);
                                                            lct3++;
                                                            for (d in result[lct1][lct2][lct3]) {
                                                                lct4++;
                                                                if (result[lct1][lct2][lct3][d] == chKeys[3]) {
                                                                    lct4++;
                                                                    result[lct1][lct2][lct3][lct4].push( adjval, [] );
                                                                    xit = true;
                                                                    break;
                                                                };
                                                            };
                                                        };
                                                        if (xit == true) {
                                                            break;
                                                        };
                                                    };
                                                };
                                                if (xit == true) {
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };
                                } else if (keyCT == 5) {
                                    // tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1: ' + result[a]);
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found 2');
                                                    lct2++;
                                                    for (c in result[lct1][lct2]) {
                                                        lct3++;
                                                        if (result[lct1][lct2][c] == chKeys[2]) {
                                                            // console.log('Found it: ' + result[lct1][lct2][c]);
                                                            lct3++;
                                                            for (d in result[lct1][lct2][lct3]) {
                                                                lct4++;
                                                                if (result[lct1][lct2][lct3][d] == chKeys[3]) {
                                                                    lct4++;
                                                                    for (e in result[lct1][lct2][lct3][lct4]) {
                                                                        lct5++;
                                                                        if (result[lct1][lct2][lct3][lct4][e] == chKeys[4]) {
                                                                            lct5++;
                                                                            result[lct1][lct2][lct3][lct4][lct5].push( adjval, [] );
                                                                            xit = true;
                                                                            break;
                                                                        };
                                                                    };
                                                                };
                                                                if (xit == true) {
                                                                    break;
                                                                };
                                                            };
                                                        };
                                                        if (xit == true) {
                                                            break;
                                                        };
                                                    };
                                                };
                                                if (xit == true) {
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };
                                } else if (keyCT == 6) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                } else if (keyCT == 7) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                } else {
                                    tmpsay = 'Section NONE Not Setup';
                                };
                                //} else if ([].indexOf(lookL[]) != -1 && [].indexOf(lookR[]) != -1) {
                                if (k0 > cks && k0 < cke && tmpsay != '') {
                                    sayIt(tmpsay + ' Line ' + k0);
                                    vewAct(k0, cks, cke, 17, '<<' + tmpsay +'>>');
                                };


                                // --- auto removal... None to remove

                                vewAct(k0,cks, cke, 10, '\n\nAdjustments: ===C=O=P=Y==>\tKeys: ' + conPath(curKeys) + '\n' + 'result' + '\n\n');
                                vewAct(k0, cks, cke, 11, result);
                                wrksect = 'clSquare';
                                wrksqre = false;


                            } else {
                                tmpsay = 'CLOSE SQUARE Response from ' + wrksect +' Not SetUp';
                                console.log ('\n\nKey Count: ' + keyCT + '\n(4710523) This ' + tmpsay + '.\n\t\t'+orig.substring(k0-10, k0+10)+'\nLast: ' + lookL[9] + '\nNext: ' + lookR[9]);
                                if (k0 > cks && k0 < cke && tmpsay != '') {
                                    sayIt(tmpsay + ' Line ' + k0);
                                };
                            };
                        } else if ((['&#39;','&#34;'].indexOf(lookL[5]) != -1 && [']}, &#39;',"]}, &#34;"].indexOf(lookR[9]) != -1) || (["'",'"'].indexOf(lookL[1]) != -1 && ["]}, '",']}, "'].indexOf(lookR[5]) != -1)) {
                            // close out last value... acknowledge array is close for list values
                            if (wrksect == 'coMma') {
                                vewAct(k0, cks, cke, 9, 'actpt' + '\n' + orig.substring(actpt[actpt.length -1], k0));
                                valvalue = orig.substring(actpt[actpt.length - 1], k0);
                                actpt.push(k0);

                                adjval = cleaNewDic1Val(valvalue, k0);

                                vewAct(k0, cks, cke, 4, 'Key Count: ' + keyCT + '\tVALUE Value: ' + valvalue + '\nActions Points: ' + 'actpt');
                                vewAct(k0, cks, cke, 8, '\n\no\t' + adjval + '\to\n\n');


                                // note: Automatically remove the key and subtract count, plus else
                                // thekeys.push(adjval); // place value in total key variable
                                // pthKeys = curKeys; // path keys do not use the last location
                                // curKeys += ' <~> ' + adjval // start the key string observer
                                chKeys = conPath(curKeys); // all except the last, however last is present. not using last though
                                xit = false;
                                lct1 = -1;
                                lct2 = -1;
                                lct3 = -1;
                                lct4 = -1;
                                // --- end auto ---

                                if (keyCT == 1) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                } else if (keyCT == 2) {
                                    tmpsay = '';
                                    // tmpsay = 'Working IN: ' + sect + ' Section, area: ' + wrksect + ', Key Count: ' + keyCT;
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1: ' + result[a]);
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found 2: ' + result[lct1][b]);
                                                    lct2++;
                                                    result[lct1][lct2].push(adjval);
                                                    xit = true;
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };

                                } else if (keyCT == 3) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                } else if (keyCT == 4) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                } else if (keyCT == 5) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                } else if (keyCT == 6) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                } else if (keyCT == 7) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                } else {
                                    tmpsay = 'Section NONE Not Setup';
                                };
                                //} else if ([].indexOf(lookL[]) != -1 && [].indexOf(lookR[]) != -1) {
                                if (k0 > cks && k0 < cke && tmpsay != '') {
                                    sayIt(tmpsay + ' Line ' + k0);
                                    vewAct(k0, cks, cke, 17, '<<' + tmpsay +'>>');
                                };


                                // --- auto removal... None to remove

                                vewAct(k0,cks, cke, 10, '\n\nAdjustments: ===C=O=P=Y==>\tKeys: ' + conPath(curKeys) + '\n' + 'result' + '\n\n');
                                vewAct(k0, cks, cke, 11, result);
                                wrksect = 'clSquare';
                                wrksqre = false;
                            } else if (wrksect == 'opSquare') {
                                vewAct(k0, cks, cke, 9, 'actpt' + '\n' + orig.substring(actpt[actpt.length -1], k0));
                                valvalue = orig.substring(actpt[actpt.length - 1], k0);
                                actpt.push(k0);

                                adjval = cleaNewDic1Val(valvalue, k0);

                                vewAct(k0, cks, cke, 4, 'Key Count: ' + keyCT + '\tVALUE Value: ' + valvalue + '\nActions Points: ' + 'actpt');
                                vewAct(k0, cks, cke, 8, '\n\no\t' + adjval + '\to\n\n');


                                // note: Automatically remove the key and subtract count, plus else
                                // thekeys.push(adjval); // place value in total key variable
                                // pthKeys = curKeys; // path keys do not use the last location
                                // curKeys += ' <~> ' + adjval // start the key string observer
                                chKeys = conPath(curKeys); // all except the last, however last is present. not using last though
                                xit = false;
                                lct1 = -1;
                                lct2 = -1;
                                lct3 = -1;
                                lct4 = -1;
                                // --- end auto ---

                                if (keyCT == 1) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                } else if (keyCT == 2) {
                                    tmpsay = '';
                                    // tmpsay = 'Working IN: ' + sect + ' Section, area: ' + wrksect + ', Key Count: ' + keyCT;
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1: ' + result[a]);
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found 2: ' + result[lct1][b]);
                                                    lct2++;
                                                    result[lct1][lct2].push(adjval);
                                                    xit = true;
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };

                                } else if (keyCT == 3) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                } else if (keyCT == 4) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                } else if (keyCT == 5) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                } else if (keyCT == 6) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                } else if (keyCT == 7) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                } else {
                                    tmpsay = 'Section NONE Not Setup';
                                };
                                //} else if ([].indexOf(lookL[]) != -1 && [].indexOf(lookR[]) != -1) {
                                if (k0 > cks && k0 < cke && tmpsay != '') {
                                    sayIt(tmpsay + ' Line ' + k0);
                                    vewAct(k0, cks, cke, 17, '<<' + tmpsay +'>>');
                                };


                                // --- auto removal... None to remove

                                vewAct(k0,cks, cke, 10, '\n\nAdjustments: ===C=O=P=Y==>\tKeys: ' + conPath(curKeys) + '\n' + 'result' + '\n\n');
                                vewAct(k0, cks, cke, 11, result);
                                wrksect = 'clSquare';
                                wrksqre = false;

                            } else {
                                tmpsay = 'CLOSE SQUARE Response from ' + wrksect +' Not SetUp';
                                console.log ('\n\nKey Count: ' + keyCT + '\n(41523) This ' + tmpsay + '.\n\t\t'+orig.substring(k0-10, k0+10)+'\nLast: ' + lookL[9] + '\nNext: ' + lookR[9]);
                                if (k0 > cks && k0 < cke && tmpsay != '') {
                                    sayIt(tmpsay + ' Line ' + k0);
                                };
                            };
                        } else if (['&#39;','&#34;'].indexOf(lookL[5]) != -1 && [']}'].indexOf(lookR[2]) != -1) {
                            //
                            if (wrksect == 'coMma') {
                                //
                                vewAct(k0, cks, cke, 9, 'actpt' + '\n' + orig.substring(actpt[actpt.length -1], k0));
                                valvalue = orig.substring(actpt[actpt.length - 1], k0);
                                actpt.push(k0);

                                adjval = cleaNewDic1Val(valvalue, k0);

                                vewAct(k0, cks, cke, 4, 'Key Count: ' + keyCT + '\tVALUE Value: ' + valvalue + '\nActions Points: ' + 'actpt');
                                vewAct(k0, cks, cke, 8, '\n\no\t' + adjval + '\to\n\n');


                                // note: Automatically remove the key and subtract count, plus else
                                // thekeys.push(adjval); // place value in total key variable
                                // pthKeys = curKeys; // path keys do not use the last location
                                // curKeys += ' <~> ' + adjval // start the key string observer
                                chKeys = conPath(curKeys); // all except the last, however last is present. not using last though
                                xit = false;
                                lct1 = -1;
                                lct2 = -1;
                                lct3 = -1;
                                lct4 = -1;
                                // --- end auto ---

                                if (keyCT == 1) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                    tmpsay = "";
                                    for (a in result) {
                                        lct1++;
                                        if (result[a] == chKeys[0]) {
                                            lct1++;
                                            result[lct1].push( adjval );
                                            break;
                                        };
                                    }
                                } else if (keyCT == 2) {
                                    tmpsay = '';
                                    // tmpsay = 'Working IN: ' + sect + ' Section, area: ' + wrksect + ', Key Count: ' + keyCT;
                                    for (a in result) {
                                        lct1++;
                                        // console.log(result[a]);
                                        if (result[a] == chKeys[0]) {
                                            // console.log('Found 1: ' + result[a]);
                                            lct1++;
                                            for(b in result[lct1]) {
                                                lct2++;
                                                // console.log(result[lct1][b]);
                                                if (result[lct1][b] == chKeys[1]) {
                                                    // console.log('Found 2: ' + result[lct1][b]);
                                                    lct2++;
                                                    result[lct1][lct2].push(adjval);
                                                    xit = true;
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };

                                } else if (keyCT == 3) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                } else if (keyCT == 4) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                } else if (keyCT == 5) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                } else if (keyCT == 6) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                } else if (keyCT == 7) {
                                    tmpsay = 'Section ' +  keyCT + ' Not Setup';
                                } else {
                                    tmpsay = 'Section NONE Not Setup';
                                };
                                //} else if ([].indexOf(lookL[]) != -1 && [].indexOf(lookR[]) != -1) {
                                if (k0 > cks && k0 < cke && tmpsay != '') {
                                    sayIt(tmpsay + ' Line ' + k0);
                                    vewAct(k0, cks, cke, 17, '<<' + tmpsay +'>>');
                                };


                                // --- auto removal... None to remove

                                vewAct(k0,cks, cke, 10, '\n\nAdjustments: ===C=O=P=Y==>\tKeys: ' + conPath(curKeys) + '\n' + 'result' + '\n\n');
                                vewAct(k0, cks, cke, 11, result);
                                wrksect = 'clSquare';
                                wrksqre = false;
                            } else {
                                tmpsay = 'CLOSE SQUARE Response from ' + wrksect +' Not SetUp';
                                console.log ('\n\nKey Count: ' + keyCT + '\n(461723) This ' + tmpsay + '.\n\t\t'+orig.substring(k0-10, k0+10)+'\nLast: ' + lookL[9] + '\nNext: ' + lookR[9]);
                                if (k0 > cks && k0 < cke && tmpsay != '') {
                                    sayIt(tmpsay + ' Line ' + k0);
                                };
                            };
                        // } else if (speChk(lookL[5]) == false && wrksqre == false) {
                        //     if (['opSquare','coLon'].indexOf(wrksect) != -1) {
                        //         vewAct(k0, cks, cke, 'Non-Important Close Square Bracket;\tSkip this...');
                        //         vewAct(k0, cks, cke, 'CLOSE SQUARE BRACKET');
                        //     };
                        //     wrksqre = false;
                        //     wrksect = 'clSquare';
                        } else if (passableChk(lookL[0],'acdeilnot','R&#394 ~',viewpos)) {
                            // passable open brackets
                            console.log('\nNon-Important Close Square Bracket;\tSkip this...\n'+viewpos);
                        } else {
                            tmpsay = "Close Square Bracket Instructions Not Setup\t\tLine: " + k0;
                            console.log('\n\t\t\t*********************************************************************');
                            console.log('\t\t\t*\t' + tmpsay + '\t*' );
                            console.log('\t\t\t*\t\t' + viewpos + '\t\t\t*');
                            console.log('\t\t\t*********************************************************************\n');
                            tmp = passableChk(lookL[0],'deio','&#394',viewpos);
                            if (k0 > cks && k0 < cke && tmpsay != '') {
                                sayIt(tmpsay);
                            };
                        };
                    } else {
                        // Not one of the main characters
                        // vewAct(k0, cks, cke, '\n\t\t\tCommand Character: ' + orig[k0] + ' Not SETUP');
                        tmpsay = "Command Character Not Setup";
                        console.log('\n\n\t\t\t*************************************');
                        console.log('\t\t\t*\tCommand Character: ' + orig[k0] + ' Not SETUP\t*');
                        console.log('\t\t\t*************************************\n');
                        //} else if ([].indexOf(lookL[]) != -1 && [].indexOf(lookR[]) != -1) {
                        if (k0 > cks && k0 < cke && tmpsay != '') {
                            sayIt(tmpsay + ' Line ' + k0);
                        };
                    };
                };
            };
            return result;
        };
        function getInfo(val1,val2) {
            // key will be 1 array value and the dic
            // example: getInfo(['Key 1','Key 2','Key 3','Key 4', 'etc.'], dictionary from py) // must be entered as an array, and dic in string form.
            // console.log('Key: ' + val1);
            // console.log('Dic: ' + val2.substring(0,1000));
            // check key to make sure its a array (may 8)
            // convert Dic to array
            var dic = nwDic(val2);

            var subk = [];
            var dkey = 0;
            for ( var i=0; i<8; i++) {
                // console.log(i);
                // console.log(val1[i]);
                if (val1[i] != undefined) {
                    subk[i] = val1[i];
                    dkey++;
                } else {
                    subk[i] = "";
                };
            };

            // retrieve data
            var nkey = 0;
            var locN = [];
            var lct1 = -1;
            var lct2 = -1;
            var lct3 = -1;
            var lct4 = -1;
            var lct5 = -1;
            var lct6 = -1;
            var lct7 = -1;
            var xit = false;

            for (i in dic) {
                lct1++;
                // console.log(dic[i]);

                if (dic[i] == subk[nkey]) {
                    // console.log('\nfound 1\t' + subk[nkey]);
                    lct1++;
                    nkey++;
                    locN.push(Number(lct1));
                    if (nkey == dkey) {
                        xit = true;
                        break;
                    };

                    for (j in dic[lct1]){
                        lct2++;
                        // console.log('\t' + dic[lct1][j]);

                        if (dic[lct1][j] == subk[nkey]) {
                            // console.log('\n\tfound 2\t' + subk[nkey]);
                            lct2++;
                            nkey++;
                            locN.push(Number(lct2));
                            if (nkey == dkey) {
                                xit = true;
                                break;
                            };

                            for (k in dic[lct1][lct2]) {
                                lct3++;
                                // console.log('\t\t' + dic[lct1][lct2][k]);

                                if (dic[lct1][lct2][k] == subk[nkey]) {
                                    // console.log('\n\t\tfound 3\t' + subk[nkey]);
                                    lct3++;
                                    nkey++;
                                    locN.push(Number(lct3));
                                    if (nkey == dkey) {
                                        xit = true;
                                        break;
                                    };

                                    for (l in dic[lct1][lct2][lct3]) {
                                        lct4++;
                                        // console.log('\t\t\t' + dic[lct1][lct2][lct3][l]);

                                        if (dic[lct1][lct2][lct3][l] == subk[nkey]) {
                                            // console.log('\n\t\t\tfound 4\t' + subk[nkey]);
                                            lct4++;
                                            nkey++;
                                            locN.push(Number(lct4));
                                            if (nkey == dkey) {
                                                xit = true;
                                                break;
                                            };

                                            for (m in dic[lct1][lct2][lct3][lct4]) {
                                                lct5++;
                                                // console.log('\t\t\t\t' + dic[lct1][lct2][lct3][lct4][m]);

                                                if (dic[lct1][lct2][lct3][lct4][m] == subk[nkey]) {
                                                    // console.log('\n\t\t\t\tfound 5 ' + subk[nkey]);
                                                    lct5++;
                                                    nkey++;
                                                    locN.push(Number(lct5));
                                                    if (nkey == dkey) {
                                                        xit = true;
                                                        break;
                                                    };

                                                    for (n in dic[lct1][lct2][lct3][lct4][lct5]) {
                                                        lct6++;
                                                        // console.log('\t\t\t\t\t' + dic[lct1][lct2][lct3][lct4][lct5][n]);

                                                        if (dic[lct1][lct2][lct3][lct4][lct5][n] == subk[nkey]) {
                                                            // console.log('\t\t\t\t\tfound 6 ' + subk[nkey]);
                                                            lct6++;
                                                            nkey++;
                                                            locN.push(Number(lct6));
                                                            if (nkey == dkey) {
                                                                xit = true;
                                                                break;
                                                            };

                                                            for (o in dic[lct1][lct2][lct3][lct4][lct5][lct6]) {
                                                                lct7++;
                                                                // console.log('\t\t\t\t\t\tfound 7 ' + subk[nkey]);
                                                                lct7++;
                                                                nkey++;
                                                                locN.push(Number(lct7));
                                                                if (nkey == dkey) {
                                                                    xit = true;
                                                                    break;
                                                                };
                                                            };
                                                            if (xit == true) {
                                                                break;
                                                            };
                                                        };
                                                    };
                                                    if (xit == true) {
                                                        break;
                                                    };
                                                };
                                            };
                                            if (xit == true) {
                                                break;
                                            };
                                        };
                                    };
                                    if (xit == true) {
                                        break;
                                    };
                                };
                            };
                            if (xit == true) {
                                break;
                            };
                        };
                    };
                    if (xit == true) {
                        break;
                    };
                };
            };
            // console.log('Location Numbers: ' + locN);
            // console.log(subk);
            if (locN.length == 1 && dkey == 1) {
                answer = dic[locN[0]];

            } else if (locN.length == 2 && dkey == 2) {
                answer = dic[locN[0]][locN[1]];

            } else if (locN.length == 3 && dkey == 3) {
                answer = dic[locN[0]][locN[1]][locN[2]];

            } else if (locN.length == 4 && dkey == 4) {
                answer = dic[locN[0]][locN[1]][locN[2]][locN[3]];

            } else if (locN.length == 5 && dkey == 5) {
                answer = dic[locN[0]][locN[1]][locN[2]][locN[3]][locN[4]];

            } else if (locN.length == 6 && dkey == 6) {
                answer = dic[locN[0]][locN[1]][locN[2]][locN[3]][locN[4]][locN[5]];

            } else if (locN.length == 7 && dkey == 7) {
                answer = dic[locN[0]][locN[1]][locN[2]][locN[3]][locN[4]][locN[5]][locN[6]];

            } else if (locN.length == 8 && dkey == 8) {
                answer = dic[locN[0]][locN[1]][locN[2]][locN[3]][locN[4]][locN[5]][locN[6]][locN[7]];

            } else {
                answer = 'NVE'; // no valid entry
            };
            // console.log('Solution: ' + answer);
            // console.log('==>\t' + dic[1][5]);
            // console.log('==>\t' + dic[1][1][1][19]);
            return answer;
        };
        function getInfoRaw(val1,val2) {
            // key will be 1 array value and the dic
            // example: getInfo(['Key 1','Key 2','Key 3','Key 4', 'etc.'], dictionary from py) // must be entered as an array, and dic in string form.
            // console.log('Key: ' + val1);
            // console.log('Dic: ' + val2.substring(0,1000));
            // check key to make sure its a array (may 8)
            // convert Dic to array
            var dic = nwDic(val2);

            var subk = [];
            var dkey = 0;
            for ( var i=0; i<8; i++) {
                // console.log(i);
                // console.log(val1[i]);
                if (val1[i] != undefined) {
                    subk[i] = val1[i];
                    dkey++;
                } else {
                    subk[i] = "";
                };
            };

            // retrieve data
            var nkey = 0;
            var locN = [];
            var lct1 = -1;
            var lct2 = -1;
            var lct3 = -1;
            var lct4 = -1;
            var lct5 = -1;
            var lct6 = -1;
            var lct7 = -1;
            var xit = false;

            for (i in dic) {
                lct1++;
                // console.log(dic[i]);

                if (dic[i] == subk[nkey]) {
                    // console.log('\nfound 1\t' + subk[nkey]);
                    lct1++;
                    nkey++;
                    locN.push(Number(lct1));
                    if (nkey == dkey) {
                        xit = true;
                        break;
                    };

                    for (j in dic[lct1]){
                        lct2++;
                        // console.log('\t' + dic[lct1][j]);

                        if (dic[lct1][j] == subk[nkey]) {
                            // console.log('\n\tfound 2\t' + subk[nkey]);
                            lct2++;
                            nkey++;
                            locN.push(Number(lct2));
                            if (nkey == dkey) {
                                xit = true;
                                break;
                            };

                            for (k in dic[lct1][lct2]) {
                                lct3++;
                                // console.log('\t\t' + dic[lct1][lct2][k]);

                                if (dic[lct1][lct2][k] == subk[nkey]) {
                                    // console.log('\n\t\tfound 3\t' + subk[nkey]);
                                    lct3++;
                                    nkey++;
                                    locN.push(Number(lct3));
                                    if (nkey == dkey) {
                                        xit = true;
                                        break;
                                    };

                                    for (l in dic[lct1][lct2][lct3]) {
                                        lct4++;
                                        // console.log('\t\t\t' + dic[lct1][lct2][lct3][l]);

                                        if (dic[lct1][lct2][lct3][l] == subk[nkey]) {
                                            // console.log('\n\t\t\tfound 4\t' + subk[nkey]);
                                            lct4++;
                                            nkey++;
                                            locN.push(Number(lct4));
                                            if (nkey == dkey) {
                                                xit = true;
                                                break;
                                            };

                                            for (m in dic[lct1][lct2][lct3][lct4]) {
                                                lct5++;
                                                // console.log('\t\t\t\t' + dic[lct1][lct2][lct3][lct4][m]);

                                                if (dic[lct1][lct2][lct3][lct4][m] == subk[nkey]) {
                                                    // console.log('\n\t\t\t\tfound 5 ' + subk[nkey]);
                                                    lct5++;
                                                    nkey++;
                                                    locN.push(Number(lct5));
                                                    if (nkey == dkey) {
                                                        xit = true;
                                                        break;
                                                    };

                                                    for (n in dic[lct1][lct2][lct3][lct4][lct5]) {
                                                        lct6++;
                                                        // console.log('\t\t\t\t\t' + dic[lct1][lct2][lct3][lct4][lct5][n]);

                                                        if (dic[lct1][lct2][lct3][lct4][lct5][n] == subk[nkey]) {
                                                            // console.log('\t\t\t\t\tfound 6 ' + subk[nkey]);
                                                            lct6++;
                                                            nkey++;
                                                            locN.push(Number(lct6));
                                                            if (nkey == dkey) {
                                                                xit = true;
                                                                break;
                                                            };

                                                            for (o in dic[lct1][lct2][lct3][lct4][lct5][lct6]) {
                                                                lct7++;
                                                                // console.log('\t\t\t\t\t\tfound 7 ' + subk[nkey]);
                                                                lct7++;
                                                                nkey++;
                                                                locN.push(Number(lct7));
                                                                if (nkey == dkey) {
                                                                    xit = true;
                                                                    break;
                                                                };
                                                            };
                                                            if (xit == true) {
                                                                break;
                                                            };
                                                        };
                                                    };
                                                    if (xit == true) {
                                                        break;
                                                    };
                                                };
                                            };
                                            if (xit == true) {
                                                break;
                                            };
                                        };
                                    };
                                    if (xit == true) {
                                        break;
                                    };
                                };
                            };
                            if (xit == true) {
                                break;
                            };
                        };
                    };
                    if (xit == true) {
                        break;
                    };
                };
            };
            // console.log('Location Numbers: ' + locN);
            // console.log(subk);
            if (locN.length == 1 && dkey == 1) {
                answer = dic[locN[0]];
            } else if (locN.length == 2 && dkey == 2) {
                answer = dic[locN[0]][locN[1]];

            } else if (locN.length == 3 && dkey == 3) {
                answer = dic[locN[0]][locN[1]][locN[2]];

            } else if (locN.length == 4 && dkey == 4) {
                answer = dic[locN[0]][locN[1]][locN[2]][locN[3]];

            } else if (locN.length == 5 && dkey == 5) {
                answer = dic[locN[0]][locN[1]][locN[2]][locN[3]][locN[4]];

            } else if (locN.length == 6 && dkey == 6) {
                answer = dic[locN[0]][locN[1]][locN[2]][locN[3]][locN[4]][locN[5]];

            } else if (locN.length == 7 && dkey == 7) {
                answer = dic[locN[0]][locN[1]][locN[2]][locN[3]][locN[4]][locN[5]][locN[6]];

            } else if (locN.length == 8 && dkey == 8) {
                answer = dic[locN[0]][locN[1]][locN[2]][locN[3]][locN[4]][locN[5]][locN[6]][locN[7]];

            } else {
                answer = 'NVE'; // no valid entry
            };
            // console.log('Solution: ' + answer);
            // console.log('==>\t' + dic[1][5]);
            // console.log('==>\t' + dic[1][1][1][19]);
            return answer;
        };
        function getInfoMod(val1,val2) {
            // key will be 1 array value and the dic will be one already sent through the nwDic format. use this so you don't have to go through the nwDic action each time.
            // example: getInfo(['Key 1','Key 2','Key 3','Key 4', 'etc.'], dictionary from py) // must be entered as an array, and dic in string form.
            var showEx = false;
            // console.log('\n\nKey: ' + val1 + '\tType: ' + typeof val1);
            // console.log('\nDic: ' + typeof(val2)); //.substring(0,1000));
            if (['','Test'].indexOf(val1[0]) != -1) {
                showEx = true;
                console.log('\n\n\t\t************ Show Example **********');
            };
            // check key to make sure its a array (may 8)
            // convert Dic to array
            var dic = val2;
            var answer = 'NVE'; // no valid entry
            var rethis = null;
            var dkey = 0;
            var myct = 0;
            var subk = [];
            var entKeys = [];
            var entValues = [];
            // locate keys and subkeys
            for ( var i=0; i<8; i++) {
                // console.log(i);
                if (showEx == true) {
                    console.log(' o  ' + val1[i]);
                };
                if (val1[i] != undefined) {
                    // determine if your returning keys, values, or answer
                    if (['<KEYS>','<VALUES>'].indexOf(val1[i]) != -1) {
                        // console.log('... do ' + val1[i]);
                        if (val1[i] == '<KEYS>') {
                            rethis = 'key';
                        } else if (val1[i] == '<VALUES>') {
                            rethis = 'value';
                        };
                    } else {
                        subk[i] = val1[i];
                        dkey++;
                    }
                } else {
                    subk[i] = "";
                };
            };
            if (showEx == true) {
                console.log('\nSub-Keys: ' + subk);
            };

            // retrieve data
            var nkey = 0;
            var Key1 = [];
            var Value1 = [];
            var locN = [];
            var lct1 = -1;
            var lct2 = -1;
            var lct3 = -1;
            var lct4 = -1;
            var lct5 = -1;
            var lct6 = -1;
            var lct7 = -1;
            var xit = false;

            for (i in dic) {
                lct1++;
                if (showEx == true) {
                    console.log(i + ' <> ' + dic[i]);
                };
                if (oddOrEven(i) == 'even') {
                    // console.log('\to\tKey: ' + answer[i]);
                    Key1.push(dic[i]);
                } else if (oddOrEven(i) == 'odd') {
                    Value1.push(dic[i]);
                }

                if (dic[i] == subk[nkey]) {
                    // console.log('\nfound 1\t' + subk[nkey]);
                    lct1++;
                    nkey++;
                    locN.push(Number(lct1));
                    if (nkey == dkey) {
                        xit = true;
                        break;
                    };

                    for (j in dic[lct1]){
                        lct2++;
                        // console.log('\t' + dic[lct1][j]);

                        if (dic[lct1][j] == subk[nkey]) {
                            // console.log('\n\tfound 2\t' + subk[nkey]);
                            lct2++;
                            nkey++;
                            locN.push(Number(lct2));
                            if (nkey == dkey) {
                                xit = true;
                                break;
                            };

                            for (k in dic[lct1][lct2]) {
                                lct3++;
                                // console.log('\t\t' + dic[lct1][lct2][k]);

                                if (dic[lct1][lct2][k] == subk[nkey]) {
                                    // console.log('\n\t\tfound 3\t' + subk[nkey]);
                                    lct3++;
                                    nkey++;
                                    locN.push(Number(lct3));
                                    if (nkey == dkey) {
                                        xit = true;
                                        break;
                                    };

                                    for (l in dic[lct1][lct2][lct3]) {
                                        lct4++;
                                        // console.log('\t\t\t' + dic[lct1][lct2][lct3][l]);

                                        if (dic[lct1][lct2][lct3][l] == subk[nkey]) {
                                            // console.log('\n\t\t\tfound 4\t' + subk[nkey]);
                                            lct4++;
                                            nkey++;
                                            locN.push(Number(lct4));
                                            if (nkey == dkey) {
                                                xit = true;
                                                break;
                                            };

                                            for (m in dic[lct1][lct2][lct3][lct4]) {
                                                lct5++;
                                                // console.log('\t\t\t\t' + dic[lct1][lct2][lct3][lct4][m]);

                                                if (dic[lct1][lct2][lct3][lct4][m] == subk[nkey]) {
                                                    // console.log('\n\t\t\t\tfound 5 ' + subk[nkey]);
                                                    lct5++;
                                                    nkey++;
                                                    locN.push(Number(lct5));
                                                    if (nkey == dkey) {
                                                        xit = true;
                                                        break;
                                                    };

                                                    for (n in dic[lct1][lct2][lct3][lct4][lct5]) {
                                                        lct6++;
                                                        // console.log('\t\t\t\t\t' + dic[lct1][lct2][lct3][lct4][lct5][n]);

                                                        if (dic[lct1][lct2][lct3][lct4][lct5][n] == subk[nkey]) {
                                                            // console.log('\t\t\t\t\tfound 6 ' + subk[nkey]);
                                                            lct6++;
                                                            nkey++;
                                                            locN.push(Number(lct6));
                                                            if (nkey == dkey) {
                                                                xit = true;
                                                                break;
                                                            };

                                                            for (o in dic[lct1][lct2][lct3][lct4][lct5][lct6]) {
                                                                lct7++;
                                                                // console.log('\t\t\t\t\t\tfound 7 ' + subk[nkey]);
                                                                lct7++;
                                                                nkey++;
                                                                locN.push(Number(lct7));
                                                                if (nkey == dkey) {
                                                                    xit = true;
                                                                    break;
                                                                };
                                                            };
                                                        };
                                                        if (xit == true) {
                                                            break;
                                                        };
                                                    };
                                                };
                                                if (xit == true) {
                                                    break;
                                                };
                                            };
                                        };
                                        if (xit == true) {
                                            break;
                                        };
                                    };
                                };
                                if (xit == true) {
                                    break;
                                };
                            };
                        };
                        if (xit == true) {
                            break;
                        };
                    };
                };
                if (xit == true) {
                    break;
                };
            };
            // console.log('Location Numbers: ' + locN);
            // console.log(subk);
            if (locN.length == 1 && dkey == 1) {
                answer = dic[locN[0]];

            } else if (locN.length == 2 && dkey == 2) {
                answer = dic[locN[0]][locN[1]];

            } else if (locN.length == 3 && dkey == 3) {
                answer = dic[locN[0]][locN[1]][locN[2]];

            } else if (locN.length == 4 && dkey == 4) {
                answer = dic[locN[0]][locN[1]][locN[2]][locN[3]];

            } else if (locN.length == 5 && dkey == 5) {
                answer = dic[locN[0]][locN[1]][locN[2]][locN[3]][locN[4]];

            } else if (locN.length == 6 && dkey == 6) {
                answer = dic[locN[0]][locN[1]][locN[2]][locN[3]][locN[4]][locN[5]];

            } else if (locN.length == 7 && dkey == 7) {
                answer = dic[locN[0]][locN[1]][locN[2]][locN[3]][locN[4]][locN[5]][locN[6]];

            } else if (locN.length == 8 && dkey == 8) {
                answer = dic[locN[0]][locN[1]][locN[2]][locN[3]][locN[4]][locN[5]][locN[6]][locN[7]];

            } else {
                answer = 'NVE'; // no valid entry... already declared in var section
            };

            if (val1 == '<KEYS>') {
                // first line request
                // console.log('Keys Length: ' + Key1.length);
                if (Key1.length > 0) {
                    answer = Key1;
                };
            } else if (val1 == '<VALUES>') {
                // first line request
                if (Key1.length > 0) {
                    answer = Value1;
                };
            } else if (rethis == 'key') {
                // return key
                // answer = 'Key Response';
                for (i in answer) {
                    myct++;
                    if (oddOrEven(myct) == 'odd') {
                        // console.log('\to\tKey: ' + answer[i]);
                        entKeys.push(answer[i]);
                    };
                };
                answer = entKeys;
            } else if (rethis == 'value') {
                // return value
                // answer = 'Value Response';
                for (i in answer) {
                    myct++;
                    if (oddOrEven(myct) == 'even') {
                        // console.log('\to\tValue: ' + answer[i]);
                        entValues.push(answer[i]);
                    };
                };
                answer = entValues;
            } else {
                // return answer
            }
            // console.log('Initial Keys: ' + Key1);
            return answer;
        };

        /*
        * @param {Array} array the original array with all items
        * @param {any} item the time you want to remove
        * @returns {Array} a new Array without the item
        */

        (function($) {
            $.fn.flash_message = function(options) {

              options = $.extend({
                text: 'Done',
                time: 2000,
                how: 'before',
                class_name: ''
              }, options);

              return $(this).each(function() {
                if( $(this).parent().find('.flash_message').get(0) )
                  return;

                var message = $('<span />', {
                  'class': 'flash_message ' + options.class_name,
                  text: options.text
                }).hide().fadeIn('fast');

                $(this)[options.how](message);

                message.delay(options.time).fadeOut('normal', function() {
                  $(this).remove();
                });

              });
            };
        })(jQuery);
        $(document).ready(function(){
        	$('body').addClass('loaded');
            starTime(); // not working in the body tag, but working here
        });
	</script>
</head>
<body>
<div id="mwrap">
    <div class="BS_passmeon">
        <textarea class="bshdflds" id="thisbs4X" name="baseX" style="display: none;" hidden></textarea>
        <textarea class="bshdflds" id="thisbs4Y" name="baseY" style="display: none;" hidden></textarea>
        <textarea class="bshdflds" id="thisbs4C" name="baseC" style="display:none;" hidden></textarea>
        <!-- <textarea class="bshdflds" id="thisbs4X" name="baseX"></textarea>
        <textarea class="bshdflds" id="thisbs4Y" name="baseY"></textarea> -->
    </div>
    <div id="header">
    	<img src="../static/img/Trademark-Crypheka.png" alt="trademark image here?" class="tmark" />
    	<label id="htyle">Crypheka</label>
    </div>

    <div id="content">
        <div id="flashed">



        </div>
    	<button id="navbut" class="topBtns" onclick="openNav()">&#9776;</button>
        <!-- <input type='text' id="cursorX" size="3">
        <input type="text" id="cursorY" size="3"> -->

    <span>
    <button class="topBtns" id="showIn_e">Instructions</button>
    </span>
    <button class="topBtns" id="showTg_e">Specific</button>
    <button class="topBtns" id="showTi_e">Timer</button>
    <button class="topBtns" id="showSp_e">Special</button>
    <button class="disable_it" id="psteButton" onclick="pasteClipboard();" >Paste</button>
    <a class="linktopBtns" href="/cryption/decrypt/">Decrypt</a>

    <br>
    <p class="scrntle">Cipher Screen</p>
    <hr />
    <marquee behavior="scroll" loop="-1" width="75%">
    <strong><span class="red_text"> Under  Construction...</span></strong>
    </marquee>
    <div id="main_section">
        <div id="instruct_div" style="width:80%;background-color: #FDFEE3; display: none">
            <div class="row">
                <div class="col-md-4">
                    <h3>Step 1</h3>
                    <p>Enter the <em>key</em> (word, phrase, etc); This unique entry will be the key, the only thing that can reveal the ciphered message.</p>
                <div class="col-md-4">
                    <h3>Step 2</h3>
                </div>
                    <p>Enter the desired message or upload the file you wish to encrypt. (max 5mb)</p>
                </div><!--col-md-4-->

                <div class="col-md-4">
                    <h3>Step 3</h3>
                    <p>You can include additional protection options.&nbsp;&nbsp;The options above can be combined. (See About for breakdown of each option.)</p>
                </div><!--col-md-4-->

                <div class="col-md-4">
                    <h3>Step 4</h3>
                    <p>After you have filled the required fields; Select the "Cipher" button, to convert the message into an encrypted text.&nbsp;&nbsp;You can place the encrypted message in any document or download the encrypted file.&nbsp;&nbsp;You can also  use the Cryptelle Service to send via email.</p>
                </div>
                <div class="col-md-4">
                    <h3>Note</h3>
                    <p>It will be on the recipient to decipher this message by coming back to this web site or by using the software version.</p>
                </div><!--col-md-4-->
                <button class="xitdlg" id="xit_instr">Close Instructions</button>
            </div><!--row for all three steps-->
        </div>

        <div id="target_div" style="width:59%;background-color: #FDFEE3; display: none">
            <p>Enter Specific Device Info</p>

                <textarea class="targentries" id="targ_One" placeholder="Info One..." ></textarea><br />

                <textarea class="targentries" id="targ_Two" placeholder="Info Two..." ></textarea><br />

                <textarea class="targentries" id="targ_Three" placeholder="Info Three..." ></textarea><br />

                <textarea class="targentries" id="targ_Four" placeholder="Info Four..." ></textarea><br />

                <textarea class="targentries" id="targ_Five" placeholder="Info Five..." ></textarea><br />

                <textarea class="targentries" id="targ_Six" placeholder="Info Six..." ></textarea><br />

            <button class="acpdlg" id="submitTg">Submit</button>
            <button class="xitdlg" id="xit_targ">Cancel</button>
            <button class="clrdlg" id="clr_targ">Clear</button>
            <br /><br />note: Can Be Deciphered With Software Version ONLY
        </div>

        <div id="timer_div" style="width:80%;background-color: #FDFEE3; display: none">


                <!-- firefox, safari, msie not working -->

            <hr/>
            <span>The Current Coordinated Universal Time (UTC):
            <span style="background-color: #BBB222;">
            &nbsp;&nbsp;&nbsp;<em id="uDate"></em>&nbsp;&nbsp;&nbsp;&nbsp;<em id="uClock"></em>&nbsp;&nbsp;&nbsp;&nbsp;</span></span>
            <p>Based on your time zone, you will have to adjust; plus or <br/>
            minus daylight savings time to suit your need.<br/>
            Time Format <span style="background-color: #BBB222;">HH:MM</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Date Format <span style="background-color: #BBB222;">DD-MMM-YYYY</span><br/>
            (also don't forget to adjust the date to the UTC Date)</p>
            <p>This Encryption Can Only Be Deciphered Between The Chosen Time/Date.</p>
            <p>
                <table border=0>
                    <tr>
                        <th colspan=2> (Optional) Start Time:</th>
                        <th style="width: 15%"></th>
                        <th colspan=2> (Optional) Expired Time:</th>
                    </tr>
                    <tr>
                        <td><textarea rows="1" cols="5" id="timdsply1" disabled="true"></textarea></td>
                        <td><input id="start_tm" class='timepicker' size='5'  title='HH:MM' onblur="chkTimentry();" /></td>
                        <td style="width: 15%;"></td>
                        <td><textarea rows="1" cols="5" id="timdsply2" disabled="true"></textarea></td>
                        <td><input id="end_tm" class='timepicker' size='5'  title='HH:MM' /></td>
                    </tr>
                    <tr style="height: 15px"></tr>
                    <tr>
                        <th colspan=2> (Optional) Start Date:</th>
                        <th style="width: 15%"></th>
                        <th colspan=2> (Optional) Expired Date:</th>
                    </tr>
                    <tr>
                        <td colspan=2>
                            <input id="start_dt" class='datepicker' size='11' title='D-MMM-YYYY' />
                        </td>

                        <td style="width: 5%;"></td>
                        <td colspan=2>
                            <input id="end_dt" class='datepicker' size='11' title='D-MMM-YYYY' />
                        </td>
                    </tr>
                </table>
            </p>
            <button class="acpdlg" id="submitTi">Submit</button>
            <button class="xitdlg" id="xit_time">Cancel</button>
            <button class="clrdlg" id="clr_time">Clear</button>
        </div>

        <div id="special_div" style="width:59%;background-color: #FDFEE3; display: none">
            (Optional) Enter Dialer<br />
            <input type="text" id="miscdial" placeholder="Special Use Only" /><br /><br />
            (Optional) Secondary<br />
            <input type='text' id="misc2nd" placeholder="Secondary" /><br /><br />
            <button class="acpdlg" id="submitSp">Submit</button>
            <button class="xitdlg" id="xit_spec">Cancel</button>
            <button class="clrdlg" id="clr_spec">Clear</button>
        </div>

        <form method="post" name="enc_sect" enctype="multipart/form-data" autocomplete="off">
            <div>
                <textarea class="enctihdFld" id="enc_date1" name="entDate1" style="display:none;" hidden></textarea>
                <textarea class="enctihdFld" id="enc_time1" name="entTime1" style="display:none;" hidden></textarea>
                <textarea class="enctihdFld" id="enc_date2" name="entDate2" style="display:none;" hidden></textarea>
                <textarea class="enctihdFld" id="enc_time2" name="entTime2" style="display:none;" hidden></textarea>
                <textarea class="encsphdFld" id="enc_2nd" name="ent2nd" style="display:none;" hidden></textarea>
                <textarea class="encsphdFld" id="enc_dial" name="entdial" style="display:none;" hidden></textarea>
                <textarea class="encsphdFld" id="enc_level" name="entLevel" style="display:none;" hidden></textarea>

                    <textarea class="enctghdFld" id="enc_t_One" name="entTOne" style="display:none;" hidden></textarea>

                    <textarea class="enctghdFld" id="enc_t_Two" name="entTTwo" style="display:none;" hidden></textarea>

                    <textarea class="enctghdFld" id="enc_t_Three" name="entTThree" style="display:none;" hidden></textarea>

                    <textarea class="enctghdFld" id="enc_t_Four" name="entTFour" style="display:none;" hidden></textarea>

                    <textarea class="enctghdFld" id="enc_t_Five" name="entTFive" style="display:none;" hidden></textarea>

                    <textarea class="enctghdFld" id="enc_t_Six" name="entTSix" style="display:none;" hidden></textarea>

            </div>
            <div id="encrapper">
                <div id="encrtside">
                    <div class="ctrl_btns">
                        <!-- instead of using input; use button, by placing image inside button -->
                        <!-- receive icons from http://findicons.com -->
                        <!-- <input type="image" img src="../static/img/lock_closed.png" alt="" name="proceed1" value="Cipher" id="encbut"><br> -->
                        <!-- <a href="#" id="encbut"><img src="../static/img/lock_closed.png" alt="">Cipher</a><br> -->
                        <!-- <input type="submit" name="proceed1" class="b1n" value="Cipher" id="encbut" style="font-size: 105%;"><br> -->
                        <div class="b1n">
                            <button type="submit" name="proceed1" value="Cipher" class="fctbut" id="encbut"><img src="../static/img/lock_closed.png" alt="">Cipher</button>
                        </div>
                        <div class="b1n">
                            <button type="submit" name="proceed1" value="Cryptelle" class="fctbut" id="encmal"><img src="../static/img/mail.png" alt="">Cryptelle</button>
                        </div>
                        <div class="b1n">
                            <a class="ReadMe" id="readaloud1"><img src="../static/img/Music_Icon_48.png" alt="">Read</a>
                        </div>
                        <div class="redo">
                            <button type="reset" name="proceed1" value="Clear" class="clrbut" id="enclr"><img src="../static/img/erase.png" alt="">Clear</button>
                        </div>
                    </div>
                </div>
                <div id="encltside">
                    <div id="kstxtenc">View The Cipher Key Here</div>

                    <div class="tooltip">
                            <input type="text" name="entekey" id="enc_ek" class="enter_ekey"
                                autocomplete="off" tabindex="1"
                                placeholder="Enter Special Key" required
                            />
                        <span class="tooltiptext">No Restrictions</span>
                        <div>
                            <a href=# class="enClear" id="enclr_pw">Clear</a>
                            <select id="ciplvl">
                                <!--  -->
                                        <option class="eselbnfrom" value="Level 1" id="cplvl1" selected="Level 1">Cipher I</option>
                                        <option class="eselbnfrom" value="Level 2" id="cplvl2">Cipher II</option>
                                        <option class="eselbnfrom" value="Level 3" id="cplvl3">Cipher III</option>
                                <!--  -->
                            </select>
                        </div>
                    </div>

                    <div class="entry_sect">
                        <textarea id="enc_ed" class="enter2encyrpt" name="entedata" tabindex="2"
                             placeholder="Enter the content you wish to encrypt... (All Accepted)" ></textarea>
                    </div>

                    <div class="file_sect">
                        <!-- <input type="file" name="ufile" class="tfilemk" id="uplfile" onchange="loadFile(event)"> -->
                        <a href=# class="enClear" id="enclr_en">Clear</a>
                        <input class="choosefile" type="file" name="ufile[]" id="uplfile" multiple />
                        <output id="thelist"></output>
                        <!--
                            <img id="output" width="100" height="100"></img>
                         -->
                    </div>

                </div>
                <div id="eprog1" class="flopwurd" display: hidden>

                        <div class="cyphflw">G</div>

                        <div class="cyphflw">N</div>

                        <div class="cyphflw">I</div>

                        <div class="cyphflw">R</div>

                        <div class="cyphflw">E</div>

                        <div class="cyphflw">H</div>

                        <div class="cyphflw">P</div>

                        <div class="cyphflw">I</div>

                        <div class="cyphflw">C</div>

                </div>
                <div id="eprog2" display: hidden>
                    <ul class="loadbar">

                            <li><div id="elayerFill0" class="bar"></div></li>

                            <li><div id="elayerFill1" class="bar"></div></li>

                            <li><div id="elayerFill2" class="bar"></div></li>

                            <li><div id="elayerFill3" class="bar"></div></li>

                            <li><div id="elayerFill4" class="bar"></div></li>

                            <li><div id="elayerFill5" class="bar"></div></li>

                            <li><div id="elayerFill6" class="bar"></div></li>

                            <li><div id="elayerFill7" class="bar"></div></li>

                            <li><div id="elayerFill8" class="bar"></div></li>

                            <li><div id="elayerFill9" class="bar"></div></li>

                            <li><div id="elayerFill10" class="bar"></div></li>

                            <li><div id="elayerFill11" class="bar"></div></li>

                            <li><div id="elayerFill12" class="bar"></div></li>

                            <li><div id="elayerFill13" class="bar"></div></li>

                            <li><div id="elayerFill14" class="bar"></div></li>

                            <li><div id="elayerFill15" class="bar"></div></li>

                            <li><div id="elayerFill16" class="bar"></div></li>

                            <li><div id="elayerFill17" class="bar"></div></li>

                            <li><div id="elayerFill18" class="bar"></div></li>

                            <li><div id="elayerFill19" class="bar"></div></li>

                            <li><div id="elayerFill20" class="bar"></div></li>

                            <li><div id="elayerFill21" class="bar"></div></li>

                            <li><div id="elayerFill22" class="bar"></div></li>

                            <li><div id="elayerFill23" class="bar"></div></li>

                            <li><div id="elayerFill24" class="bar"></div></li>

                            <li><div id="elayerFill25" class="bar"></div></li>

                            <li><div id="elayerFill26" class="bar"></div></li>

                            <li><div id="elayerFill27" class="bar"></div></li>

                            <li><div id="elayerFill28" class="bar"></div></li>

                            <li><div id="elayerFill29" class="bar"></div></li>

                            <li><div id="elayerFill30" class="bar"></div></li>

                            <li><div id="elayerFill31" class="bar"></div></li>

                            <li><div id="elayerFill32" class="bar"></div></li>

                            <li><div id="elayerFill33" class="bar"></div></li>

                            <li><div id="elayerFill34" class="bar"></div></li>

                            <li><div id="elayerFill35" class="bar"></div></li>

                            <li><div id="elayerFill36" class="bar"></div></li>

                            <li><div id="elayerFill37" class="bar"></div></li>

                            <li><div id="elayerFill38" class="bar"></div></li>

                            <li><div id="elayerFill39" class="bar"></div></li>

                            <li><div id="elayerFill40" class="bar"></div></li>

                            <li><div id="elayerFill41" class="bar"></div></li>

                            <li><div id="elayerFill42" class="bar"></div></li>

                            <li><div id="elayerFill43" class="bar"></div></li>

                            <li><div id="elayerFill44" class="bar"></div></li>

                            <li><div id="elayerFill45" class="bar"></div></li>

                            <li><div id="elayerFill46" class="bar"></div></li>

                            <li><div id="elayerFill47" class="bar"></div></li>

                            <li><div id="elayerFill48" class="bar"></div></li>

                            <li><div id="elayerFill49" class="bar"></div></li>

                            <li><div id="elayerFill50" class="bar"></div></li>

                            <li><div id="elayerFill51" class="bar"></div></li>

                            <li><div id="elayerFill52" class="bar"></div></li>

                            <li><div id="elayerFill53" class="bar"></div></li>

                            <li><div id="elayerFill54" class="bar"></div></li>

                            <li><div id="elayerFill55" class="bar"></div></li>

                            <li><div id="elayerFill56" class="bar"></div></li>

                            <li><div id="elayerFill57" class="bar"></div></li>

                            <li><div id="elayerFill58" class="bar"></div></li>

                            <li><div id="elayerFill59" class="bar"></div></li>

                            <li><div id="elayerFill60" class="bar"></div></li>

                            <li><div id="elayerFill61" class="bar"></div></li>

                            <li><div id="elayerFill62" class="bar"></div></li>

                    </ul>
                </div>
            </div>
        </form>
    </div>
    <br /><hr />
    <div id="visitors">

    </div>
    <!-- http://www.iconarchive.com -->
    <style type="text/css">
        #uplfile {
            color: pink;
        }
        #thelist {
            color: pink;
        }
        .thumb {
            height: 75px;
            border: 1px solid #000;
            margin: 10px 5px 0 0;
        }

		.enClear {
			-moz-box-shadow: 0px 10px 14px -7px #276873;
			-webkit-box-shadow: 0px 10px 14px -7px #276873;
			box-shadow: 0px 10px 14px -7px #276873;
			background: -webkit-gradient(linear, left top, left bottom, color-stop(0.05, #599bb3), color-stop(1, #408c99));
			background: -moz-linear-gradient(top, #599bb3 5%, #408c99 100%);
			background: -webkit-linear-gradient(top, #599bb3 5%, #408c99 100%);
			background: -o-linear-gradient(top, #599bb3 5%, #408c99 100%);
			background: -ms-linear-gradient(top, #599bb3 5%, #408c99 100%);
			background: linear-gradient(to bottom, #599bb3 5%, #408c99 100%);
			filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#599bb3', endColorstr='#408c99',GradientType=0);
			background-color: #599bb3;
			-moz-border-radius: 8px;
			-webkit-border-radius: 8px;
			border-radius: 8px;
			display: inline-block;
			cursor: pointer;
			color: #ffffff;
			font-family: Arial;
			font-size: 12px;
			font-weight: bold;
			padding: 10px 28px;
			text-decoration: none;
			text-shadow: 0px 1px 0px #3d768a;
		}
		.enClear:hover {
			background: -webkit-gradient(linear, left top, left bottom, color-stop(0.05, #408c99), color-stop(1, #599bb3));
			background: -moz-linear-gradient(top, #408c99 5%, #599bb3 100%);
			background: -webkit-linear-gradient(top, #408c99 5%, #599bb3 100%);
			background: -o-linear-gradient(top, #408c99 5%, #599bb3 100%);
			background: -ms-linear-gradient(top, #408c99 5%, #599bb3 100%);
			background: linear-gradient(to bottom, #408c99 5%, #599bb3 100%);
			filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#408c99', endColorstr='#599bb3',GradientType=0);
			background-color: #408c99;
		}
		.enClear:active {
			position: relative;
			top: 1px;
		}






        /* works, correctly... when user place cursor over object */
        /*div:hover span.hidkey {
            opacity: 1;
        }
        div:not(:hover) span.hidkey {
            opacity: 0;
        }*/

        /* works, but when cursors is completely off page, because criteria is div */
        /*div span.hidkey {
            opacity: 0;
        }
        div:hover span.hidkey {
            opacity: 1;
        }*/

        /* works & using, assigned by class
        .key_sect span.hidkey {
            visibility: hidden;
        }
        .key_sect:hover span.hidkey {
            visibility: visible;
        } */

        /*.key_sect input[type=text], textarea {
            -webkit-transition: all 0.30s ease-in-out;
            -moz-transition: all 0.30s ease-in-out;
            -ms-transition: all 0.30s ease-in-out;
            -o-transition: all 0.30s ease-in-out;
            outline: none;
            padding: 12px 20px;
            margin: 8px 0;
            border: 1px solid #DDDDDD;
            display: inline-block;
            box-sizing: border-box;
            text-shadow: 0;
        }

        .key_sect input[type=text]:focus {
            box-shadow: 0 0 5px rgba(81, 203, 238, 1);
            padding: 3px 0px 3px 3px;
            margin: 5px 1px 3px 0px;
            border: 1px solid rgba(81, 203, 238, 1);
        }*/



        #kstxtenc {
            width: 99%;
            height: 50px;
            padding: 5px;
            /*-webkit-transition: all 0.30s ease-in-out;
            -moz-transition: all 0.30s ease-in-out;
            -ms-transition: all 0.30s ease-in-out;
            -o-transition: all 0.30s ease-in-out;*/
            display: none;
            outline: none;
            /*padding: 12px 20px;*/
            /*margin: 8px 0;*/
            border: 1px solid #DDDDDD;
            /*display: inline-block;*/
            box-sizing: border-box;
            /*text-shadow: 0 0 5px rgba(0, 0, 0, 0.9);*/
            /*text-shadow: 0;*/
            text-align: center;
            line-height: 50px;
            /*vertical-align: text-bottom; nw*/
            color: white;
            font: bold 20px sans-serif;
        }
        #enc_ek {
            /*border-style: dotted;
            border-width: 5px;
            border-color: green;*/

            /*make the text blurry*/ /*these two*/
            /*color: transparent;*/
            /*text-shadow: 0 0 5px rgba(0, 0, 0, 0.9);*/
            /*opacity: 0.25;*/

            font: bold 15px sans-serif;
            background-color: #d8e5e5;
            width: 99%;
            height: 50px;
            padding: 5px;
        }
    </style>

    <!-- <script type="text/javascript" src="../static/js/crypt-encrypt001.js"></script> -->
    <script type="text/javascript">
        var num_ct = pyList("[&#39;One&#39;, &#39;Two&#39;, &#39;Three&#39;, &#39;Four&#39;, &#39;Five&#39;, &#39;Six&#39;]");
        // console.log(num_ct[0][0]);
        var encls = document.body.getElementsByTagName('*'); // get all the tags on page
        var eprogdply1 = document.getElementById("eprog1");
        var eprogdply2 = document.getElementById("eprog2");
        var eflociph = document.querySelectorAll(".cyphflw"); // get all with this class
        var ebarciph = document.querySelectorAll(".bar");
        var shwfle = document.getElementById('thelist');
        var instr_div = document.getElementById('instruct_div'); // instruction section
        var targ_div = document.getElementById('target_div'); // target section
        var time_div = document.getElementById('timer_div'); // timer section
        var spec_div = document.getElementById('special_div'); // special section
        var tm1dsp = document.getElementById("timdsply1"); // 24hr display
        var tm2dsp = document.getElementById("timdsply2"); // 24hr display
        var tm1obj = document.getElementById("start_tm"); // time object
        var tm2obj = document.getElementById("end_tm"); // time object
        var dt1obj = document.getElementById("start_dt"); // date object
        var dt2obj = document.getElementById("end_dt"); // date object
        var dilobj = document.getElementById("miscdial");
        var secobj = document.getElementById("misc2nd");
        var enctihdfld = document.getElementsByClassName('enctihdFld'); // get the hidden timer fields
        var enctghdfld = document.getElementsByClassName('enctghdFld'); // get the hidden target fields
        var encsphdfld = document.getElementsByClassName('encsphdFld'); // get the hidden target fields
        var closeMebot = document.getElementsByClassName("closebot")[0];
        var encinprogrss;

        var loop = setInterval(encounter, 1000);

        var tmp1, tmp2, tmp3;
        document.getElementById("mwrap").style.backgroundImage = "url('../static/img/matrix4.gif')";
        // document.getElementById("mwrap").style.backgroundImage = 'none';


        // var loadFile = function(event) { depreciated

        //     var reader = new FileReader();
        //     var fname = document.getElementById("uplfile").value;
        //     var ext = fname.substr((~-fname.lastIndexOf(".") >>> 0) + 2);
        //     fpth = "../static/img/file_" + ext + ".jpg"
        //     reader.onload = function(){
        //         if (ext == 'jpg') {
        //             shwfle.src = reader.result;
        //         } else {
        //             shwfle.src = fpth;
        //         };
        //     };
        //     options: FileReader.readAsText,FileReader.readAsArrayBuffer,FileReader.readAsBinaryString
        //     reader.readAsDataURL(event.target.files[0]);
        // };

        // Listeners
        document.getElementById('uplfile').addEventListener('change',fileSelect,false);
        document.getElementById('kstxtenc').addEventListener('mouseover',tog1EntKeyEnc,false);
        document.getElementById('enc_ek').addEventListener('mouseout',tog2EntKeyEnc,false);
        // document.addEventListener('keyup', function (e) { depreciated... using blur function
        //     chkTabpressEnc(e);  check for tab press
        // }, false);
        // Focus

        $( "#enc_ek" ).blur(function() {
            // alert( "Handler for .blur() called." );
            console.log('Exit Object of choice');
            tog2EntKeyEnc(this); // use this instead of keypress
        });


        // #note: the input button will be process regardless because of form
        for (c = 0; c < encls.length; c++) {
            // cycle through all tags
            // tabIndexs
            // tabidx = encls[c].tabIndex;
            // console.log(c + '\tTab Index: ' + tabidx);
            // onClicks
            encls[c].onclick = function() {
                // check if the selected c tag has a click function
                // console.log ("\n\nYou've Clicked: " + this.tagName);
                if (this.tagName == 'A') {
                    if (this.className == 'linktopBtns') {
                        console.log("\t-->\t" + this.id);
                    } else if (this.className == 'ReadMe') {
                        console.log('Read Entry');
                        encRead();
                    } else if (this.className == 'enClear') {
                        if (['enclr_pw'].indexOf(this.id) != -1) {
                            console.log('Clear Password');
                            clrPassWrdEntry();
                        } else if (['enclr_en'].indexOf(this.id) != -1) {
                            console.log('Clear Entry');
                            clrTextEntry()
                        } else {
                            console.log("Button ID: " + this.id + "\t...it's Class: " + this.className + "\n...Not Setup");
                        };
                    } else {
                        console.log(this.tagName + '\tThis Process was not Setup: ' + this.className + '\n-> ' + this.id);
                    };
                } else if (this.tagName == 'BUTTON') {
                    if (this.className == 'fctbut') {
                        // console.log("\t-->\t" + this.id + "\tselected");
                        if (['encbut','encmal'].indexOf(this.id) != -1) {
                            // console.log("Encrypt Button Press Do Encryption");
                            // console.log('START Animation Process');

                            // read cipher level
                            var stmp = document.getElementById("ciplvl").value
                            console.log('Cipher Level: ' + stmp)
                            // store value in v2pass
                            document.getElementById('enc_level').value = stmp

                            tmp1 = document.getElementById("enc_ek").value
                            if (tmp1.length != 0) {
                                encshwanim();
                            };
                        } else {
                            console.log("Button ID: " + this.id + "\t...it's Class: " + this.className + "\n...Not Setup");
                        };
                    } else if (this.className == "clrbut") {
                        // only one no need to check the id
                        // console.log(this.className + "\t-->\t" + this.id + "\tselected");
                        enclranim();
                        enclrfeld()
                    } else if (this.className == "topBtns") {
                        console.log(this.className + "\t-->\t" + this.id + "\tselected");
                        if (this.id == "navbut") {
                            openNav();
                        } else if (this.id == "showIn_e") {
                            showInstruction();
                        } else if (this.id == "showTg_e") {
                            showTarget();
                        } else if (this.id == "showTi_e") {
                            showTime();
                        } else if (this.id == "showSp_e") {
                            showSpecial();
                        } else {
                            console.log("Button ID: " + this.id + "\t...it's Class: " + this.className + "\n...Not Setup");
                        };
                    } else if (this.className == "acpdlg") {
                        document.getElementById("encrapper").style = "margin-top: 0px;"
                        if (this.id == "submitSp") {
                            spec_sub();
                        } else if (this.id == "submitTi") {
                            time_sub();
                        } else if (this.id == "submitTg") {
                            targ_sub();
                        } else {
                            console.log("Button ID: " + this.id + "\t...it's Class: " + this.className + "\n...Not Setup");
                        };
                    } else if (this.className == "xitdlg") {
                        document.getElementById("encrapper").style = "margin-top: 0px;"
                        if (this.id == "xit_instr") {
                            instr_exit();
                        } else if (this.id == "xit_targ") {
                            targ_exit();
                        } else if (this.id == "xit_time") {
                            time_exit();
                        } else if (this.id == "xit_spec") {
                            spec_exit();
                        } else {
                            console.log("Button ID: " + this.id + "\t...it's Class: " + this.className + "\n...Not Setup");
                        };
                    } else if ([].indexOf(this.className) != -1) {
                        // Nothing Need For These As Yet
                    } else {
                        console.log('(Button) This Process was not Setup: ' + this.className + '\n' + this.id);
                    };
                } else if (this.tagName == 'DIV') {
                } else if (this.tagName == 'FORM') {
                } else if (this.tagName == 'INPUT') {
                    if (this.className == "tfilemk") {
                        console.log("\t-->\t" + this.id + "\tselected");
                        shwfle.style.display = "inline";
                    } else if (this.className == "choosefile") {
                        // fileSelect(this); controlling by eventlistener
                    } else if (this.className == "datepicker") {
                        if (this.id == "start_dt") {
                            console.log('Start Date Entry:');
                            $('#enc_date1').val($('#start_dt').val());
                        } else if (this.id == "start_tm") {
                            console.log('Start Time Entry:');
                        } else if (this.id == "end_dt") {
                            console.log('End Date Entry:');
                        } else if (this.id == "end_tm") {
                            console.log('End Time Entry:');
                        } else {
                            console.log("Button ID: " + this.id + "\t...it's Class: " + this.className + "\n...Not Setup");
                        };
                    } else if (["enter_ekey"].indexOf(this.className) != -1) {
                        // Nothing Need For These As Yet
                    } else {
                        console.log('(INPUT) This Process was not Setup: ' + this.className + '\n' + this.id);
                    };
                } else if (this.tagName == 'TD') {
                    if (this.className == 'fctbut') {
                    } else {
                        console.log('This Process was not Setup: ' + this.className + '\n' + this.id);
                    };
                } else if (this.tagName == 'OPTION') {
                    if (this.className == 'eselbnfrom') {
                        console.log('What Next?');
                        // read cipher level
                        var stmp = document.getElementById("ciplvl").value
                        console.log('Cipher Level: ' + stmp)
                        // store value in v2pass
                        document.getElementById('enc_level').value = stmp

                    } else {
                        console.log('This Process was not Setup: ' + this.className + '\n' + this.id);
                    };
                } else if (this.tagName == 'TEXTAREA') {
                    // Nothing Need For These As Yet
                } else if (this.tagName == 'SPAN') {
                    if (this.className == '???') {
                        console.log("\t-->\t" + this.id);
                    } else {
                        console.log(this.tagName + '\tThis Process was not Setup: ' + this.className + '\n-> ' + this.id);
                    };
                } else {
                    console.log('Tag Name <<' + this.tagName + ">>\tNot Setup!!!" + ' ID: ' + this.id);
                };
            };
        };

        function encounter() {
            // setup counter here to handle the animation starting a encryption.
            // cstatus = 'ended';
            // encinprogrss = false;
            c++;
            tnum = c % 8; // testing display
            tnum1 = c % 48; // timer for display
            tnum2 = c % 11;
            // console.log('inside timer loop. ' + tnum);
        };

        // https://www.html5rocks.com/en/tutorials/file/dndfiles/
        function fileSelect(evt) {
            console.log('...inside fileSelect')
            var files = evt.target.files; // File list objects
            console.log(files);
            // files is a FileList of File objects. List some properties.
            var output = [];
            for (var i = 0, f; f = files[i]; i++) {
                adjsize = Math.ceil(f.size / 1000);
                var ext = f.name.substr((~-f.name.lastIndexOf(".") >>> 0) + 2);
                // // Only process image files.
                // if (!f.type.match('image.*')) {
                //     continue;
                // }
                var fpth = "../static/img/file_" + ext + ".jpg"
                console.log('type: ' + ext);
                output.push('<li><strong>', escape(f.name), '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;',
                adjsize, ' kb',
                // '</strong> (', f.type || 'n/a', ') - ', f.size,
                // ' bytes, last modified: ',
                // f.lastModified ? f.lastModifiedDate.toLocaleDateString() : 'n/a',
                '</li>');
                var reader = new FileReader();
                // Closure to capture the file information.
                reader.onload = (function(theFile) {
                    return function(e) {
                        // Render thumbnail.
                        var span = document.createElement('span');
                        // span.innerHTML = ['<img class="thumb" src="', e.target.result,
                        //     '" title="', escape(theFile.name), '"/>'].join('');
                        var ext = theFile.name.substr((~-theFile.name.lastIndexOf(".") >>> 0) + 2);
                        var fpth = "../static/img/file_" + ext + ".jpg"
                        console.log('the image path: ' + fpth.name);
                        span.innerHTML = ['<img class="thumb" src="' + fpth + '" title="', escape(theFile.name), '"/>'].join('');
                        document.getElementById('thelist').insertBefore(span, null);
                    };
                })(f);

                // Read in the image file as a data URL.
                reader.readAsDataURL(f);


            };
            document.getElementById('thelist').innerHTML = '<ul>' + output.join('') + '</ul>';
        };
        // function chkTabpressEnc(e) { depreciated
        //     // console.log('Some Button Was Pressed\t' + e);
        //     if (e.keyCode === 9) {
        //         var ele = document.activeElement;
        //         console.log('\tTab Button Pressed: ' + ele.id);
        //         if (ele.id != 'enc_ek' || ele.id == 'enc_ed') {
        //             tog2EntKeyEnc(ele);
        //         };
        //     };
        // };
        function tog2EntKeyEnc(evt) {
            var tkey = document.getElementById('enc_ek').value;
            console.log('\n\t\t...inside toggle OFF Enter Key StaticText');
            console.log(tkey.length + '\tKey Content: ' + tkey);
            if (tkey.length == 0) {
                document.getElementById('kstxtenc').style.display="none";
                document.getElementById('enc_ek').style.display="block";
            } else {
                document.getElementById('enc_ek').style.display="none";
                document.getElementById('kstxtenc').style.display="block";
            };
        };
        function tog1EntKeyEnc(evt) {
            var tkey = document.getElementById('enc_ek').value;
            document.getElementById('kstxtenc').style.display="none";
            document.getElementById('enc_ek').style.display="block";
            console.log('\n\t...inside toggle ON Enter Key StaticText');
        };

        function clrPassWrdEntry() {
            console.log('Clear <> Password');
            document.getElementById('enc_ek').value = null;
            tog2EntKeyEnc(self);
        };

        function clrTextEntry() {
            console.log('Clear <> Text Entry');
            document.getElementById('enc_ed').value = null;
        };

        function encRead() {
            // the text area value & read it
            var temp = document.getElementById('enc_ed').value;
            console.log('...inside read: ' + temp);
            if (temp.length > 0) {
                sayIt(temp);
            };
        };
        function encshwanim() {
            document.getElementById("mwrap").style.backgroundImage = "url('../static/img/matrix5.gif')";
            eprogdply1.style.display = 'block'; // reveal div with animation
            eprogdply2.style.display = 'block';
            for (var i=0; i < eflociph.length; i++) {
                eflociph[i].style.webkitAnimationPlayState = "running";
            };
            for (var i=0; i < ebarciph.length; i++) {
                ebarciph[i].style.webkitAnimationPlayState = "running";
            };
        };
        function enclranim() {
            eprogdply1.style.display = "none";
            eprogdply2.style.display = "none";
            // shwfle.src = "";
            shwfle.style.display = "none";
            for (var i=0; i < eflociph.length; i++) {
                eflociph[i].style.webkitAnimationPlayState = "paused";
            };
            for (var i=0; i < ebarciph.length; i++) {
                ebarciph[i].style.webkitAnimationPlayState = "paused";
            };
        };
        function enclrfeld() {
            // clear text/contents
            tm1dsp.value = null;
            tm2dsp.value = null;
            tm1obj.value = null;
            tm2obj.value = null;
            dt1obj.value = null;
            dt2obj.value = null;
            dilobj.value = null;
            secobj.value = null;
            document.getElementById("flashed").innerHTML = null;
            // document.getElementById("encrapper").style = "margin-top: 0px;"
            // console.log(num_ct[0].length + '\tType: ' + typeof num_ct[0]);
            // var tmpx = num_ct[0].split("', '");
            for (i=0; i < enctghdfld.length; i++) {
                enctghdfld[i].value = '';
            };
            for (i=0; i < enctihdfld.length; i++) {
                enctihdfld[i].value = '';
            };
            for (i=0; i < encsphdfld.length; i++) {
                encsphdfld[i].value = '';
            };
        };
        function showInstruction() {
            targ_div.style.display = "none";
            time_div.style.display = "none";
            spec_div.style.display = "none";
            if (instr_div.style.display === 'none') {
                instr_div.style.display = 'block';
            } else {
                instr_div.style.display = 'none';
            };
        };
        function showTarget() {
            instr_div.style.display = "none";
            time_div.style.display = "none";
            spec_div.style.display = "none";
            if (targ_div.style.display === 'none') {
                targ_div.style.display = 'block';
            } else {
                targ_div.style.display = 'none';
            };
        };
        function showTime() {
            var test_date = new Date();
            instr_div.style.display = "none";
            targ_div.style.display = "none";
            spec_div.style.display = "none";
            if (time_div.style.display === 'none') {
                time_div.style.display = 'block';
                // move main down
                document.getElementById("encrapper").style = "margin-top: 150px;"
            } else {
                time_div.style.display = 'none';
                // move main up
                document.getElementById("encrapper").style = "margin-top: 0px;"
            };
        };
        function showSpecial () {
            instr_div.style.display = "none";
            targ_div.style.display = "none";
            time_div.style.display = "none";
            if (spec_div.style.display === 'none') {
                spec_div.style.display = 'block';
            } else {
                spec_div.style.display = 'none';
            };
        };
        function instr_exit() {
            instr_div.style.display = "none";
        };
        function targ_exit() {
            targ_div.style.display = "none";
        };
        function time_exit() {
            time_div.style.display = "none";
        };
        function spec_exit() {
            spec_div.style.display = "none";
        };

        function targ_sub() {
            $('#enc_t_One').val($('#targ_One').val());
            $('#enc_t_Two').val($('#targ_Two').val());
            $('#enc_t_Three').val($('#targ_Three').val());
            $('#enc_t_Four').val($('#targ_Four').val());
            $('#enc_t_Five').val($('#targ_Five').val());
            $('#enc_t_Six').val($('#targ_Six').val());
            targ_div.style.display = "none";
        };
        function time_sub() {
            $('#enc_date1').val($('#start_dt').val());
            $('#enc_time1').val($('#start_tm').val());
            $('#enc_date2').val($('#end_dt').val());
            $('#enc_time2').val($('#end_tm').val());
            time_div.style.display = "none";
        };
        function spec_sub() {
            $('#enc_2nd').val($('#misc2nd').val());
            $('#enc_dial').val($('#miscdial').val());
            spec_div.style.display = "none";
        };

        $(document).ready(function(){
            $("#end_tm").focusout(function(){
                // alert("focus out.");
                tmp = tm2obj.value;
                proc = true;
                if (tmp.indexOf(':') == -1 || tmp.length > 5) {
                    proc = false;
                } else {
                    // colon present
                    var h = isNumeric(tmp);
                    var i = isNumeric(tmp.slice(0,2));
                    var j = isNumeric(tmp.slice(3,5));
                    var k = tmp.split(':');
                    // console.log('-->\t'+ k);
                    if (h == false && i == true && j == true) {
                        if (k[0].length == 2 && k[1].length == 2) {
                            if (parseInt(k[0]) > 23){
                                // ace adjust it on its own.
                                var hr = '23';
                                sayIt('Made an adjustment to your hour time');
                            } else {
                                var hr = k[0];
                            };
                            if (parseInt(k[1]) > 59){
                                var mn = '59';
                                sayIt('Made an adjustment to your minute time');
                            } else {
                                var mn = k[1];
                            };
                            tm2dsp.value = hr + ':' + mn
                        } else {
                            proc = false;
                        };
                    } else {
                        proc = false;
                    };
                };
                if (tmp.length != 0) {
                    if (proc == false) {
                        tm2dsp.value = 'ERROR';
                        sayIt('You have an error with your end time entry.');
                    };
                };
            });
        });

        $(document).ready(function(){
            $("#start_tm").focusout(function(){
                // alert("focus out.");
                tmp = tm1obj.value;
                proc = true;
                if (tmp.indexOf(':') == -1 || tmp.length > 5) {
                    proc = false;
                } else {
                    // colon present
                    var h = isNumeric(tmp);
                    var i = isNumeric(tmp.slice(0,2));
                    var j = isNumeric(tmp.slice(3,5));
                    var k = tmp.split(':');
                    console.log('-->\t'+ k);
                    if (h == false && i == true && j == true) {
                        if (k[0].length == 2 && k[1].length == 2) {
                            if (parseInt(k[0]) > 23){
                                var hr = '23';
                                sayIt('Made an adjustment to your hour time');
                            } else {
                                var hr = k[0];
                            };
                            if (parseInt(k[1]) > 59){
                                var mn = '59';
                                sayIt('Made an adjustment to your minute time');
                            } else {
                                var mn = k[1];
                            };
                            tm1dsp.value = hr + ':' + mn
                        } else {
                            proc = false;
                        };
                    } else {
                        proc = false;
                    };
                };
                if (tmp.length != 0) {
                    if (proc == false) {
                        tm1dsp.value = 'ERROR';
                        sayIt('You have an error with your start time entry.');
                    };
                };
            });
        });

        (function($) {
            $.fn.flash_message = function(options) {

              options = $.extend({
                text: 'Done',
                time: 2000,
                how: 'before',
                class_name: ''
              }, options);

              return $(this).each(function() {
                if( $(this).parent().find('.flash_message').get(0) )
                  return;

                var message = $('<span />', {
                  'class': 'flash_message ' + options.class_name,
                  text: options.text
                }).hide().fadeIn('fast');

                $(this)[options.how](message);

                message.delay(options.time).fadeOut('normal', function() {
                  $(this).remove();
                });

              });
            };
        })(jQuery);




    </script>

        <!-- <input type="text" id="cursorX" size="3"> X-position of the mouse cursor
        <br /><br />
        <input type="text" id="cursorY" size="3"> Y-position of the mouse cursor -->
    </div>

    <div id="mySidenav" class="sidenav">
        <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">&times;</a>
        <a href="/cryption/welcome/">Home</a>

            <hr/>
            <a href="/cryption/login/">Login</a>
            <hr/>

        <a href="/cryption/decrypt/">Decrypt</a>
        <a href="/cryption/encrypt/">Encrypt</a>
        <a href="/cryption/about/">About</a> <!-- <a href="/cryption/about/">About</a> -->
        <a href="/cryption/blog/">Blog</a>
        <a href="/cryption/viscalc/">Calculator</a>
        <a href="/cryption/utility/">Utility</a>
        <a href="/cryption/contact/">Contact</a>
        <!-- <a href="/cryption/loadpage/">LoadPage</a> -->

            <a href="/cryption/joinup/">Sign Up</a>

        <a href="/cryption/scoreboard/">Score Board</a>

        <hr/>

    </div>

    <br />
    <script>

        // var mls = document.body.getElementsByTagName('*'); // get all the tags on page

        // for (c = 0; c < mls.length; c++) { # this will bypass all the other pages options
        //     // cycle through all tags
        //     mls[c].onclick = function() {
        //         // check if the selected c tag has a click function
        //         console.log ("\n\nYou've <M> Clicked\n  Tag Name: [ " + this.tagName + " ]\tID: [ " + this.id + " ] ");
        //     };
        // };


        /* Set the width of the side navigation to 250px */
        function openNav() {
            document.getElementById("mySidenav").style.width = "270px";
            document.body.style.backgroundColor = "rgba(0,0,0,0.4)";
        };

        /* Set the width of the side navigation to 0 */
        function closeNav() {
            document.getElementById("mySidenav").style.width = "0";
             document.body.style.backgroundColor = "white";
        };
    </script>
</div>
</body>
</html>
